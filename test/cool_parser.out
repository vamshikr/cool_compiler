Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT_MULTILINE
    NEWLINE
    COMMENT_SINGLELINE

Grammar

Rule 0     S' -> program
Rule 1     program -> class ; program
Rule 2     program -> class ;
Rule 3     class -> CLASS TYPEID baseclass { features }
Rule 4     baseclass -> INHERITS TYPEID
Rule 5     baseclass -> empty
Rule 6     features -> feature ; features
Rule 7     features -> empty
Rule 8     feature -> variabledefinition
Rule 9     feature -> methoddefinition
Rule 10    methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr }
Rule 11    variabledefinition -> variabledeclaration variableinitialization
Rule 12    variabledeclaration -> OBJECTID : TYPEID
Rule 13    variableinitialization -> ASSIGN expr
Rule 14    variableinitialization -> empty
Rule 15    formalargs -> variabledeclaration , formalargs
Rule 16    formalargs -> variabledeclaration
Rule 17    formalargs -> empty
Rule 18    actualargs -> expr , actualargs
Rule 19    actualargs -> expr
Rule 20    actualargs -> empty
Rule 21    expr -> assignment
Rule 22    expr -> methodinvoke
Rule 23    expr -> localmethodinvoke
Rule 24    expr -> ifthenelse
Rule 25    expr -> whileloop
Rule 26    expr -> blockexpr
Rule 27    expr -> letexpr
Rule 28    expr -> caseexpr
Rule 29    expr -> NEW TYPEID
Rule 30    expr -> ISVOID expr
Rule 31    expr -> NOT expr
Rule 32    expr -> ~ expr
Rule 33    expr -> ( expr )
Rule 34    expr -> expr + expr
Rule 35    expr -> expr - expr
Rule 36    expr -> expr * expr
Rule 37    expr -> expr / expr
Rule 38    expr -> expr < expr
Rule 39    expr -> expr LE expr
Rule 40    expr -> expr = expr
Rule 41    expr -> INT_CONST
Rule 42    expr -> STR_CONST
Rule 43    expr -> BOOL_CONST
Rule 44    expr -> OBJECTID
Rule 45    assignment -> OBJECTID ASSIGN expr
Rule 46    letexpr -> LET variablelist IN expr
Rule 47    methodinvoke -> expr DOT OBJECTID ( actualargs )
Rule 48    methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs )
Rule 49    localmethodinvoke -> OBJECTID ( actualargs )
Rule 50    ifthenelse -> IF expr THEN expr ELSE expr FI
Rule 51    whileloop -> WHILE expr LOOP expr POOL
Rule 52    blockexpr -> { blockstatements }
Rule 53    blockstatements -> expr ; blockstatements
Rule 54    blockstatements -> expr ;
Rule 55    variablelist -> variabledefinition , variablelist
Rule 56    variablelist -> variabledefinition
Rule 57    caseexpr -> CASE expr OF casestatements ESAC
Rule 58    casestatements -> variabledeclaration DARROW expr ; casestatements
Rule 59    casestatements -> variabledeclaration DARROW expr ;
Rule 60    empty -> <empty>

Terminals, with rules where they appear

(                    : 10 33 47 48 49
)                    : 10 33 47 48 49
*                    : 36
+                    : 34
,                    : 15 18 55
-                    : 35
/                    : 37
:                    : 10 12
;                    : 1 2 6 53 54 58 59
<                    : 38
=                    : 40
@                    : 48
ASSIGN               : 13 45
BOOL_CONST           : 43
CASE                 : 57
CLASS                : 3
COMMENT_MULTILINE    : 
COMMENT_SINGLELINE   : 
DARROW               : 58 59
DOT                  : 47 48
ELSE                 : 50
ESAC                 : 57
FI                   : 50
IF                   : 50
IN                   : 46
INHERITS             : 4
INT_CONST            : 41
ISVOID               : 30
LE                   : 39
LET                  : 46
LOOP                 : 51
NEW                  : 29
NEWLINE              : 
NOT                  : 31
OBJECTID             : 10 12 44 45 47 48 49
OF                   : 57
POOL                 : 51
STR_CONST            : 42
THEN                 : 50
TYPEID               : 3 4 10 12 29 48
WHILE                : 51
error                : 
{                    : 3 10 52
}                    : 3 10 52
~                    : 32

Nonterminals, with rules where they appear

actualargs           : 18 47 48 49
assignment           : 21
baseclass            : 3
blockexpr            : 26
blockstatements      : 52 53
caseexpr             : 28
casestatements       : 57 58
class                : 1 2
empty                : 5 7 14 17 20
expr                 : 10 13 18 19 30 31 32 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 45 46 47 48 50 50 50 51 51 53 54 57 58 59
feature              : 6
features             : 3 6
formalargs           : 10 15
ifthenelse           : 24
letexpr              : 27
localmethodinvoke    : 23
methoddefinition     : 9
methodinvoke         : 22
program              : 1 0
variabledeclaration  : 11 15 16 58 59
variabledefinition   : 8 55 56
variableinitialization : 11
variablelist         : 46 55
whileloop            : 25

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class ; program
    (2) program -> . class ;
    (3) class -> . CLASS TYPEID baseclass { features }

    CLASS           shift and go to state 1

    class                          shift and go to state 3
    program                        shift and go to state 2

state 1

    (3) class -> CLASS . TYPEID baseclass { features }

    TYPEID          shift and go to state 4


state 2

    (0) S' -> program .



state 3

    (1) program -> class . ; program
    (2) program -> class . ;

    ;               shift and go to state 5


state 4

    (3) class -> CLASS TYPEID . baseclass { features }
    (4) baseclass -> . INHERITS TYPEID
    (5) baseclass -> . empty
    (60) empty -> .

    INHERITS        shift and go to state 7
    {               reduce using rule 60 (empty -> .)

    empty                          shift and go to state 6
    baseclass                      shift and go to state 8

state 5

    (1) program -> class ; . program
    (2) program -> class ; .
    (1) program -> . class ; program
    (2) program -> . class ;
    (3) class -> . CLASS TYPEID baseclass { features }

    $end            reduce using rule 2 (program -> class ; .)
    CLASS           shift and go to state 1

    class                          shift and go to state 3
    program                        shift and go to state 9

state 6

    (5) baseclass -> empty .

    {               reduce using rule 5 (baseclass -> empty .)


state 7

    (4) baseclass -> INHERITS . TYPEID

    TYPEID          shift and go to state 10


state 8

    (3) class -> CLASS TYPEID baseclass . { features }

    {               shift and go to state 11


state 9

    (1) program -> class ; program .

    $end            reduce using rule 1 (program -> class ; program .)


state 10

    (4) baseclass -> INHERITS TYPEID .

    {               reduce using rule 4 (baseclass -> INHERITS TYPEID .)


state 11

    (3) class -> CLASS TYPEID baseclass { . features }
    (6) features -> . feature ; features
    (7) features -> . empty
    (8) feature -> . variabledefinition
    (9) feature -> . methoddefinition
    (60) empty -> .
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (10) methoddefinition -> . OBJECTID ( formalargs ) : TYPEID { expr }
    (12) variabledeclaration -> . OBJECTID : TYPEID

    }               reduce using rule 60 (empty -> .)
    OBJECTID        shift and go to state 17

    features                       shift and go to state 12
    empty                          shift and go to state 13
    variabledeclaration            shift and go to state 16
    methoddefinition               shift and go to state 18
    variabledefinition             shift and go to state 14
    feature                        shift and go to state 15

state 12

    (3) class -> CLASS TYPEID baseclass { features . }

    }               shift and go to state 19


state 13

    (7) features -> empty .

    }               reduce using rule 7 (features -> empty .)


state 14

    (8) feature -> variabledefinition .

    ;               reduce using rule 8 (feature -> variabledefinition .)


state 15

    (6) features -> feature . ; features

    ;               shift and go to state 20


state 16

    (11) variabledefinition -> variabledeclaration . variableinitialization
    (13) variableinitialization -> . ASSIGN expr
    (14) variableinitialization -> . empty
    (60) empty -> .

    ASSIGN          shift and go to state 22
    ;               reduce using rule 60 (empty -> .)
    ,               reduce using rule 60 (empty -> .)
    IN              reduce using rule 60 (empty -> .)

    variableinitialization         shift and go to state 21
    empty                          shift and go to state 23

state 17

    (10) methoddefinition -> OBJECTID . ( formalargs ) : TYPEID { expr }
    (12) variabledeclaration -> OBJECTID . : TYPEID

    (               shift and go to state 25
    :               shift and go to state 24


state 18

    (9) feature -> methoddefinition .

    ;               reduce using rule 9 (feature -> methoddefinition .)


state 19

    (3) class -> CLASS TYPEID baseclass { features } .

    ;               reduce using rule 3 (class -> CLASS TYPEID baseclass { features } .)


state 20

    (6) features -> feature ; . features
    (6) features -> . feature ; features
    (7) features -> . empty
    (8) feature -> . variabledefinition
    (9) feature -> . methoddefinition
    (60) empty -> .
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (10) methoddefinition -> . OBJECTID ( formalargs ) : TYPEID { expr }
    (12) variabledeclaration -> . OBJECTID : TYPEID

    }               reduce using rule 60 (empty -> .)
    OBJECTID        shift and go to state 17

    features                       shift and go to state 26
    empty                          shift and go to state 13
    variabledeclaration            shift and go to state 16
    variabledefinition             shift and go to state 14
    methoddefinition               shift and go to state 18
    feature                        shift and go to state 15

state 21

    (11) variabledefinition -> variabledeclaration variableinitialization .

    ,               reduce using rule 11 (variabledefinition -> variabledeclaration variableinitialization .)
    IN              reduce using rule 11 (variabledefinition -> variabledeclaration variableinitialization .)
    ;               reduce using rule 11 (variabledefinition -> variabledeclaration variableinitialization .)


state 22

    (13) variableinitialization -> ASSIGN . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 38
    caseexpr                       shift and go to state 45

state 23

    (14) variableinitialization -> empty .

    ;               reduce using rule 14 (variableinitialization -> empty .)
    ,               reduce using rule 14 (variableinitialization -> empty .)
    IN              reduce using rule 14 (variableinitialization -> empty .)


state 24

    (12) variabledeclaration -> OBJECTID : . TYPEID

    TYPEID          shift and go to state 50


state 25

    (10) methoddefinition -> OBJECTID ( . formalargs ) : TYPEID { expr }
    (15) formalargs -> . variabledeclaration , formalargs
    (16) formalargs -> . variabledeclaration
    (17) formalargs -> . empty
    (12) variabledeclaration -> . OBJECTID : TYPEID
    (60) empty -> .

    OBJECTID        shift and go to state 54
    )               reduce using rule 60 (empty -> .)

    empty                          shift and go to state 51
    formalargs                     shift and go to state 52
    variabledeclaration            shift and go to state 53

state 26

    (6) features -> feature ; features .

    }               reduce using rule 6 (features -> feature ; features .)


state 27

    (43) expr -> BOOL_CONST .

    ,               reduce using rule 43 (expr -> BOOL_CONST .)
    +               reduce using rule 43 (expr -> BOOL_CONST .)
    -               reduce using rule 43 (expr -> BOOL_CONST .)
    *               reduce using rule 43 (expr -> BOOL_CONST .)
    /               reduce using rule 43 (expr -> BOOL_CONST .)
    <               reduce using rule 43 (expr -> BOOL_CONST .)
    LE              reduce using rule 43 (expr -> BOOL_CONST .)
    =               reduce using rule 43 (expr -> BOOL_CONST .)
    DOT             reduce using rule 43 (expr -> BOOL_CONST .)
    @               reduce using rule 43 (expr -> BOOL_CONST .)
    )               reduce using rule 43 (expr -> BOOL_CONST .)
    LOOP            reduce using rule 43 (expr -> BOOL_CONST .)
    ;               reduce using rule 43 (expr -> BOOL_CONST .)
    IN              reduce using rule 43 (expr -> BOOL_CONST .)
    THEN            reduce using rule 43 (expr -> BOOL_CONST .)
    OF              reduce using rule 43 (expr -> BOOL_CONST .)
    ELSE            reduce using rule 43 (expr -> BOOL_CONST .)
    POOL            reduce using rule 43 (expr -> BOOL_CONST .)
    FI              reduce using rule 43 (expr -> BOOL_CONST .)
    }               reduce using rule 43 (expr -> BOOL_CONST .)


state 28

    (24) expr -> ifthenelse .

    ,               reduce using rule 24 (expr -> ifthenelse .)
    +               reduce using rule 24 (expr -> ifthenelse .)
    -               reduce using rule 24 (expr -> ifthenelse .)
    *               reduce using rule 24 (expr -> ifthenelse .)
    /               reduce using rule 24 (expr -> ifthenelse .)
    <               reduce using rule 24 (expr -> ifthenelse .)
    LE              reduce using rule 24 (expr -> ifthenelse .)
    =               reduce using rule 24 (expr -> ifthenelse .)
    DOT             reduce using rule 24 (expr -> ifthenelse .)
    @               reduce using rule 24 (expr -> ifthenelse .)
    )               reduce using rule 24 (expr -> ifthenelse .)
    LOOP            reduce using rule 24 (expr -> ifthenelse .)
    ;               reduce using rule 24 (expr -> ifthenelse .)
    IN              reduce using rule 24 (expr -> ifthenelse .)
    THEN            reduce using rule 24 (expr -> ifthenelse .)
    OF              reduce using rule 24 (expr -> ifthenelse .)
    ELSE            reduce using rule 24 (expr -> ifthenelse .)
    POOL            reduce using rule 24 (expr -> ifthenelse .)
    FI              reduce using rule 24 (expr -> ifthenelse .)
    }               reduce using rule 24 (expr -> ifthenelse .)


state 29

    (42) expr -> STR_CONST .

    ,               reduce using rule 42 (expr -> STR_CONST .)
    +               reduce using rule 42 (expr -> STR_CONST .)
    -               reduce using rule 42 (expr -> STR_CONST .)
    *               reduce using rule 42 (expr -> STR_CONST .)
    /               reduce using rule 42 (expr -> STR_CONST .)
    <               reduce using rule 42 (expr -> STR_CONST .)
    LE              reduce using rule 42 (expr -> STR_CONST .)
    =               reduce using rule 42 (expr -> STR_CONST .)
    DOT             reduce using rule 42 (expr -> STR_CONST .)
    @               reduce using rule 42 (expr -> STR_CONST .)
    )               reduce using rule 42 (expr -> STR_CONST .)
    LOOP            reduce using rule 42 (expr -> STR_CONST .)
    ;               reduce using rule 42 (expr -> STR_CONST .)
    IN              reduce using rule 42 (expr -> STR_CONST .)
    THEN            reduce using rule 42 (expr -> STR_CONST .)
    OF              reduce using rule 42 (expr -> STR_CONST .)
    ELSE            reduce using rule 42 (expr -> STR_CONST .)
    POOL            reduce using rule 42 (expr -> STR_CONST .)
    FI              reduce using rule 42 (expr -> STR_CONST .)
    }               reduce using rule 42 (expr -> STR_CONST .)


state 30

    (41) expr -> INT_CONST .

    ,               reduce using rule 41 (expr -> INT_CONST .)
    +               reduce using rule 41 (expr -> INT_CONST .)
    -               reduce using rule 41 (expr -> INT_CONST .)
    *               reduce using rule 41 (expr -> INT_CONST .)
    /               reduce using rule 41 (expr -> INT_CONST .)
    <               reduce using rule 41 (expr -> INT_CONST .)
    LE              reduce using rule 41 (expr -> INT_CONST .)
    =               reduce using rule 41 (expr -> INT_CONST .)
    DOT             reduce using rule 41 (expr -> INT_CONST .)
    @               reduce using rule 41 (expr -> INT_CONST .)
    )               reduce using rule 41 (expr -> INT_CONST .)
    LOOP            reduce using rule 41 (expr -> INT_CONST .)
    ;               reduce using rule 41 (expr -> INT_CONST .)
    IN              reduce using rule 41 (expr -> INT_CONST .)
    THEN            reduce using rule 41 (expr -> INT_CONST .)
    OF              reduce using rule 41 (expr -> INT_CONST .)
    ELSE            reduce using rule 41 (expr -> INT_CONST .)
    POOL            reduce using rule 41 (expr -> INT_CONST .)
    FI              reduce using rule 41 (expr -> INT_CONST .)
    }               reduce using rule 41 (expr -> INT_CONST .)


state 31

    (22) expr -> methodinvoke .

    ,               reduce using rule 22 (expr -> methodinvoke .)
    +               reduce using rule 22 (expr -> methodinvoke .)
    -               reduce using rule 22 (expr -> methodinvoke .)
    *               reduce using rule 22 (expr -> methodinvoke .)
    /               reduce using rule 22 (expr -> methodinvoke .)
    <               reduce using rule 22 (expr -> methodinvoke .)
    LE              reduce using rule 22 (expr -> methodinvoke .)
    =               reduce using rule 22 (expr -> methodinvoke .)
    DOT             reduce using rule 22 (expr -> methodinvoke .)
    @               reduce using rule 22 (expr -> methodinvoke .)
    )               reduce using rule 22 (expr -> methodinvoke .)
    LOOP            reduce using rule 22 (expr -> methodinvoke .)
    ;               reduce using rule 22 (expr -> methodinvoke .)
    IN              reduce using rule 22 (expr -> methodinvoke .)
    THEN            reduce using rule 22 (expr -> methodinvoke .)
    OF              reduce using rule 22 (expr -> methodinvoke .)
    ELSE            reduce using rule 22 (expr -> methodinvoke .)
    POOL            reduce using rule 22 (expr -> methodinvoke .)
    FI              reduce using rule 22 (expr -> methodinvoke .)
    }               reduce using rule 22 (expr -> methodinvoke .)


state 32

    (32) expr -> ~ . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 55
    caseexpr                       shift and go to state 45

state 33

    (29) expr -> NEW . TYPEID

    TYPEID          shift and go to state 56


state 34

    (23) expr -> localmethodinvoke .

    ,               reduce using rule 23 (expr -> localmethodinvoke .)
    +               reduce using rule 23 (expr -> localmethodinvoke .)
    -               reduce using rule 23 (expr -> localmethodinvoke .)
    *               reduce using rule 23 (expr -> localmethodinvoke .)
    /               reduce using rule 23 (expr -> localmethodinvoke .)
    <               reduce using rule 23 (expr -> localmethodinvoke .)
    LE              reduce using rule 23 (expr -> localmethodinvoke .)
    =               reduce using rule 23 (expr -> localmethodinvoke .)
    DOT             reduce using rule 23 (expr -> localmethodinvoke .)
    @               reduce using rule 23 (expr -> localmethodinvoke .)
    )               reduce using rule 23 (expr -> localmethodinvoke .)
    LOOP            reduce using rule 23 (expr -> localmethodinvoke .)
    ;               reduce using rule 23 (expr -> localmethodinvoke .)
    IN              reduce using rule 23 (expr -> localmethodinvoke .)
    THEN            reduce using rule 23 (expr -> localmethodinvoke .)
    OF              reduce using rule 23 (expr -> localmethodinvoke .)
    ELSE            reduce using rule 23 (expr -> localmethodinvoke .)
    POOL            reduce using rule 23 (expr -> localmethodinvoke .)
    FI              reduce using rule 23 (expr -> localmethodinvoke .)
    }               reduce using rule 23 (expr -> localmethodinvoke .)


state 35

    (44) expr -> OBJECTID .
    (45) assignment -> OBJECTID . ASSIGN expr
    (49) localmethodinvoke -> OBJECTID . ( actualargs )

    ,               reduce using rule 44 (expr -> OBJECTID .)
    +               reduce using rule 44 (expr -> OBJECTID .)
    -               reduce using rule 44 (expr -> OBJECTID .)
    *               reduce using rule 44 (expr -> OBJECTID .)
    /               reduce using rule 44 (expr -> OBJECTID .)
    <               reduce using rule 44 (expr -> OBJECTID .)
    LE              reduce using rule 44 (expr -> OBJECTID .)
    =               reduce using rule 44 (expr -> OBJECTID .)
    DOT             reduce using rule 44 (expr -> OBJECTID .)
    @               reduce using rule 44 (expr -> OBJECTID .)
    )               reduce using rule 44 (expr -> OBJECTID .)
    LOOP            reduce using rule 44 (expr -> OBJECTID .)
    ;               reduce using rule 44 (expr -> OBJECTID .)
    IN              reduce using rule 44 (expr -> OBJECTID .)
    THEN            reduce using rule 44 (expr -> OBJECTID .)
    OF              reduce using rule 44 (expr -> OBJECTID .)
    ELSE            reduce using rule 44 (expr -> OBJECTID .)
    POOL            reduce using rule 44 (expr -> OBJECTID .)
    FI              reduce using rule 44 (expr -> OBJECTID .)
    }               reduce using rule 44 (expr -> OBJECTID .)
    ASSIGN          shift and go to state 57
    (               shift and go to state 58


state 36

    (46) letexpr -> LET . variablelist IN expr
    (55) variablelist -> . variabledefinition , variablelist
    (56) variablelist -> . variabledefinition
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (12) variabledeclaration -> . OBJECTID : TYPEID

    OBJECTID        shift and go to state 54

    variabledefinition             shift and go to state 60
    variablelist                   shift and go to state 59
    variabledeclaration            shift and go to state 16

state 37

    (26) expr -> blockexpr .

    ,               reduce using rule 26 (expr -> blockexpr .)
    +               reduce using rule 26 (expr -> blockexpr .)
    -               reduce using rule 26 (expr -> blockexpr .)
    *               reduce using rule 26 (expr -> blockexpr .)
    /               reduce using rule 26 (expr -> blockexpr .)
    <               reduce using rule 26 (expr -> blockexpr .)
    LE              reduce using rule 26 (expr -> blockexpr .)
    =               reduce using rule 26 (expr -> blockexpr .)
    DOT             reduce using rule 26 (expr -> blockexpr .)
    @               reduce using rule 26 (expr -> blockexpr .)
    )               reduce using rule 26 (expr -> blockexpr .)
    LOOP            reduce using rule 26 (expr -> blockexpr .)
    ;               reduce using rule 26 (expr -> blockexpr .)
    IN              reduce using rule 26 (expr -> blockexpr .)
    THEN            reduce using rule 26 (expr -> blockexpr .)
    OF              reduce using rule 26 (expr -> blockexpr .)
    ELSE            reduce using rule 26 (expr -> blockexpr .)
    POOL            reduce using rule 26 (expr -> blockexpr .)
    FI              reduce using rule 26 (expr -> blockexpr .)
    }               reduce using rule 26 (expr -> blockexpr .)


state 38

    (13) variableinitialization -> ASSIGN expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               reduce using rule 13 (variableinitialization -> ASSIGN expr .)
    ,               reduce using rule 13 (variableinitialization -> ASSIGN expr .)
    IN              reduce using rule 13 (variableinitialization -> ASSIGN expr .)
    +               shift and go to state 66
    -               shift and go to state 64
    *               shift and go to state 62
    /               shift and go to state 67
    <               shift and go to state 69
    LE              shift and go to state 68
    =               shift and go to state 61
    DOT             shift and go to state 63
    @               shift and go to state 65


state 39

    (33) expr -> ( . expr )
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 70
    caseexpr                       shift and go to state 45

state 40

    (27) expr -> letexpr .

    ,               reduce using rule 27 (expr -> letexpr .)
    +               reduce using rule 27 (expr -> letexpr .)
    -               reduce using rule 27 (expr -> letexpr .)
    *               reduce using rule 27 (expr -> letexpr .)
    /               reduce using rule 27 (expr -> letexpr .)
    <               reduce using rule 27 (expr -> letexpr .)
    LE              reduce using rule 27 (expr -> letexpr .)
    =               reduce using rule 27 (expr -> letexpr .)
    DOT             reduce using rule 27 (expr -> letexpr .)
    @               reduce using rule 27 (expr -> letexpr .)
    )               reduce using rule 27 (expr -> letexpr .)
    LOOP            reduce using rule 27 (expr -> letexpr .)
    ;               reduce using rule 27 (expr -> letexpr .)
    IN              reduce using rule 27 (expr -> letexpr .)
    THEN            reduce using rule 27 (expr -> letexpr .)
    OF              reduce using rule 27 (expr -> letexpr .)
    ELSE            reduce using rule 27 (expr -> letexpr .)
    POOL            reduce using rule 27 (expr -> letexpr .)
    FI              reduce using rule 27 (expr -> letexpr .)
    }               reduce using rule 27 (expr -> letexpr .)


state 41

    (21) expr -> assignment .

    ,               reduce using rule 21 (expr -> assignment .)
    +               reduce using rule 21 (expr -> assignment .)
    -               reduce using rule 21 (expr -> assignment .)
    *               reduce using rule 21 (expr -> assignment .)
    /               reduce using rule 21 (expr -> assignment .)
    <               reduce using rule 21 (expr -> assignment .)
    LE              reduce using rule 21 (expr -> assignment .)
    =               reduce using rule 21 (expr -> assignment .)
    DOT             reduce using rule 21 (expr -> assignment .)
    @               reduce using rule 21 (expr -> assignment .)
    )               reduce using rule 21 (expr -> assignment .)
    LOOP            reduce using rule 21 (expr -> assignment .)
    ;               reduce using rule 21 (expr -> assignment .)
    IN              reduce using rule 21 (expr -> assignment .)
    THEN            reduce using rule 21 (expr -> assignment .)
    OF              reduce using rule 21 (expr -> assignment .)
    ELSE            reduce using rule 21 (expr -> assignment .)
    POOL            reduce using rule 21 (expr -> assignment .)
    FI              reduce using rule 21 (expr -> assignment .)
    }               reduce using rule 21 (expr -> assignment .)


state 42

    (52) blockexpr -> { . blockstatements }
    (53) blockstatements -> . expr ; blockstatements
    (54) blockstatements -> . expr ;
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    blockstatements                shift and go to state 72
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 71
    caseexpr                       shift and go to state 45

state 43

    (25) expr -> whileloop .

    ,               reduce using rule 25 (expr -> whileloop .)
    +               reduce using rule 25 (expr -> whileloop .)
    -               reduce using rule 25 (expr -> whileloop .)
    *               reduce using rule 25 (expr -> whileloop .)
    /               reduce using rule 25 (expr -> whileloop .)
    <               reduce using rule 25 (expr -> whileloop .)
    LE              reduce using rule 25 (expr -> whileloop .)
    =               reduce using rule 25 (expr -> whileloop .)
    DOT             reduce using rule 25 (expr -> whileloop .)
    @               reduce using rule 25 (expr -> whileloop .)
    )               reduce using rule 25 (expr -> whileloop .)
    LOOP            reduce using rule 25 (expr -> whileloop .)
    ;               reduce using rule 25 (expr -> whileloop .)
    IN              reduce using rule 25 (expr -> whileloop .)
    THEN            reduce using rule 25 (expr -> whileloop .)
    OF              reduce using rule 25 (expr -> whileloop .)
    ELSE            reduce using rule 25 (expr -> whileloop .)
    POOL            reduce using rule 25 (expr -> whileloop .)
    FI              reduce using rule 25 (expr -> whileloop .)
    }               reduce using rule 25 (expr -> whileloop .)


state 44

    (30) expr -> ISVOID . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 73
    caseexpr                       shift and go to state 45

state 45

    (28) expr -> caseexpr .

    ,               reduce using rule 28 (expr -> caseexpr .)
    +               reduce using rule 28 (expr -> caseexpr .)
    -               reduce using rule 28 (expr -> caseexpr .)
    *               reduce using rule 28 (expr -> caseexpr .)
    /               reduce using rule 28 (expr -> caseexpr .)
    <               reduce using rule 28 (expr -> caseexpr .)
    LE              reduce using rule 28 (expr -> caseexpr .)
    =               reduce using rule 28 (expr -> caseexpr .)
    DOT             reduce using rule 28 (expr -> caseexpr .)
    @               reduce using rule 28 (expr -> caseexpr .)
    )               reduce using rule 28 (expr -> caseexpr .)
    LOOP            reduce using rule 28 (expr -> caseexpr .)
    ;               reduce using rule 28 (expr -> caseexpr .)
    IN              reduce using rule 28 (expr -> caseexpr .)
    THEN            reduce using rule 28 (expr -> caseexpr .)
    OF              reduce using rule 28 (expr -> caseexpr .)
    ELSE            reduce using rule 28 (expr -> caseexpr .)
    POOL            reduce using rule 28 (expr -> caseexpr .)
    FI              reduce using rule 28 (expr -> caseexpr .)
    }               reduce using rule 28 (expr -> caseexpr .)


state 46

    (31) expr -> NOT . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 74
    caseexpr                       shift and go to state 45

state 47

    (50) ifthenelse -> IF . expr THEN expr ELSE expr FI
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 75
    caseexpr                       shift and go to state 45

state 48

    (51) whileloop -> WHILE . expr LOOP expr POOL
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 76
    caseexpr                       shift and go to state 45

state 49

    (57) caseexpr -> CASE . expr OF casestatements ESAC
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 77
    caseexpr                       shift and go to state 45

state 50

    (12) variabledeclaration -> OBJECTID : TYPEID .

    ,               reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    )               reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    DARROW          reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    ASSIGN          reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    ;               reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    IN              reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)


state 51

    (17) formalargs -> empty .

    )               reduce using rule 17 (formalargs -> empty .)


state 52

    (10) methoddefinition -> OBJECTID ( formalargs . ) : TYPEID { expr }

    )               shift and go to state 78


state 53

    (15) formalargs -> variabledeclaration . , formalargs
    (16) formalargs -> variabledeclaration .

    ,               shift and go to state 79
    )               reduce using rule 16 (formalargs -> variabledeclaration .)


state 54

    (12) variabledeclaration -> OBJECTID . : TYPEID

    :               shift and go to state 24


state 55

    (32) expr -> ~ expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 32 (expr -> ~ expr .)
    +               reduce using rule 32 (expr -> ~ expr .)
    -               reduce using rule 32 (expr -> ~ expr .)
    *               reduce using rule 32 (expr -> ~ expr .)
    /               reduce using rule 32 (expr -> ~ expr .)
    <               reduce using rule 32 (expr -> ~ expr .)
    LE              reduce using rule 32 (expr -> ~ expr .)
    =               reduce using rule 32 (expr -> ~ expr .)
    )               reduce using rule 32 (expr -> ~ expr .)
    LOOP            reduce using rule 32 (expr -> ~ expr .)
    ;               reduce using rule 32 (expr -> ~ expr .)
    IN              reduce using rule 32 (expr -> ~ expr .)
    THEN            reduce using rule 32 (expr -> ~ expr .)
    OF              reduce using rule 32 (expr -> ~ expr .)
    ELSE            reduce using rule 32 (expr -> ~ expr .)
    POOL            reduce using rule 32 (expr -> ~ expr .)
    FI              reduce using rule 32 (expr -> ~ expr .)
    }               reduce using rule 32 (expr -> ~ expr .)
    DOT             shift and go to state 63
    @               shift and go to state 65

  ! DOT             [ reduce using rule 32 (expr -> ~ expr .) ]
  ! @               [ reduce using rule 32 (expr -> ~ expr .) ]
  ! +               [ shift and go to state 66 ]
  ! -               [ shift and go to state 64 ]
  ! *               [ shift and go to state 62 ]
  ! /               [ shift and go to state 67 ]
  ! <               [ shift and go to state 69 ]
  ! LE              [ shift and go to state 68 ]
  ! =               [ shift and go to state 61 ]


state 56

    (29) expr -> NEW TYPEID .

    ,               reduce using rule 29 (expr -> NEW TYPEID .)
    +               reduce using rule 29 (expr -> NEW TYPEID .)
    -               reduce using rule 29 (expr -> NEW TYPEID .)
    *               reduce using rule 29 (expr -> NEW TYPEID .)
    /               reduce using rule 29 (expr -> NEW TYPEID .)
    <               reduce using rule 29 (expr -> NEW TYPEID .)
    LE              reduce using rule 29 (expr -> NEW TYPEID .)
    =               reduce using rule 29 (expr -> NEW TYPEID .)
    DOT             reduce using rule 29 (expr -> NEW TYPEID .)
    @               reduce using rule 29 (expr -> NEW TYPEID .)
    )               reduce using rule 29 (expr -> NEW TYPEID .)
    LOOP            reduce using rule 29 (expr -> NEW TYPEID .)
    ;               reduce using rule 29 (expr -> NEW TYPEID .)
    IN              reduce using rule 29 (expr -> NEW TYPEID .)
    THEN            reduce using rule 29 (expr -> NEW TYPEID .)
    OF              reduce using rule 29 (expr -> NEW TYPEID .)
    ELSE            reduce using rule 29 (expr -> NEW TYPEID .)
    POOL            reduce using rule 29 (expr -> NEW TYPEID .)
    FI              reduce using rule 29 (expr -> NEW TYPEID .)
    }               reduce using rule 29 (expr -> NEW TYPEID .)


state 57

    (45) assignment -> OBJECTID ASSIGN . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 80
    caseexpr                       shift and go to state 45

state 58

    (49) localmethodinvoke -> OBJECTID ( . actualargs )
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    empty                          shift and go to state 83
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    actualargs                     shift and go to state 82
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 81
    caseexpr                       shift and go to state 45

state 59

    (46) letexpr -> LET variablelist . IN expr

    IN              shift and go to state 84


state 60

    (55) variablelist -> variabledefinition . , variablelist
    (56) variablelist -> variabledefinition .

    ,               shift and go to state 85
    IN              reduce using rule 56 (variablelist -> variabledefinition .)


state 61

    (40) expr -> expr = . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 86
    caseexpr                       shift and go to state 45

state 62

    (36) expr -> expr * . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 87
    caseexpr                       shift and go to state 45

state 63

    (47) methodinvoke -> expr DOT . OBJECTID ( actualargs )

    OBJECTID        shift and go to state 88


state 64

    (35) expr -> expr - . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 89
    caseexpr                       shift and go to state 45

state 65

    (48) methodinvoke -> expr @ . TYPEID DOT OBJECTID ( actualargs )

    TYPEID          shift and go to state 90


state 66

    (34) expr -> expr + . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 91
    caseexpr                       shift and go to state 45

state 67

    (37) expr -> expr / . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 92
    caseexpr                       shift and go to state 45

state 68

    (39) expr -> expr LE . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 93
    caseexpr                       shift and go to state 45

state 69

    (38) expr -> expr < . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 94
    caseexpr                       shift and go to state 45

state 70

    (33) expr -> ( expr . )
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    )               shift and go to state 95
    +               shift and go to state 66
    -               shift and go to state 64
    *               shift and go to state 62
    /               shift and go to state 67
    <               shift and go to state 69
    LE              shift and go to state 68
    =               shift and go to state 61
    DOT             shift and go to state 63
    @               shift and go to state 65


state 71

    (53) blockstatements -> expr . ; blockstatements
    (54) blockstatements -> expr . ;
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               shift and go to state 96
    +               shift and go to state 66
    -               shift and go to state 64
    *               shift and go to state 62
    /               shift and go to state 67
    <               shift and go to state 69
    LE              shift and go to state 68
    =               shift and go to state 61
    DOT             shift and go to state 63
    @               shift and go to state 65


state 72

    (52) blockexpr -> { blockstatements . }

    }               shift and go to state 97


state 73

    (30) expr -> ISVOID expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 30 (expr -> ISVOID expr .)
    +               reduce using rule 30 (expr -> ISVOID expr .)
    -               reduce using rule 30 (expr -> ISVOID expr .)
    *               reduce using rule 30 (expr -> ISVOID expr .)
    /               reduce using rule 30 (expr -> ISVOID expr .)
    <               reduce using rule 30 (expr -> ISVOID expr .)
    LE              reduce using rule 30 (expr -> ISVOID expr .)
    =               reduce using rule 30 (expr -> ISVOID expr .)
    )               reduce using rule 30 (expr -> ISVOID expr .)
    LOOP            reduce using rule 30 (expr -> ISVOID expr .)
    ;               reduce using rule 30 (expr -> ISVOID expr .)
    IN              reduce using rule 30 (expr -> ISVOID expr .)
    THEN            reduce using rule 30 (expr -> ISVOID expr .)
    OF              reduce using rule 30 (expr -> ISVOID expr .)
    ELSE            reduce using rule 30 (expr -> ISVOID expr .)
    POOL            reduce using rule 30 (expr -> ISVOID expr .)
    FI              reduce using rule 30 (expr -> ISVOID expr .)
    }               reduce using rule 30 (expr -> ISVOID expr .)
    DOT             shift and go to state 63
    @               shift and go to state 65

  ! DOT             [ reduce using rule 30 (expr -> ISVOID expr .) ]
  ! @               [ reduce using rule 30 (expr -> ISVOID expr .) ]
  ! +               [ shift and go to state 66 ]
  ! -               [ shift and go to state 64 ]
  ! *               [ shift and go to state 62 ]
  ! /               [ shift and go to state 67 ]
  ! <               [ shift and go to state 69 ]
  ! LE              [ shift and go to state 68 ]
  ! =               [ shift and go to state 61 ]


state 74

    (31) expr -> NOT expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 31 (expr -> NOT expr .)
    )               reduce using rule 31 (expr -> NOT expr .)
    LOOP            reduce using rule 31 (expr -> NOT expr .)
    ;               reduce using rule 31 (expr -> NOT expr .)
    IN              reduce using rule 31 (expr -> NOT expr .)
    THEN            reduce using rule 31 (expr -> NOT expr .)
    OF              reduce using rule 31 (expr -> NOT expr .)
    ELSE            reduce using rule 31 (expr -> NOT expr .)
    POOL            reduce using rule 31 (expr -> NOT expr .)
    FI              reduce using rule 31 (expr -> NOT expr .)
    }               reduce using rule 31 (expr -> NOT expr .)
    +               shift and go to state 66
    -               shift and go to state 64
    *               shift and go to state 62
    /               shift and go to state 67
    <               shift and go to state 69
    LE              shift and go to state 68
    =               shift and go to state 61
    DOT             shift and go to state 63
    @               shift and go to state 65

  ! +               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! -               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! *               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! /               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! <               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! LE              [ reduce using rule 31 (expr -> NOT expr .) ]
  ! =               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! DOT             [ reduce using rule 31 (expr -> NOT expr .) ]
  ! @               [ reduce using rule 31 (expr -> NOT expr .) ]


state 75

    (50) ifthenelse -> IF expr . THEN expr ELSE expr FI
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    THEN            shift and go to state 98
    +               shift and go to state 66
    -               shift and go to state 64
    *               shift and go to state 62
    /               shift and go to state 67
    <               shift and go to state 69
    LE              shift and go to state 68
    =               shift and go to state 61
    DOT             shift and go to state 63
    @               shift and go to state 65


state 76

    (51) whileloop -> WHILE expr . LOOP expr POOL
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    LOOP            shift and go to state 99
    +               shift and go to state 66
    -               shift and go to state 64
    *               shift and go to state 62
    /               shift and go to state 67
    <               shift and go to state 69
    LE              shift and go to state 68
    =               shift and go to state 61
    DOT             shift and go to state 63
    @               shift and go to state 65


state 77

    (57) caseexpr -> CASE expr . OF casestatements ESAC
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    OF              shift and go to state 100
    +               shift and go to state 66
    -               shift and go to state 64
    *               shift and go to state 62
    /               shift and go to state 67
    <               shift and go to state 69
    LE              shift and go to state 68
    =               shift and go to state 61
    DOT             shift and go to state 63
    @               shift and go to state 65


state 78

    (10) methoddefinition -> OBJECTID ( formalargs ) . : TYPEID { expr }

    :               shift and go to state 101


state 79

    (15) formalargs -> variabledeclaration , . formalargs
    (15) formalargs -> . variabledeclaration , formalargs
    (16) formalargs -> . variabledeclaration
    (17) formalargs -> . empty
    (12) variabledeclaration -> . OBJECTID : TYPEID
    (60) empty -> .

    OBJECTID        shift and go to state 54
    )               reduce using rule 60 (empty -> .)

    empty                          shift and go to state 51
    formalargs                     shift and go to state 102
    variabledeclaration            shift and go to state 53

state 80

    (45) assignment -> OBJECTID ASSIGN expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    )               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    ;               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    ,               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    IN              reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    THEN            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    LOOP            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    OF              reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    ELSE            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    POOL            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    FI              reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    }               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    +               shift and go to state 66
    -               shift and go to state 64
    *               shift and go to state 62
    /               shift and go to state 67
    <               shift and go to state 69
    LE              shift and go to state 68
    =               shift and go to state 61
    DOT             shift and go to state 63
    @               shift and go to state 65

  ! +               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! -               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! *               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! /               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! <               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! LE              [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! =               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! DOT             [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! @               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]


state 81

    (18) actualargs -> expr . , actualargs
    (19) actualargs -> expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               shift and go to state 103
    )               reduce using rule 19 (actualargs -> expr .)
    +               shift and go to state 66
    -               shift and go to state 64
    *               shift and go to state 62
    /               shift and go to state 67
    <               shift and go to state 69
    LE              shift and go to state 68
    =               shift and go to state 61
    DOT             shift and go to state 63
    @               shift and go to state 65


state 82

    (49) localmethodinvoke -> OBJECTID ( actualargs . )

    )               shift and go to state 104


state 83

    (20) actualargs -> empty .

    )               reduce using rule 20 (actualargs -> empty .)


state 84

    (46) letexpr -> LET variablelist IN . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 105
    caseexpr                       shift and go to state 45

state 85

    (55) variablelist -> variabledefinition , . variablelist
    (55) variablelist -> . variabledefinition , variablelist
    (56) variablelist -> . variabledefinition
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (12) variabledeclaration -> . OBJECTID : TYPEID

    OBJECTID        shift and go to state 54

    variablelist                   shift and go to state 106
    variabledefinition             shift and go to state 60
    variabledeclaration            shift and go to state 16

state 86

    (40) expr -> expr = expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 40 (expr -> expr = expr .)
    <               reduce using rule 40 (expr -> expr = expr .)
    LE              reduce using rule 40 (expr -> expr = expr .)
    =               reduce using rule 40 (expr -> expr = expr .)
    )               reduce using rule 40 (expr -> expr = expr .)
    LOOP            reduce using rule 40 (expr -> expr = expr .)
    ;               reduce using rule 40 (expr -> expr = expr .)
    IN              reduce using rule 40 (expr -> expr = expr .)
    THEN            reduce using rule 40 (expr -> expr = expr .)
    OF              reduce using rule 40 (expr -> expr = expr .)
    ELSE            reduce using rule 40 (expr -> expr = expr .)
    POOL            reduce using rule 40 (expr -> expr = expr .)
    FI              reduce using rule 40 (expr -> expr = expr .)
    }               reduce using rule 40 (expr -> expr = expr .)
    +               shift and go to state 66
    -               shift and go to state 64
    *               shift and go to state 62
    /               shift and go to state 67
    DOT             shift and go to state 63
    @               shift and go to state 65

  ! +               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! -               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! *               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! /               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! DOT             [ reduce using rule 40 (expr -> expr = expr .) ]
  ! @               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! <               [ shift and go to state 69 ]
  ! LE              [ shift and go to state 68 ]
  ! =               [ shift and go to state 61 ]


state 87

    (36) expr -> expr * expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 36 (expr -> expr * expr .)
    +               reduce using rule 36 (expr -> expr * expr .)
    -               reduce using rule 36 (expr -> expr * expr .)
    *               reduce using rule 36 (expr -> expr * expr .)
    /               reduce using rule 36 (expr -> expr * expr .)
    <               reduce using rule 36 (expr -> expr * expr .)
    LE              reduce using rule 36 (expr -> expr * expr .)
    =               reduce using rule 36 (expr -> expr * expr .)
    )               reduce using rule 36 (expr -> expr * expr .)
    LOOP            reduce using rule 36 (expr -> expr * expr .)
    ;               reduce using rule 36 (expr -> expr * expr .)
    IN              reduce using rule 36 (expr -> expr * expr .)
    THEN            reduce using rule 36 (expr -> expr * expr .)
    OF              reduce using rule 36 (expr -> expr * expr .)
    ELSE            reduce using rule 36 (expr -> expr * expr .)
    POOL            reduce using rule 36 (expr -> expr * expr .)
    FI              reduce using rule 36 (expr -> expr * expr .)
    }               reduce using rule 36 (expr -> expr * expr .)
    DOT             shift and go to state 63
    @               shift and go to state 65

  ! DOT             [ reduce using rule 36 (expr -> expr * expr .) ]
  ! @               [ reduce using rule 36 (expr -> expr * expr .) ]
  ! +               [ shift and go to state 66 ]
  ! -               [ shift and go to state 64 ]
  ! *               [ shift and go to state 62 ]
  ! /               [ shift and go to state 67 ]
  ! <               [ shift and go to state 69 ]
  ! LE              [ shift and go to state 68 ]
  ! =               [ shift and go to state 61 ]


state 88

    (47) methodinvoke -> expr DOT OBJECTID . ( actualargs )

    (               shift and go to state 107


state 89

    (35) expr -> expr - expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 35 (expr -> expr - expr .)
    +               reduce using rule 35 (expr -> expr - expr .)
    -               reduce using rule 35 (expr -> expr - expr .)
    <               reduce using rule 35 (expr -> expr - expr .)
    LE              reduce using rule 35 (expr -> expr - expr .)
    =               reduce using rule 35 (expr -> expr - expr .)
    )               reduce using rule 35 (expr -> expr - expr .)
    LOOP            reduce using rule 35 (expr -> expr - expr .)
    ;               reduce using rule 35 (expr -> expr - expr .)
    IN              reduce using rule 35 (expr -> expr - expr .)
    THEN            reduce using rule 35 (expr -> expr - expr .)
    OF              reduce using rule 35 (expr -> expr - expr .)
    ELSE            reduce using rule 35 (expr -> expr - expr .)
    POOL            reduce using rule 35 (expr -> expr - expr .)
    FI              reduce using rule 35 (expr -> expr - expr .)
    }               reduce using rule 35 (expr -> expr - expr .)
    *               shift and go to state 62
    /               shift and go to state 67
    DOT             shift and go to state 63
    @               shift and go to state 65

  ! *               [ reduce using rule 35 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 35 (expr -> expr - expr .) ]
  ! DOT             [ reduce using rule 35 (expr -> expr - expr .) ]
  ! @               [ reduce using rule 35 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 66 ]
  ! -               [ shift and go to state 64 ]
  ! <               [ shift and go to state 69 ]
  ! LE              [ shift and go to state 68 ]
  ! =               [ shift and go to state 61 ]


state 90

    (48) methodinvoke -> expr @ TYPEID . DOT OBJECTID ( actualargs )

    DOT             shift and go to state 108


state 91

    (34) expr -> expr + expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 34 (expr -> expr + expr .)
    +               reduce using rule 34 (expr -> expr + expr .)
    -               reduce using rule 34 (expr -> expr + expr .)
    <               reduce using rule 34 (expr -> expr + expr .)
    LE              reduce using rule 34 (expr -> expr + expr .)
    =               reduce using rule 34 (expr -> expr + expr .)
    )               reduce using rule 34 (expr -> expr + expr .)
    LOOP            reduce using rule 34 (expr -> expr + expr .)
    ;               reduce using rule 34 (expr -> expr + expr .)
    IN              reduce using rule 34 (expr -> expr + expr .)
    THEN            reduce using rule 34 (expr -> expr + expr .)
    OF              reduce using rule 34 (expr -> expr + expr .)
    ELSE            reduce using rule 34 (expr -> expr + expr .)
    POOL            reduce using rule 34 (expr -> expr + expr .)
    FI              reduce using rule 34 (expr -> expr + expr .)
    }               reduce using rule 34 (expr -> expr + expr .)
    *               shift and go to state 62
    /               shift and go to state 67
    DOT             shift and go to state 63
    @               shift and go to state 65

  ! *               [ reduce using rule 34 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 34 (expr -> expr + expr .) ]
  ! DOT             [ reduce using rule 34 (expr -> expr + expr .) ]
  ! @               [ reduce using rule 34 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 66 ]
  ! -               [ shift and go to state 64 ]
  ! <               [ shift and go to state 69 ]
  ! LE              [ shift and go to state 68 ]
  ! =               [ shift and go to state 61 ]


state 92

    (37) expr -> expr / expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 37 (expr -> expr / expr .)
    +               reduce using rule 37 (expr -> expr / expr .)
    -               reduce using rule 37 (expr -> expr / expr .)
    *               reduce using rule 37 (expr -> expr / expr .)
    /               reduce using rule 37 (expr -> expr / expr .)
    <               reduce using rule 37 (expr -> expr / expr .)
    LE              reduce using rule 37 (expr -> expr / expr .)
    =               reduce using rule 37 (expr -> expr / expr .)
    )               reduce using rule 37 (expr -> expr / expr .)
    LOOP            reduce using rule 37 (expr -> expr / expr .)
    ;               reduce using rule 37 (expr -> expr / expr .)
    IN              reduce using rule 37 (expr -> expr / expr .)
    THEN            reduce using rule 37 (expr -> expr / expr .)
    OF              reduce using rule 37 (expr -> expr / expr .)
    ELSE            reduce using rule 37 (expr -> expr / expr .)
    POOL            reduce using rule 37 (expr -> expr / expr .)
    FI              reduce using rule 37 (expr -> expr / expr .)
    }               reduce using rule 37 (expr -> expr / expr .)
    DOT             shift and go to state 63
    @               shift and go to state 65

  ! DOT             [ reduce using rule 37 (expr -> expr / expr .) ]
  ! @               [ reduce using rule 37 (expr -> expr / expr .) ]
  ! +               [ shift and go to state 66 ]
  ! -               [ shift and go to state 64 ]
  ! *               [ shift and go to state 62 ]
  ! /               [ shift and go to state 67 ]
  ! <               [ shift and go to state 69 ]
  ! LE              [ shift and go to state 68 ]
  ! =               [ shift and go to state 61 ]


state 93

    (39) expr -> expr LE expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 39 (expr -> expr LE expr .)
    <               reduce using rule 39 (expr -> expr LE expr .)
    LE              reduce using rule 39 (expr -> expr LE expr .)
    =               reduce using rule 39 (expr -> expr LE expr .)
    )               reduce using rule 39 (expr -> expr LE expr .)
    LOOP            reduce using rule 39 (expr -> expr LE expr .)
    ;               reduce using rule 39 (expr -> expr LE expr .)
    IN              reduce using rule 39 (expr -> expr LE expr .)
    THEN            reduce using rule 39 (expr -> expr LE expr .)
    OF              reduce using rule 39 (expr -> expr LE expr .)
    ELSE            reduce using rule 39 (expr -> expr LE expr .)
    POOL            reduce using rule 39 (expr -> expr LE expr .)
    FI              reduce using rule 39 (expr -> expr LE expr .)
    }               reduce using rule 39 (expr -> expr LE expr .)
    +               shift and go to state 66
    -               shift and go to state 64
    *               shift and go to state 62
    /               shift and go to state 67
    DOT             shift and go to state 63
    @               shift and go to state 65

  ! +               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! -               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! *               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! /               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! DOT             [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! @               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! <               [ shift and go to state 69 ]
  ! LE              [ shift and go to state 68 ]
  ! =               [ shift and go to state 61 ]


state 94

    (38) expr -> expr < expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 38 (expr -> expr < expr .)
    <               reduce using rule 38 (expr -> expr < expr .)
    LE              reduce using rule 38 (expr -> expr < expr .)
    =               reduce using rule 38 (expr -> expr < expr .)
    )               reduce using rule 38 (expr -> expr < expr .)
    LOOP            reduce using rule 38 (expr -> expr < expr .)
    ;               reduce using rule 38 (expr -> expr < expr .)
    IN              reduce using rule 38 (expr -> expr < expr .)
    THEN            reduce using rule 38 (expr -> expr < expr .)
    OF              reduce using rule 38 (expr -> expr < expr .)
    ELSE            reduce using rule 38 (expr -> expr < expr .)
    POOL            reduce using rule 38 (expr -> expr < expr .)
    FI              reduce using rule 38 (expr -> expr < expr .)
    }               reduce using rule 38 (expr -> expr < expr .)
    +               shift and go to state 66
    -               shift and go to state 64
    *               shift and go to state 62
    /               shift and go to state 67
    DOT             shift and go to state 63
    @               shift and go to state 65

  ! +               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! DOT             [ reduce using rule 38 (expr -> expr < expr .) ]
  ! @               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! <               [ shift and go to state 69 ]
  ! LE              [ shift and go to state 68 ]
  ! =               [ shift and go to state 61 ]


state 95

    (33) expr -> ( expr ) .

    ,               reduce using rule 33 (expr -> ( expr ) .)
    +               reduce using rule 33 (expr -> ( expr ) .)
    -               reduce using rule 33 (expr -> ( expr ) .)
    *               reduce using rule 33 (expr -> ( expr ) .)
    /               reduce using rule 33 (expr -> ( expr ) .)
    <               reduce using rule 33 (expr -> ( expr ) .)
    LE              reduce using rule 33 (expr -> ( expr ) .)
    =               reduce using rule 33 (expr -> ( expr ) .)
    DOT             reduce using rule 33 (expr -> ( expr ) .)
    @               reduce using rule 33 (expr -> ( expr ) .)
    )               reduce using rule 33 (expr -> ( expr ) .)
    LOOP            reduce using rule 33 (expr -> ( expr ) .)
    ;               reduce using rule 33 (expr -> ( expr ) .)
    IN              reduce using rule 33 (expr -> ( expr ) .)
    THEN            reduce using rule 33 (expr -> ( expr ) .)
    OF              reduce using rule 33 (expr -> ( expr ) .)
    ELSE            reduce using rule 33 (expr -> ( expr ) .)
    POOL            reduce using rule 33 (expr -> ( expr ) .)
    FI              reduce using rule 33 (expr -> ( expr ) .)
    }               reduce using rule 33 (expr -> ( expr ) .)


state 96

    (53) blockstatements -> expr ; . blockstatements
    (54) blockstatements -> expr ; .
    (53) blockstatements -> . expr ; blockstatements
    (54) blockstatements -> . expr ;
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    }               reduce using rule 54 (blockstatements -> expr ; .)
    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    blockstatements                shift and go to state 109
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 71
    caseexpr                       shift and go to state 45

state 97

    (52) blockexpr -> { blockstatements } .

    +               reduce using rule 52 (blockexpr -> { blockstatements } .)
    -               reduce using rule 52 (blockexpr -> { blockstatements } .)
    *               reduce using rule 52 (blockexpr -> { blockstatements } .)
    /               reduce using rule 52 (blockexpr -> { blockstatements } .)
    <               reduce using rule 52 (blockexpr -> { blockstatements } .)
    LE              reduce using rule 52 (blockexpr -> { blockstatements } .)
    =               reduce using rule 52 (blockexpr -> { blockstatements } .)
    DOT             reduce using rule 52 (blockexpr -> { blockstatements } .)
    @               reduce using rule 52 (blockexpr -> { blockstatements } .)
    ;               reduce using rule 52 (blockexpr -> { blockstatements } .)
    ,               reduce using rule 52 (blockexpr -> { blockstatements } .)
    IN              reduce using rule 52 (blockexpr -> { blockstatements } .)
    )               reduce using rule 52 (blockexpr -> { blockstatements } .)
    THEN            reduce using rule 52 (blockexpr -> { blockstatements } .)
    LOOP            reduce using rule 52 (blockexpr -> { blockstatements } .)
    OF              reduce using rule 52 (blockexpr -> { blockstatements } .)
    ELSE            reduce using rule 52 (blockexpr -> { blockstatements } .)
    POOL            reduce using rule 52 (blockexpr -> { blockstatements } .)
    FI              reduce using rule 52 (blockexpr -> { blockstatements } .)
    }               reduce using rule 52 (blockexpr -> { blockstatements } .)


state 98

    (50) ifthenelse -> IF expr THEN . expr ELSE expr FI
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 110
    caseexpr                       shift and go to state 45

state 99

    (51) whileloop -> WHILE expr LOOP . expr POOL
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 111
    caseexpr                       shift and go to state 45

state 100

    (57) caseexpr -> CASE expr OF . casestatements ESAC
    (58) casestatements -> . variabledeclaration DARROW expr ; casestatements
    (59) casestatements -> . variabledeclaration DARROW expr ;
    (12) variabledeclaration -> . OBJECTID : TYPEID

    OBJECTID        shift and go to state 54

    variabledeclaration            shift and go to state 112
    casestatements                 shift and go to state 113

state 101

    (10) methoddefinition -> OBJECTID ( formalargs ) : . TYPEID { expr }

    TYPEID          shift and go to state 114


state 102

    (15) formalargs -> variabledeclaration , formalargs .

    )               reduce using rule 15 (formalargs -> variabledeclaration , formalargs .)


state 103

    (18) actualargs -> expr , . actualargs
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    empty                          shift and go to state 83
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    actualargs                     shift and go to state 115
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 81
    caseexpr                       shift and go to state 45

state 104

    (49) localmethodinvoke -> OBJECTID ( actualargs ) .

    +               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    -               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    *               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    /               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    <               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    LE              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    =               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    DOT             reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    @               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    ;               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    ,               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    IN              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    )               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    THEN            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    LOOP            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    OF              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    ELSE            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    POOL            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    FI              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    }               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)


state 105

    (46) letexpr -> LET variablelist IN expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    ,               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    IN              reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    )               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    THEN            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    LOOP            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    OF              reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    ELSE            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    POOL            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    FI              reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    }               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    +               shift and go to state 66
    -               shift and go to state 64
    *               shift and go to state 62
    /               shift and go to state 67
    <               shift and go to state 69
    LE              shift and go to state 68
    =               shift and go to state 61
    DOT             shift and go to state 63
    @               shift and go to state 65

  ! +               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! -               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! *               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! /               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! <               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! LE              [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! =               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! DOT             [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! @               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]


state 106

    (55) variablelist -> variabledefinition , variablelist .

    IN              reduce using rule 55 (variablelist -> variabledefinition , variablelist .)


state 107

    (47) methodinvoke -> expr DOT OBJECTID ( . actualargs )
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    empty                          shift and go to state 83
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    actualargs                     shift and go to state 116
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 81
    caseexpr                       shift and go to state 45

state 108

    (48) methodinvoke -> expr @ TYPEID DOT . OBJECTID ( actualargs )

    OBJECTID        shift and go to state 117


state 109

    (53) blockstatements -> expr ; blockstatements .

    }               reduce using rule 53 (blockstatements -> expr ; blockstatements .)


state 110

    (50) ifthenelse -> IF expr THEN expr . ELSE expr FI
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ELSE            shift and go to state 118
    +               shift and go to state 66
    -               shift and go to state 64
    *               shift and go to state 62
    /               shift and go to state 67
    <               shift and go to state 69
    LE              shift and go to state 68
    =               shift and go to state 61
    DOT             shift and go to state 63
    @               shift and go to state 65


state 111

    (51) whileloop -> WHILE expr LOOP expr . POOL
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    POOL            shift and go to state 119
    +               shift and go to state 66
    -               shift and go to state 64
    *               shift and go to state 62
    /               shift and go to state 67
    <               shift and go to state 69
    LE              shift and go to state 68
    =               shift and go to state 61
    DOT             shift and go to state 63
    @               shift and go to state 65


state 112

    (58) casestatements -> variabledeclaration . DARROW expr ; casestatements
    (59) casestatements -> variabledeclaration . DARROW expr ;

    DARROW          shift and go to state 120


state 113

    (57) caseexpr -> CASE expr OF casestatements . ESAC

    ESAC            shift and go to state 121


state 114

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID . { expr }

    {               shift and go to state 122


state 115

    (18) actualargs -> expr , actualargs .

    )               reduce using rule 18 (actualargs -> expr , actualargs .)


state 116

    (47) methodinvoke -> expr DOT OBJECTID ( actualargs . )

    )               shift and go to state 123


state 117

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID . ( actualargs )

    (               shift and go to state 124


state 118

    (50) ifthenelse -> IF expr THEN expr ELSE . expr FI
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 125
    caseexpr                       shift and go to state 45

state 119

    (51) whileloop -> WHILE expr LOOP expr POOL .

    )               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    +               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    -               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    *               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    /               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    <               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    LE              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    =               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    DOT             reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    @               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    ;               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    ,               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    IN              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    THEN            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    LOOP            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    OF              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    ELSE            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    POOL            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    FI              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    }               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)


state 120

    (58) casestatements -> variabledeclaration DARROW . expr ; casestatements
    (59) casestatements -> variabledeclaration DARROW . expr ;
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 126
    caseexpr                       shift and go to state 45

state 121

    (57) caseexpr -> CASE expr OF casestatements ESAC .

    ;               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    +               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    -               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    *               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    /               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    <               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    LE              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    =               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    DOT             reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    @               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    ,               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    IN              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    )               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    THEN            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    LOOP            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    OF              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    ELSE            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    POOL            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    FI              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    }               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)


state 122

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID { . expr }
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 127
    caseexpr                       shift and go to state 45

state 123

    (47) methodinvoke -> expr DOT OBJECTID ( actualargs ) .

    +               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    -               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    *               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    /               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    <               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    LE              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    =               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    DOT             reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    @               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    ;               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    ,               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    IN              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    )               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    THEN            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    LOOP            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    OF              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    ELSE            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    POOL            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    FI              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    }               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)


state 124

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID ( . actualargs )
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 33
    ISVOID          shift and go to state 44
    NOT             shift and go to state 46
    ~               shift and go to state 32
    (               shift and go to state 39
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 29
    BOOL_CONST      shift and go to state 27
    OBJECTID        shift and go to state 35
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 47
    WHILE           shift and go to state 48
    {               shift and go to state 42
    LET             shift and go to state 36
    CASE            shift and go to state 49

    letexpr                        shift and go to state 40
    empty                          shift and go to state 83
    assignment                     shift and go to state 41
    methodinvoke                   shift and go to state 31
    ifthenelse                     shift and go to state 28
    whileloop                      shift and go to state 43
    actualargs                     shift and go to state 128
    localmethodinvoke              shift and go to state 34
    blockexpr                      shift and go to state 37
    expr                           shift and go to state 81
    caseexpr                       shift and go to state 45

state 125

    (50) ifthenelse -> IF expr THEN expr ELSE expr . FI
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    FI              shift and go to state 129
    +               shift and go to state 66
    -               shift and go to state 64
    *               shift and go to state 62
    /               shift and go to state 67
    <               shift and go to state 69
    LE              shift and go to state 68
    =               shift and go to state 61
    DOT             shift and go to state 63
    @               shift and go to state 65


state 126

    (58) casestatements -> variabledeclaration DARROW expr . ; casestatements
    (59) casestatements -> variabledeclaration DARROW expr . ;
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               shift and go to state 130
    +               shift and go to state 66
    -               shift and go to state 64
    *               shift and go to state 62
    /               shift and go to state 67
    <               shift and go to state 69
    LE              shift and go to state 68
    =               shift and go to state 61
    DOT             shift and go to state 63
    @               shift and go to state 65


state 127

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr . }
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    }               shift and go to state 131
    +               shift and go to state 66
    -               shift and go to state 64
    *               shift and go to state 62
    /               shift and go to state 67
    <               shift and go to state 69
    LE              shift and go to state 68
    =               shift and go to state 61
    DOT             shift and go to state 63
    @               shift and go to state 65


state 128

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs . )

    )               shift and go to state 132


state 129

    (50) ifthenelse -> IF expr THEN expr ELSE expr FI .

    +               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    -               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    *               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    /               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    <               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    LE              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    =               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    DOT             reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    @               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    ;               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    ,               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    IN              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    )               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    THEN            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    LOOP            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    OF              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    ELSE            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    POOL            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    FI              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    }               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)


state 130

    (58) casestatements -> variabledeclaration DARROW expr ; . casestatements
    (59) casestatements -> variabledeclaration DARROW expr ; .
    (58) casestatements -> . variabledeclaration DARROW expr ; casestatements
    (59) casestatements -> . variabledeclaration DARROW expr ;
    (12) variabledeclaration -> . OBJECTID : TYPEID

    ESAC            reduce using rule 59 (casestatements -> variabledeclaration DARROW expr ; .)
    OBJECTID        shift and go to state 54

    variabledeclaration            shift and go to state 112
    casestatements                 shift and go to state 133

state 131

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr } .

    ;               reduce using rule 10 (methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr } .)


state 132

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .

    +               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    -               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    *               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    /               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    <               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    LE              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    =               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    DOT             reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    @               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    ;               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    ,               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    IN              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    )               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    THEN            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    LOOP            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    OF              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    ELSE            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    POOL            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    FI              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    }               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)


state 133

    (58) casestatements -> variabledeclaration DARROW expr ; casestatements .

    ESAC            reduce using rule 58 (casestatements -> variabledeclaration DARROW expr ; casestatements .)

