Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT_SINGLELINE
    COMMENT_MULTILINE
    NEWLINE

Grammar

Rule 0     S' -> program
Rule 1     program -> class ; program
Rule 2     program -> class ;
Rule 3     class -> CLASS TYPEID baseclass { features }
Rule 4     baseclass -> INHERITS TYPEID
Rule 5     baseclass -> empty
Rule 6     features -> feature ; features
Rule 7     features -> empty
Rule 8     feature -> variabledefinition
Rule 9     feature -> methoddefinition
Rule 10    methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr }
Rule 11    variabledefinition -> variabledeclaration variableinitialization
Rule 12    variabledeclaration -> OBJECTID : TYPEID
Rule 13    variableinitialization -> ASSIGN expr
Rule 14    variableinitialization -> empty
Rule 15    formalargs -> variabledeclaration , formalargs
Rule 16    formalargs -> variabledeclaration
Rule 17    formalargs -> empty
Rule 18    actualargs -> expr , actualargs
Rule 19    actualargs -> expr
Rule 20    actualargs -> empty
Rule 21    expr -> assignment
Rule 22    expr -> methodinvoke
Rule 23    expr -> localmethodinvoke
Rule 24    expr -> ifthenelse
Rule 25    expr -> whileloop
Rule 26    expr -> blockexpr
Rule 27    expr -> letexpr
Rule 28    expr -> caseexpr
Rule 29    expr -> NEW TYPEID
Rule 30    expr -> ISVOID expr
Rule 31    expr -> NOT expr
Rule 32    expr -> ~ expr
Rule 33    expr -> ( expr )
Rule 34    expr -> expr + expr
Rule 35    expr -> expr - expr
Rule 36    expr -> expr * expr
Rule 37    expr -> expr / expr
Rule 38    expr -> expr < expr
Rule 39    expr -> expr LE expr
Rule 40    expr -> expr = expr
Rule 41    expr -> INT_CONST
Rule 42    expr -> STR_CONST
Rule 43    expr -> BOOL_CONST
Rule 44    expr -> OBJECTID
Rule 45    assignment -> OBJECTID ASSIGN expr
Rule 46    letexpr -> LET variablelist IN expr
Rule 47    methodinvoke -> expr DOT OBJECTID ( actualargs )
Rule 48    methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs )
Rule 49    localmethodinvoke -> OBJECTID ( actualargs )
Rule 50    ifthenelse -> IF expr THEN expr ELSE expr FI
Rule 51    whileloop -> WHILE expr LOOP expr POOL
Rule 52    blockexpr -> { blockstatements }
Rule 53    blockstatements -> expr ; blockstatements
Rule 54    blockstatements -> expr ;
Rule 55    variablelist -> variabledefinition , variablelist
Rule 56    variablelist -> variabledefinition
Rule 57    caseexpr -> CASE expr OF casestatements ESAC
Rule 58    casestatements -> variabledeclaration DARROW expr ; casestatements
Rule 59    casestatements -> variabledeclaration DARROW expr ;
Rule 60    empty -> <empty>

Terminals, with rules where they appear

(                    : 10 33 47 48 49
)                    : 10 33 47 48 49
*                    : 36
+                    : 34
,                    : 15 18 55
-                    : 35
/                    : 37
:                    : 10 12
;                    : 1 2 6 53 54 58 59
<                    : 38
=                    : 40
@                    : 48
ASSIGN               : 13 45
BOOL_CONST           : 43
CASE                 : 57
CLASS                : 3
COMMENT_MULTILINE    : 
COMMENT_SINGLELINE   : 
DARROW               : 58 59
DOT                  : 47 48
ELSE                 : 50
ESAC                 : 57
FI                   : 50
IF                   : 50
IN                   : 46
INHERITS             : 4
INT_CONST            : 41
ISVOID               : 30
LE                   : 39
LET                  : 46
LOOP                 : 51
NEW                  : 29
NEWLINE              : 
NOT                  : 31
OBJECTID             : 10 12 44 45 47 48 49
OF                   : 57
POOL                 : 51
STR_CONST            : 42
THEN                 : 50
TYPEID               : 3 4 10 12 29 48
WHILE                : 51
error                : 
{                    : 3 10 52
}                    : 3 10 52
~                    : 32

Nonterminals, with rules where they appear

actualargs           : 18 47 48 49
assignment           : 21
baseclass            : 3
blockexpr            : 26
blockstatements      : 52 53
caseexpr             : 28
casestatements       : 57 58
class                : 1 2
empty                : 5 7 14 17 20
expr                 : 10 13 18 19 30 31 32 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 45 46 47 48 50 50 50 51 51 53 54 57 58 59
feature              : 6
features             : 3 6
formalargs           : 10 15
ifthenelse           : 24
letexpr              : 27
localmethodinvoke    : 23
methoddefinition     : 9
methodinvoke         : 22
program              : 1 0
variabledeclaration  : 11 15 16 58 59
variabledefinition   : 8 55 56
variableinitialization : 11
variablelist         : 46 55
whileloop            : 25

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class ; program
    (2) program -> . class ;
    (3) class -> . CLASS TYPEID baseclass { features }

    CLASS           shift and go to state 2

    class                          shift and go to state 1
    program                        shift and go to state 3

state 1

    (1) program -> class . ; program
    (2) program -> class . ;

    ;               shift and go to state 4


state 2

    (3) class -> CLASS . TYPEID baseclass { features }

    TYPEID          shift and go to state 5


state 3

    (0) S' -> program .



state 4

    (1) program -> class ; . program
    (2) program -> class ; .
    (1) program -> . class ; program
    (2) program -> . class ;
    (3) class -> . CLASS TYPEID baseclass { features }

    $end            reduce using rule 2 (program -> class ; .)
    CLASS           shift and go to state 2

    class                          shift and go to state 1
    program                        shift and go to state 6

state 5

    (3) class -> CLASS TYPEID . baseclass { features }
    (4) baseclass -> . INHERITS TYPEID
    (5) baseclass -> . empty
    (60) empty -> .

    INHERITS        shift and go to state 7
    {               reduce using rule 60 (empty -> .)

    empty                          shift and go to state 9
    baseclass                      shift and go to state 8

state 6

    (1) program -> class ; program .

    $end            reduce using rule 1 (program -> class ; program .)


state 7

    (4) baseclass -> INHERITS . TYPEID

    TYPEID          shift and go to state 10


state 8

    (3) class -> CLASS TYPEID baseclass . { features }

    {               shift and go to state 11


state 9

    (5) baseclass -> empty .

    {               reduce using rule 5 (baseclass -> empty .)


state 10

    (4) baseclass -> INHERITS TYPEID .

    {               reduce using rule 4 (baseclass -> INHERITS TYPEID .)


state 11

    (3) class -> CLASS TYPEID baseclass { . features }
    (6) features -> . feature ; features
    (7) features -> . empty
    (8) feature -> . variabledefinition
    (9) feature -> . methoddefinition
    (60) empty -> .
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (10) methoddefinition -> . OBJECTID ( formalargs ) : TYPEID { expr }
    (12) variabledeclaration -> . OBJECTID : TYPEID

    }               reduce using rule 60 (empty -> .)
    OBJECTID        shift and go to state 16

    features                       shift and go to state 13
    feature                        shift and go to state 12
    variabledefinition             shift and go to state 18
    empty                          shift and go to state 17
    variabledeclaration            shift and go to state 15
    methoddefinition               shift and go to state 14

state 12

    (6) features -> feature . ; features

    ;               shift and go to state 19


state 13

    (3) class -> CLASS TYPEID baseclass { features . }

    }               shift and go to state 20


state 14

    (9) feature -> methoddefinition .

    ;               reduce using rule 9 (feature -> methoddefinition .)


state 15

    (11) variabledefinition -> variabledeclaration . variableinitialization
    (13) variableinitialization -> . ASSIGN expr
    (14) variableinitialization -> . empty
    (60) empty -> .

    ASSIGN          shift and go to state 22
    ;               reduce using rule 60 (empty -> .)
    ,               reduce using rule 60 (empty -> .)
    IN              reduce using rule 60 (empty -> .)

    variableinitialization         shift and go to state 21
    empty                          shift and go to state 23

state 16

    (10) methoddefinition -> OBJECTID . ( formalargs ) : TYPEID { expr }
    (12) variabledeclaration -> OBJECTID . : TYPEID

    (               shift and go to state 25
    :               shift and go to state 24


state 17

    (7) features -> empty .

    }               reduce using rule 7 (features -> empty .)


state 18

    (8) feature -> variabledefinition .

    ;               reduce using rule 8 (feature -> variabledefinition .)


state 19

    (6) features -> feature ; . features
    (6) features -> . feature ; features
    (7) features -> . empty
    (8) feature -> . variabledefinition
    (9) feature -> . methoddefinition
    (60) empty -> .
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (10) methoddefinition -> . OBJECTID ( formalargs ) : TYPEID { expr }
    (12) variabledeclaration -> . OBJECTID : TYPEID

    }               reduce using rule 60 (empty -> .)
    OBJECTID        shift and go to state 16

    feature                        shift and go to state 12
    variabledeclaration            shift and go to state 15
    variabledefinition             shift and go to state 18
    empty                          shift and go to state 17
    features                       shift and go to state 26
    methoddefinition               shift and go to state 14

state 20

    (3) class -> CLASS TYPEID baseclass { features } .

    ;               reduce using rule 3 (class -> CLASS TYPEID baseclass { features } .)


state 21

    (11) variabledefinition -> variabledeclaration variableinitialization .

    ,               reduce using rule 11 (variabledefinition -> variabledeclaration variableinitialization .)
    IN              reduce using rule 11 (variabledefinition -> variabledeclaration variableinitialization .)
    ;               reduce using rule 11 (variabledefinition -> variabledeclaration variableinitialization .)


state 22

    (13) variableinitialization -> ASSIGN . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockexpr                      shift and go to state 40
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 44
    methodinvoke                   shift and go to state 48

state 23

    (14) variableinitialization -> empty .

    ;               reduce using rule 14 (variableinitialization -> empty .)
    ,               reduce using rule 14 (variableinitialization -> empty .)
    IN              reduce using rule 14 (variableinitialization -> empty .)


state 24

    (12) variabledeclaration -> OBJECTID : . TYPEID

    TYPEID          shift and go to state 50


state 25

    (10) methoddefinition -> OBJECTID ( . formalargs ) : TYPEID { expr }
    (15) formalargs -> . variabledeclaration , formalargs
    (16) formalargs -> . variabledeclaration
    (17) formalargs -> . empty
    (12) variabledeclaration -> . OBJECTID : TYPEID
    (60) empty -> .

    OBJECTID        shift and go to state 53
    )               reduce using rule 60 (empty -> .)

    empty                          shift and go to state 54
    variabledeclaration            shift and go to state 52
    formalargs                     shift and go to state 51

state 26

    (6) features -> feature ; features .

    }               reduce using rule 6 (features -> feature ; features .)


state 27

    (30) expr -> ISVOID . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockexpr                      shift and go to state 40
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 55
    methodinvoke                   shift and go to state 48

state 28

    (23) expr -> localmethodinvoke .

    ,               reduce using rule 23 (expr -> localmethodinvoke .)
    +               reduce using rule 23 (expr -> localmethodinvoke .)
    -               reduce using rule 23 (expr -> localmethodinvoke .)
    *               reduce using rule 23 (expr -> localmethodinvoke .)
    /               reduce using rule 23 (expr -> localmethodinvoke .)
    <               reduce using rule 23 (expr -> localmethodinvoke .)
    LE              reduce using rule 23 (expr -> localmethodinvoke .)
    =               reduce using rule 23 (expr -> localmethodinvoke .)
    DOT             reduce using rule 23 (expr -> localmethodinvoke .)
    @               reduce using rule 23 (expr -> localmethodinvoke .)
    )               reduce using rule 23 (expr -> localmethodinvoke .)
    THEN            reduce using rule 23 (expr -> localmethodinvoke .)
    ;               reduce using rule 23 (expr -> localmethodinvoke .)
    IN              reduce using rule 23 (expr -> localmethodinvoke .)
    OF              reduce using rule 23 (expr -> localmethodinvoke .)
    LOOP            reduce using rule 23 (expr -> localmethodinvoke .)
    ELSE            reduce using rule 23 (expr -> localmethodinvoke .)
    POOL            reduce using rule 23 (expr -> localmethodinvoke .)
    FI              reduce using rule 23 (expr -> localmethodinvoke .)
    }               reduce using rule 23 (expr -> localmethodinvoke .)


state 29

    (24) expr -> ifthenelse .

    ,               reduce using rule 24 (expr -> ifthenelse .)
    +               reduce using rule 24 (expr -> ifthenelse .)
    -               reduce using rule 24 (expr -> ifthenelse .)
    *               reduce using rule 24 (expr -> ifthenelse .)
    /               reduce using rule 24 (expr -> ifthenelse .)
    <               reduce using rule 24 (expr -> ifthenelse .)
    LE              reduce using rule 24 (expr -> ifthenelse .)
    =               reduce using rule 24 (expr -> ifthenelse .)
    DOT             reduce using rule 24 (expr -> ifthenelse .)
    @               reduce using rule 24 (expr -> ifthenelse .)
    )               reduce using rule 24 (expr -> ifthenelse .)
    THEN            reduce using rule 24 (expr -> ifthenelse .)
    ;               reduce using rule 24 (expr -> ifthenelse .)
    IN              reduce using rule 24 (expr -> ifthenelse .)
    OF              reduce using rule 24 (expr -> ifthenelse .)
    LOOP            reduce using rule 24 (expr -> ifthenelse .)
    ELSE            reduce using rule 24 (expr -> ifthenelse .)
    POOL            reduce using rule 24 (expr -> ifthenelse .)
    FI              reduce using rule 24 (expr -> ifthenelse .)
    }               reduce using rule 24 (expr -> ifthenelse .)


state 30

    (50) ifthenelse -> IF . expr THEN expr ELSE expr FI
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockexpr                      shift and go to state 40
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 56
    methodinvoke                   shift and go to state 48

state 31

    (57) caseexpr -> CASE . expr OF casestatements ESAC
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    blockexpr                      shift and go to state 40
    letexpr                        shift and go to state 38
    caseexpr                       shift and go to state 45
    localmethodinvoke              shift and go to state 28
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 57
    methodinvoke                   shift and go to state 48

state 32

    (25) expr -> whileloop .

    ,               reduce using rule 25 (expr -> whileloop .)
    +               reduce using rule 25 (expr -> whileloop .)
    -               reduce using rule 25 (expr -> whileloop .)
    *               reduce using rule 25 (expr -> whileloop .)
    /               reduce using rule 25 (expr -> whileloop .)
    <               reduce using rule 25 (expr -> whileloop .)
    LE              reduce using rule 25 (expr -> whileloop .)
    =               reduce using rule 25 (expr -> whileloop .)
    DOT             reduce using rule 25 (expr -> whileloop .)
    @               reduce using rule 25 (expr -> whileloop .)
    )               reduce using rule 25 (expr -> whileloop .)
    THEN            reduce using rule 25 (expr -> whileloop .)
    ;               reduce using rule 25 (expr -> whileloop .)
    IN              reduce using rule 25 (expr -> whileloop .)
    OF              reduce using rule 25 (expr -> whileloop .)
    LOOP            reduce using rule 25 (expr -> whileloop .)
    ELSE            reduce using rule 25 (expr -> whileloop .)
    POOL            reduce using rule 25 (expr -> whileloop .)
    FI              reduce using rule 25 (expr -> whileloop .)
    }               reduce using rule 25 (expr -> whileloop .)


state 33

    (44) expr -> OBJECTID .
    (45) assignment -> OBJECTID . ASSIGN expr
    (49) localmethodinvoke -> OBJECTID . ( actualargs )

    ,               reduce using rule 44 (expr -> OBJECTID .)
    +               reduce using rule 44 (expr -> OBJECTID .)
    -               reduce using rule 44 (expr -> OBJECTID .)
    *               reduce using rule 44 (expr -> OBJECTID .)
    /               reduce using rule 44 (expr -> OBJECTID .)
    <               reduce using rule 44 (expr -> OBJECTID .)
    LE              reduce using rule 44 (expr -> OBJECTID .)
    =               reduce using rule 44 (expr -> OBJECTID .)
    DOT             reduce using rule 44 (expr -> OBJECTID .)
    @               reduce using rule 44 (expr -> OBJECTID .)
    )               reduce using rule 44 (expr -> OBJECTID .)
    THEN            reduce using rule 44 (expr -> OBJECTID .)
    ;               reduce using rule 44 (expr -> OBJECTID .)
    IN              reduce using rule 44 (expr -> OBJECTID .)
    OF              reduce using rule 44 (expr -> OBJECTID .)
    LOOP            reduce using rule 44 (expr -> OBJECTID .)
    ELSE            reduce using rule 44 (expr -> OBJECTID .)
    POOL            reduce using rule 44 (expr -> OBJECTID .)
    FI              reduce using rule 44 (expr -> OBJECTID .)
    }               reduce using rule 44 (expr -> OBJECTID .)
    ASSIGN          shift and go to state 59
    (               shift and go to state 58


state 34

    (33) expr -> ( . expr )
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockexpr                      shift and go to state 40
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 60
    methodinvoke                   shift and go to state 48

state 35

    (46) letexpr -> LET . variablelist IN expr
    (55) variablelist -> . variabledefinition , variablelist
    (56) variablelist -> . variabledefinition
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (12) variabledeclaration -> . OBJECTID : TYPEID

    OBJECTID        shift and go to state 53

    variabledefinition             shift and go to state 61
    variabledeclaration            shift and go to state 15
    variablelist                   shift and go to state 62

state 36

    (43) expr -> BOOL_CONST .

    ,               reduce using rule 43 (expr -> BOOL_CONST .)
    +               reduce using rule 43 (expr -> BOOL_CONST .)
    -               reduce using rule 43 (expr -> BOOL_CONST .)
    *               reduce using rule 43 (expr -> BOOL_CONST .)
    /               reduce using rule 43 (expr -> BOOL_CONST .)
    <               reduce using rule 43 (expr -> BOOL_CONST .)
    LE              reduce using rule 43 (expr -> BOOL_CONST .)
    =               reduce using rule 43 (expr -> BOOL_CONST .)
    DOT             reduce using rule 43 (expr -> BOOL_CONST .)
    @               reduce using rule 43 (expr -> BOOL_CONST .)
    )               reduce using rule 43 (expr -> BOOL_CONST .)
    THEN            reduce using rule 43 (expr -> BOOL_CONST .)
    ;               reduce using rule 43 (expr -> BOOL_CONST .)
    IN              reduce using rule 43 (expr -> BOOL_CONST .)
    OF              reduce using rule 43 (expr -> BOOL_CONST .)
    LOOP            reduce using rule 43 (expr -> BOOL_CONST .)
    ELSE            reduce using rule 43 (expr -> BOOL_CONST .)
    POOL            reduce using rule 43 (expr -> BOOL_CONST .)
    FI              reduce using rule 43 (expr -> BOOL_CONST .)
    }               reduce using rule 43 (expr -> BOOL_CONST .)


state 37

    (51) whileloop -> WHILE . expr LOOP expr POOL
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockexpr                      shift and go to state 40
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 63
    methodinvoke                   shift and go to state 48

state 38

    (27) expr -> letexpr .

    ,               reduce using rule 27 (expr -> letexpr .)
    +               reduce using rule 27 (expr -> letexpr .)
    -               reduce using rule 27 (expr -> letexpr .)
    *               reduce using rule 27 (expr -> letexpr .)
    /               reduce using rule 27 (expr -> letexpr .)
    <               reduce using rule 27 (expr -> letexpr .)
    LE              reduce using rule 27 (expr -> letexpr .)
    =               reduce using rule 27 (expr -> letexpr .)
    DOT             reduce using rule 27 (expr -> letexpr .)
    @               reduce using rule 27 (expr -> letexpr .)
    )               reduce using rule 27 (expr -> letexpr .)
    THEN            reduce using rule 27 (expr -> letexpr .)
    ;               reduce using rule 27 (expr -> letexpr .)
    IN              reduce using rule 27 (expr -> letexpr .)
    OF              reduce using rule 27 (expr -> letexpr .)
    LOOP            reduce using rule 27 (expr -> letexpr .)
    ELSE            reduce using rule 27 (expr -> letexpr .)
    POOL            reduce using rule 27 (expr -> letexpr .)
    FI              reduce using rule 27 (expr -> letexpr .)
    }               reduce using rule 27 (expr -> letexpr .)


state 39

    (52) blockexpr -> { . blockstatements }
    (53) blockstatements -> . expr ; blockstatements
    (54) blockstatements -> . expr ;
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    blockexpr                      shift and go to state 40
    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockstatements                shift and go to state 65
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 64
    methodinvoke                   shift and go to state 48

state 40

    (26) expr -> blockexpr .

    ,               reduce using rule 26 (expr -> blockexpr .)
    +               reduce using rule 26 (expr -> blockexpr .)
    -               reduce using rule 26 (expr -> blockexpr .)
    *               reduce using rule 26 (expr -> blockexpr .)
    /               reduce using rule 26 (expr -> blockexpr .)
    <               reduce using rule 26 (expr -> blockexpr .)
    LE              reduce using rule 26 (expr -> blockexpr .)
    =               reduce using rule 26 (expr -> blockexpr .)
    DOT             reduce using rule 26 (expr -> blockexpr .)
    @               reduce using rule 26 (expr -> blockexpr .)
    )               reduce using rule 26 (expr -> blockexpr .)
    THEN            reduce using rule 26 (expr -> blockexpr .)
    ;               reduce using rule 26 (expr -> blockexpr .)
    IN              reduce using rule 26 (expr -> blockexpr .)
    OF              reduce using rule 26 (expr -> blockexpr .)
    LOOP            reduce using rule 26 (expr -> blockexpr .)
    ELSE            reduce using rule 26 (expr -> blockexpr .)
    POOL            reduce using rule 26 (expr -> blockexpr .)
    FI              reduce using rule 26 (expr -> blockexpr .)
    }               reduce using rule 26 (expr -> blockexpr .)


state 41

    (42) expr -> STR_CONST .

    ,               reduce using rule 42 (expr -> STR_CONST .)
    +               reduce using rule 42 (expr -> STR_CONST .)
    -               reduce using rule 42 (expr -> STR_CONST .)
    *               reduce using rule 42 (expr -> STR_CONST .)
    /               reduce using rule 42 (expr -> STR_CONST .)
    <               reduce using rule 42 (expr -> STR_CONST .)
    LE              reduce using rule 42 (expr -> STR_CONST .)
    =               reduce using rule 42 (expr -> STR_CONST .)
    DOT             reduce using rule 42 (expr -> STR_CONST .)
    @               reduce using rule 42 (expr -> STR_CONST .)
    )               reduce using rule 42 (expr -> STR_CONST .)
    THEN            reduce using rule 42 (expr -> STR_CONST .)
    ;               reduce using rule 42 (expr -> STR_CONST .)
    IN              reduce using rule 42 (expr -> STR_CONST .)
    OF              reduce using rule 42 (expr -> STR_CONST .)
    LOOP            reduce using rule 42 (expr -> STR_CONST .)
    ELSE            reduce using rule 42 (expr -> STR_CONST .)
    POOL            reduce using rule 42 (expr -> STR_CONST .)
    FI              reduce using rule 42 (expr -> STR_CONST .)
    }               reduce using rule 42 (expr -> STR_CONST .)


state 42

    (32) expr -> ~ . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockexpr                      shift and go to state 40
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 66
    methodinvoke                   shift and go to state 48

state 43

    (31) expr -> NOT . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockexpr                      shift and go to state 40
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 67
    methodinvoke                   shift and go to state 48

state 44

    (13) variableinitialization -> ASSIGN expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               reduce using rule 13 (variableinitialization -> ASSIGN expr .)
    ,               reduce using rule 13 (variableinitialization -> ASSIGN expr .)
    IN              reduce using rule 13 (variableinitialization -> ASSIGN expr .)
    +               shift and go to state 75
    -               shift and go to state 73
    *               shift and go to state 71
    /               shift and go to state 69
    <               shift and go to state 72
    LE              shift and go to state 70
    =               shift and go to state 68
    DOT             shift and go to state 74
    @               shift and go to state 76


state 45

    (28) expr -> caseexpr .

    ,               reduce using rule 28 (expr -> caseexpr .)
    +               reduce using rule 28 (expr -> caseexpr .)
    -               reduce using rule 28 (expr -> caseexpr .)
    *               reduce using rule 28 (expr -> caseexpr .)
    /               reduce using rule 28 (expr -> caseexpr .)
    <               reduce using rule 28 (expr -> caseexpr .)
    LE              reduce using rule 28 (expr -> caseexpr .)
    =               reduce using rule 28 (expr -> caseexpr .)
    DOT             reduce using rule 28 (expr -> caseexpr .)
    @               reduce using rule 28 (expr -> caseexpr .)
    )               reduce using rule 28 (expr -> caseexpr .)
    THEN            reduce using rule 28 (expr -> caseexpr .)
    ;               reduce using rule 28 (expr -> caseexpr .)
    IN              reduce using rule 28 (expr -> caseexpr .)
    OF              reduce using rule 28 (expr -> caseexpr .)
    LOOP            reduce using rule 28 (expr -> caseexpr .)
    ELSE            reduce using rule 28 (expr -> caseexpr .)
    POOL            reduce using rule 28 (expr -> caseexpr .)
    FI              reduce using rule 28 (expr -> caseexpr .)
    }               reduce using rule 28 (expr -> caseexpr .)


state 46

    (21) expr -> assignment .

    ,               reduce using rule 21 (expr -> assignment .)
    +               reduce using rule 21 (expr -> assignment .)
    -               reduce using rule 21 (expr -> assignment .)
    *               reduce using rule 21 (expr -> assignment .)
    /               reduce using rule 21 (expr -> assignment .)
    <               reduce using rule 21 (expr -> assignment .)
    LE              reduce using rule 21 (expr -> assignment .)
    =               reduce using rule 21 (expr -> assignment .)
    DOT             reduce using rule 21 (expr -> assignment .)
    @               reduce using rule 21 (expr -> assignment .)
    )               reduce using rule 21 (expr -> assignment .)
    THEN            reduce using rule 21 (expr -> assignment .)
    ;               reduce using rule 21 (expr -> assignment .)
    IN              reduce using rule 21 (expr -> assignment .)
    OF              reduce using rule 21 (expr -> assignment .)
    LOOP            reduce using rule 21 (expr -> assignment .)
    ELSE            reduce using rule 21 (expr -> assignment .)
    POOL            reduce using rule 21 (expr -> assignment .)
    FI              reduce using rule 21 (expr -> assignment .)
    }               reduce using rule 21 (expr -> assignment .)


state 47

    (41) expr -> INT_CONST .

    ,               reduce using rule 41 (expr -> INT_CONST .)
    +               reduce using rule 41 (expr -> INT_CONST .)
    -               reduce using rule 41 (expr -> INT_CONST .)
    *               reduce using rule 41 (expr -> INT_CONST .)
    /               reduce using rule 41 (expr -> INT_CONST .)
    <               reduce using rule 41 (expr -> INT_CONST .)
    LE              reduce using rule 41 (expr -> INT_CONST .)
    =               reduce using rule 41 (expr -> INT_CONST .)
    DOT             reduce using rule 41 (expr -> INT_CONST .)
    @               reduce using rule 41 (expr -> INT_CONST .)
    )               reduce using rule 41 (expr -> INT_CONST .)
    THEN            reduce using rule 41 (expr -> INT_CONST .)
    ;               reduce using rule 41 (expr -> INT_CONST .)
    IN              reduce using rule 41 (expr -> INT_CONST .)
    OF              reduce using rule 41 (expr -> INT_CONST .)
    LOOP            reduce using rule 41 (expr -> INT_CONST .)
    ELSE            reduce using rule 41 (expr -> INT_CONST .)
    POOL            reduce using rule 41 (expr -> INT_CONST .)
    FI              reduce using rule 41 (expr -> INT_CONST .)
    }               reduce using rule 41 (expr -> INT_CONST .)


state 48

    (22) expr -> methodinvoke .

    ,               reduce using rule 22 (expr -> methodinvoke .)
    +               reduce using rule 22 (expr -> methodinvoke .)
    -               reduce using rule 22 (expr -> methodinvoke .)
    *               reduce using rule 22 (expr -> methodinvoke .)
    /               reduce using rule 22 (expr -> methodinvoke .)
    <               reduce using rule 22 (expr -> methodinvoke .)
    LE              reduce using rule 22 (expr -> methodinvoke .)
    =               reduce using rule 22 (expr -> methodinvoke .)
    DOT             reduce using rule 22 (expr -> methodinvoke .)
    @               reduce using rule 22 (expr -> methodinvoke .)
    )               reduce using rule 22 (expr -> methodinvoke .)
    THEN            reduce using rule 22 (expr -> methodinvoke .)
    ;               reduce using rule 22 (expr -> methodinvoke .)
    IN              reduce using rule 22 (expr -> methodinvoke .)
    OF              reduce using rule 22 (expr -> methodinvoke .)
    LOOP            reduce using rule 22 (expr -> methodinvoke .)
    ELSE            reduce using rule 22 (expr -> methodinvoke .)
    POOL            reduce using rule 22 (expr -> methodinvoke .)
    FI              reduce using rule 22 (expr -> methodinvoke .)
    }               reduce using rule 22 (expr -> methodinvoke .)


state 49

    (29) expr -> NEW . TYPEID

    TYPEID          shift and go to state 77


state 50

    (12) variabledeclaration -> OBJECTID : TYPEID .

    ASSIGN          reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    ,               reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    IN              reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    )               reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    ;               reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    DARROW          reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)


state 51

    (10) methoddefinition -> OBJECTID ( formalargs . ) : TYPEID { expr }

    )               shift and go to state 78


state 52

    (15) formalargs -> variabledeclaration . , formalargs
    (16) formalargs -> variabledeclaration .

    ,               shift and go to state 79
    )               reduce using rule 16 (formalargs -> variabledeclaration .)


state 53

    (12) variabledeclaration -> OBJECTID . : TYPEID

    :               shift and go to state 24


state 54

    (17) formalargs -> empty .

    )               reduce using rule 17 (formalargs -> empty .)


state 55

    (30) expr -> ISVOID expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 30 (expr -> ISVOID expr .)
    +               reduce using rule 30 (expr -> ISVOID expr .)
    -               reduce using rule 30 (expr -> ISVOID expr .)
    *               reduce using rule 30 (expr -> ISVOID expr .)
    /               reduce using rule 30 (expr -> ISVOID expr .)
    <               reduce using rule 30 (expr -> ISVOID expr .)
    LE              reduce using rule 30 (expr -> ISVOID expr .)
    =               reduce using rule 30 (expr -> ISVOID expr .)
    )               reduce using rule 30 (expr -> ISVOID expr .)
    THEN            reduce using rule 30 (expr -> ISVOID expr .)
    ;               reduce using rule 30 (expr -> ISVOID expr .)
    IN              reduce using rule 30 (expr -> ISVOID expr .)
    OF              reduce using rule 30 (expr -> ISVOID expr .)
    LOOP            reduce using rule 30 (expr -> ISVOID expr .)
    ELSE            reduce using rule 30 (expr -> ISVOID expr .)
    POOL            reduce using rule 30 (expr -> ISVOID expr .)
    FI              reduce using rule 30 (expr -> ISVOID expr .)
    }               reduce using rule 30 (expr -> ISVOID expr .)
    DOT             shift and go to state 74
    @               shift and go to state 76

  ! DOT             [ reduce using rule 30 (expr -> ISVOID expr .) ]
  ! @               [ reduce using rule 30 (expr -> ISVOID expr .) ]
  ! +               [ shift and go to state 75 ]
  ! -               [ shift and go to state 73 ]
  ! *               [ shift and go to state 71 ]
  ! /               [ shift and go to state 69 ]
  ! <               [ shift and go to state 72 ]
  ! LE              [ shift and go to state 70 ]
  ! =               [ shift and go to state 68 ]


state 56

    (50) ifthenelse -> IF expr . THEN expr ELSE expr FI
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    THEN            shift and go to state 80
    +               shift and go to state 75
    -               shift and go to state 73
    *               shift and go to state 71
    /               shift and go to state 69
    <               shift and go to state 72
    LE              shift and go to state 70
    =               shift and go to state 68
    DOT             shift and go to state 74
    @               shift and go to state 76


state 57

    (57) caseexpr -> CASE expr . OF casestatements ESAC
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    OF              shift and go to state 81
    +               shift and go to state 75
    -               shift and go to state 73
    *               shift and go to state 71
    /               shift and go to state 69
    <               shift and go to state 72
    LE              shift and go to state 70
    =               shift and go to state 68
    DOT             shift and go to state 74
    @               shift and go to state 76


state 58

    (49) localmethodinvoke -> OBJECTID ( . actualargs )
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    blockexpr                      shift and go to state 40
    letexpr                        shift and go to state 38
    actualargs                     shift and go to state 82
    caseexpr                       shift and go to state 45
    localmethodinvoke              shift and go to state 28
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    empty                          shift and go to state 84
    expr                           shift and go to state 83
    methodinvoke                   shift and go to state 48

state 59

    (45) assignment -> OBJECTID ASSIGN . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockexpr                      shift and go to state 40
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 85
    methodinvoke                   shift and go to state 48

state 60

    (33) expr -> ( expr . )
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    )               shift and go to state 86
    +               shift and go to state 75
    -               shift and go to state 73
    *               shift and go to state 71
    /               shift and go to state 69
    <               shift and go to state 72
    LE              shift and go to state 70
    =               shift and go to state 68
    DOT             shift and go to state 74
    @               shift and go to state 76


state 61

    (55) variablelist -> variabledefinition . , variablelist
    (56) variablelist -> variabledefinition .

    ,               shift and go to state 87
    IN              reduce using rule 56 (variablelist -> variabledefinition .)


state 62

    (46) letexpr -> LET variablelist . IN expr

    IN              shift and go to state 88


state 63

    (51) whileloop -> WHILE expr . LOOP expr POOL
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    LOOP            shift and go to state 89
    +               shift and go to state 75
    -               shift and go to state 73
    *               shift and go to state 71
    /               shift and go to state 69
    <               shift and go to state 72
    LE              shift and go to state 70
    =               shift and go to state 68
    DOT             shift and go to state 74
    @               shift and go to state 76


state 64

    (53) blockstatements -> expr . ; blockstatements
    (54) blockstatements -> expr . ;
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               shift and go to state 90
    +               shift and go to state 75
    -               shift and go to state 73
    *               shift and go to state 71
    /               shift and go to state 69
    <               shift and go to state 72
    LE              shift and go to state 70
    =               shift and go to state 68
    DOT             shift and go to state 74
    @               shift and go to state 76


state 65

    (52) blockexpr -> { blockstatements . }

    }               shift and go to state 91


state 66

    (32) expr -> ~ expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 32 (expr -> ~ expr .)
    +               reduce using rule 32 (expr -> ~ expr .)
    -               reduce using rule 32 (expr -> ~ expr .)
    *               reduce using rule 32 (expr -> ~ expr .)
    /               reduce using rule 32 (expr -> ~ expr .)
    <               reduce using rule 32 (expr -> ~ expr .)
    LE              reduce using rule 32 (expr -> ~ expr .)
    =               reduce using rule 32 (expr -> ~ expr .)
    )               reduce using rule 32 (expr -> ~ expr .)
    THEN            reduce using rule 32 (expr -> ~ expr .)
    ;               reduce using rule 32 (expr -> ~ expr .)
    IN              reduce using rule 32 (expr -> ~ expr .)
    OF              reduce using rule 32 (expr -> ~ expr .)
    LOOP            reduce using rule 32 (expr -> ~ expr .)
    ELSE            reduce using rule 32 (expr -> ~ expr .)
    POOL            reduce using rule 32 (expr -> ~ expr .)
    FI              reduce using rule 32 (expr -> ~ expr .)
    }               reduce using rule 32 (expr -> ~ expr .)
    DOT             shift and go to state 74
    @               shift and go to state 76

  ! DOT             [ reduce using rule 32 (expr -> ~ expr .) ]
  ! @               [ reduce using rule 32 (expr -> ~ expr .) ]
  ! +               [ shift and go to state 75 ]
  ! -               [ shift and go to state 73 ]
  ! *               [ shift and go to state 71 ]
  ! /               [ shift and go to state 69 ]
  ! <               [ shift and go to state 72 ]
  ! LE              [ shift and go to state 70 ]
  ! =               [ shift and go to state 68 ]


state 67

    (31) expr -> NOT expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 31 (expr -> NOT expr .)
    )               reduce using rule 31 (expr -> NOT expr .)
    THEN            reduce using rule 31 (expr -> NOT expr .)
    ;               reduce using rule 31 (expr -> NOT expr .)
    IN              reduce using rule 31 (expr -> NOT expr .)
    OF              reduce using rule 31 (expr -> NOT expr .)
    LOOP            reduce using rule 31 (expr -> NOT expr .)
    ELSE            reduce using rule 31 (expr -> NOT expr .)
    POOL            reduce using rule 31 (expr -> NOT expr .)
    FI              reduce using rule 31 (expr -> NOT expr .)
    }               reduce using rule 31 (expr -> NOT expr .)
    +               shift and go to state 75
    -               shift and go to state 73
    *               shift and go to state 71
    /               shift and go to state 69
    <               shift and go to state 72
    LE              shift and go to state 70
    =               shift and go to state 68
    DOT             shift and go to state 74
    @               shift and go to state 76

  ! +               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! -               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! *               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! /               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! <               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! LE              [ reduce using rule 31 (expr -> NOT expr .) ]
  ! =               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! DOT             [ reduce using rule 31 (expr -> NOT expr .) ]
  ! @               [ reduce using rule 31 (expr -> NOT expr .) ]


state 68

    (40) expr -> expr = . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockexpr                      shift and go to state 40
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 92
    methodinvoke                   shift and go to state 48

state 69

    (37) expr -> expr / . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockexpr                      shift and go to state 40
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 93
    methodinvoke                   shift and go to state 48

state 70

    (39) expr -> expr LE . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockexpr                      shift and go to state 40
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 94
    methodinvoke                   shift and go to state 48

state 71

    (36) expr -> expr * . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockexpr                      shift and go to state 40
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 95
    methodinvoke                   shift and go to state 48

state 72

    (38) expr -> expr < . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockexpr                      shift and go to state 40
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 96
    methodinvoke                   shift and go to state 48

state 73

    (35) expr -> expr - . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockexpr                      shift and go to state 40
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 97
    methodinvoke                   shift and go to state 48

state 74

    (47) methodinvoke -> expr DOT . OBJECTID ( actualargs )

    OBJECTID        shift and go to state 98


state 75

    (34) expr -> expr + . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockexpr                      shift and go to state 40
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 99
    methodinvoke                   shift and go to state 48

state 76

    (48) methodinvoke -> expr @ . TYPEID DOT OBJECTID ( actualargs )

    TYPEID          shift and go to state 100


state 77

    (29) expr -> NEW TYPEID .

    ,               reduce using rule 29 (expr -> NEW TYPEID .)
    +               reduce using rule 29 (expr -> NEW TYPEID .)
    -               reduce using rule 29 (expr -> NEW TYPEID .)
    *               reduce using rule 29 (expr -> NEW TYPEID .)
    /               reduce using rule 29 (expr -> NEW TYPEID .)
    <               reduce using rule 29 (expr -> NEW TYPEID .)
    LE              reduce using rule 29 (expr -> NEW TYPEID .)
    =               reduce using rule 29 (expr -> NEW TYPEID .)
    DOT             reduce using rule 29 (expr -> NEW TYPEID .)
    @               reduce using rule 29 (expr -> NEW TYPEID .)
    )               reduce using rule 29 (expr -> NEW TYPEID .)
    THEN            reduce using rule 29 (expr -> NEW TYPEID .)
    ;               reduce using rule 29 (expr -> NEW TYPEID .)
    IN              reduce using rule 29 (expr -> NEW TYPEID .)
    OF              reduce using rule 29 (expr -> NEW TYPEID .)
    LOOP            reduce using rule 29 (expr -> NEW TYPEID .)
    ELSE            reduce using rule 29 (expr -> NEW TYPEID .)
    POOL            reduce using rule 29 (expr -> NEW TYPEID .)
    FI              reduce using rule 29 (expr -> NEW TYPEID .)
    }               reduce using rule 29 (expr -> NEW TYPEID .)


state 78

    (10) methoddefinition -> OBJECTID ( formalargs ) . : TYPEID { expr }

    :               shift and go to state 101


state 79

    (15) formalargs -> variabledeclaration , . formalargs
    (15) formalargs -> . variabledeclaration , formalargs
    (16) formalargs -> . variabledeclaration
    (17) formalargs -> . empty
    (12) variabledeclaration -> . OBJECTID : TYPEID
    (60) empty -> .

    OBJECTID        shift and go to state 53
    )               reduce using rule 60 (empty -> .)

    empty                          shift and go to state 54
    variabledeclaration            shift and go to state 52
    formalargs                     shift and go to state 102

state 80

    (50) ifthenelse -> IF expr THEN . expr ELSE expr FI
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockexpr                      shift and go to state 40
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 103
    methodinvoke                   shift and go to state 48

state 81

    (57) caseexpr -> CASE expr OF . casestatements ESAC
    (58) casestatements -> . variabledeclaration DARROW expr ; casestatements
    (59) casestatements -> . variabledeclaration DARROW expr ;
    (12) variabledeclaration -> . OBJECTID : TYPEID

    OBJECTID        shift and go to state 53

    variabledeclaration            shift and go to state 104
    casestatements                 shift and go to state 105

state 82

    (49) localmethodinvoke -> OBJECTID ( actualargs . )

    )               shift and go to state 106


state 83

    (18) actualargs -> expr . , actualargs
    (19) actualargs -> expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               shift and go to state 107
    )               reduce using rule 19 (actualargs -> expr .)
    +               shift and go to state 75
    -               shift and go to state 73
    *               shift and go to state 71
    /               shift and go to state 69
    <               shift and go to state 72
    LE              shift and go to state 70
    =               shift and go to state 68
    DOT             shift and go to state 74
    @               shift and go to state 76


state 84

    (20) actualargs -> empty .

    )               reduce using rule 20 (actualargs -> empty .)


state 85

    (45) assignment -> OBJECTID ASSIGN expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    ,               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    IN              reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    THEN            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    OF              reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    )               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    LOOP            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    ELSE            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    POOL            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    FI              reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    }               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    +               shift and go to state 75
    -               shift and go to state 73
    *               shift and go to state 71
    /               shift and go to state 69
    <               shift and go to state 72
    LE              shift and go to state 70
    =               shift and go to state 68
    DOT             shift and go to state 74
    @               shift and go to state 76

  ! +               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! -               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! *               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! /               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! <               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! LE              [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! =               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! DOT             [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! @               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]


state 86

    (33) expr -> ( expr ) .

    ,               reduce using rule 33 (expr -> ( expr ) .)
    +               reduce using rule 33 (expr -> ( expr ) .)
    -               reduce using rule 33 (expr -> ( expr ) .)
    *               reduce using rule 33 (expr -> ( expr ) .)
    /               reduce using rule 33 (expr -> ( expr ) .)
    <               reduce using rule 33 (expr -> ( expr ) .)
    LE              reduce using rule 33 (expr -> ( expr ) .)
    =               reduce using rule 33 (expr -> ( expr ) .)
    DOT             reduce using rule 33 (expr -> ( expr ) .)
    @               reduce using rule 33 (expr -> ( expr ) .)
    )               reduce using rule 33 (expr -> ( expr ) .)
    THEN            reduce using rule 33 (expr -> ( expr ) .)
    ;               reduce using rule 33 (expr -> ( expr ) .)
    IN              reduce using rule 33 (expr -> ( expr ) .)
    OF              reduce using rule 33 (expr -> ( expr ) .)
    LOOP            reduce using rule 33 (expr -> ( expr ) .)
    ELSE            reduce using rule 33 (expr -> ( expr ) .)
    POOL            reduce using rule 33 (expr -> ( expr ) .)
    FI              reduce using rule 33 (expr -> ( expr ) .)
    }               reduce using rule 33 (expr -> ( expr ) .)


state 87

    (55) variablelist -> variabledefinition , . variablelist
    (55) variablelist -> . variabledefinition , variablelist
    (56) variablelist -> . variabledefinition
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (12) variabledeclaration -> . OBJECTID : TYPEID

    OBJECTID        shift and go to state 53

    variabledefinition             shift and go to state 61
    variabledeclaration            shift and go to state 15
    variablelist                   shift and go to state 108

state 88

    (46) letexpr -> LET variablelist IN . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    blockexpr                      shift and go to state 40
    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 109
    methodinvoke                   shift and go to state 48

state 89

    (51) whileloop -> WHILE expr LOOP . expr POOL
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockexpr                      shift and go to state 40
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 110
    methodinvoke                   shift and go to state 48

state 90

    (53) blockstatements -> expr ; . blockstatements
    (54) blockstatements -> expr ; .
    (53) blockstatements -> . expr ; blockstatements
    (54) blockstatements -> . expr ;
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    }               reduce using rule 54 (blockstatements -> expr ; .)
    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    blockexpr                      shift and go to state 40
    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockstatements                shift and go to state 111
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 64
    methodinvoke                   shift and go to state 48

state 91

    (52) blockexpr -> { blockstatements } .

    +               reduce using rule 52 (blockexpr -> { blockstatements } .)
    -               reduce using rule 52 (blockexpr -> { blockstatements } .)
    *               reduce using rule 52 (blockexpr -> { blockstatements } .)
    /               reduce using rule 52 (blockexpr -> { blockstatements } .)
    <               reduce using rule 52 (blockexpr -> { blockstatements } .)
    LE              reduce using rule 52 (blockexpr -> { blockstatements } .)
    =               reduce using rule 52 (blockexpr -> { blockstatements } .)
    DOT             reduce using rule 52 (blockexpr -> { blockstatements } .)
    @               reduce using rule 52 (blockexpr -> { blockstatements } .)
    ;               reduce using rule 52 (blockexpr -> { blockstatements } .)
    ,               reduce using rule 52 (blockexpr -> { blockstatements } .)
    IN              reduce using rule 52 (blockexpr -> { blockstatements } .)
    THEN            reduce using rule 52 (blockexpr -> { blockstatements } .)
    OF              reduce using rule 52 (blockexpr -> { blockstatements } .)
    )               reduce using rule 52 (blockexpr -> { blockstatements } .)
    LOOP            reduce using rule 52 (blockexpr -> { blockstatements } .)
    ELSE            reduce using rule 52 (blockexpr -> { blockstatements } .)
    POOL            reduce using rule 52 (blockexpr -> { blockstatements } .)
    FI              reduce using rule 52 (blockexpr -> { blockstatements } .)
    }               reduce using rule 52 (blockexpr -> { blockstatements } .)


state 92

    (40) expr -> expr = expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 40 (expr -> expr = expr .)
    <               reduce using rule 40 (expr -> expr = expr .)
    LE              reduce using rule 40 (expr -> expr = expr .)
    =               reduce using rule 40 (expr -> expr = expr .)
    )               reduce using rule 40 (expr -> expr = expr .)
    THEN            reduce using rule 40 (expr -> expr = expr .)
    ;               reduce using rule 40 (expr -> expr = expr .)
    IN              reduce using rule 40 (expr -> expr = expr .)
    OF              reduce using rule 40 (expr -> expr = expr .)
    LOOP            reduce using rule 40 (expr -> expr = expr .)
    ELSE            reduce using rule 40 (expr -> expr = expr .)
    POOL            reduce using rule 40 (expr -> expr = expr .)
    FI              reduce using rule 40 (expr -> expr = expr .)
    }               reduce using rule 40 (expr -> expr = expr .)
    +               shift and go to state 75
    -               shift and go to state 73
    *               shift and go to state 71
    /               shift and go to state 69
    DOT             shift and go to state 74
    @               shift and go to state 76

  ! +               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! -               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! *               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! /               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! DOT             [ reduce using rule 40 (expr -> expr = expr .) ]
  ! @               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! <               [ shift and go to state 72 ]
  ! LE              [ shift and go to state 70 ]
  ! =               [ shift and go to state 68 ]


state 93

    (37) expr -> expr / expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 37 (expr -> expr / expr .)
    +               reduce using rule 37 (expr -> expr / expr .)
    -               reduce using rule 37 (expr -> expr / expr .)
    *               reduce using rule 37 (expr -> expr / expr .)
    /               reduce using rule 37 (expr -> expr / expr .)
    <               reduce using rule 37 (expr -> expr / expr .)
    LE              reduce using rule 37 (expr -> expr / expr .)
    =               reduce using rule 37 (expr -> expr / expr .)
    )               reduce using rule 37 (expr -> expr / expr .)
    THEN            reduce using rule 37 (expr -> expr / expr .)
    ;               reduce using rule 37 (expr -> expr / expr .)
    IN              reduce using rule 37 (expr -> expr / expr .)
    OF              reduce using rule 37 (expr -> expr / expr .)
    LOOP            reduce using rule 37 (expr -> expr / expr .)
    ELSE            reduce using rule 37 (expr -> expr / expr .)
    POOL            reduce using rule 37 (expr -> expr / expr .)
    FI              reduce using rule 37 (expr -> expr / expr .)
    }               reduce using rule 37 (expr -> expr / expr .)
    DOT             shift and go to state 74
    @               shift and go to state 76

  ! DOT             [ reduce using rule 37 (expr -> expr / expr .) ]
  ! @               [ reduce using rule 37 (expr -> expr / expr .) ]
  ! +               [ shift and go to state 75 ]
  ! -               [ shift and go to state 73 ]
  ! *               [ shift and go to state 71 ]
  ! /               [ shift and go to state 69 ]
  ! <               [ shift and go to state 72 ]
  ! LE              [ shift and go to state 70 ]
  ! =               [ shift and go to state 68 ]


state 94

    (39) expr -> expr LE expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 39 (expr -> expr LE expr .)
    <               reduce using rule 39 (expr -> expr LE expr .)
    LE              reduce using rule 39 (expr -> expr LE expr .)
    =               reduce using rule 39 (expr -> expr LE expr .)
    )               reduce using rule 39 (expr -> expr LE expr .)
    THEN            reduce using rule 39 (expr -> expr LE expr .)
    ;               reduce using rule 39 (expr -> expr LE expr .)
    IN              reduce using rule 39 (expr -> expr LE expr .)
    OF              reduce using rule 39 (expr -> expr LE expr .)
    LOOP            reduce using rule 39 (expr -> expr LE expr .)
    ELSE            reduce using rule 39 (expr -> expr LE expr .)
    POOL            reduce using rule 39 (expr -> expr LE expr .)
    FI              reduce using rule 39 (expr -> expr LE expr .)
    }               reduce using rule 39 (expr -> expr LE expr .)
    +               shift and go to state 75
    -               shift and go to state 73
    *               shift and go to state 71
    /               shift and go to state 69
    DOT             shift and go to state 74
    @               shift and go to state 76

  ! +               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! -               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! *               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! /               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! DOT             [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! @               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! <               [ shift and go to state 72 ]
  ! LE              [ shift and go to state 70 ]
  ! =               [ shift and go to state 68 ]


state 95

    (36) expr -> expr * expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 36 (expr -> expr * expr .)
    +               reduce using rule 36 (expr -> expr * expr .)
    -               reduce using rule 36 (expr -> expr * expr .)
    *               reduce using rule 36 (expr -> expr * expr .)
    /               reduce using rule 36 (expr -> expr * expr .)
    <               reduce using rule 36 (expr -> expr * expr .)
    LE              reduce using rule 36 (expr -> expr * expr .)
    =               reduce using rule 36 (expr -> expr * expr .)
    )               reduce using rule 36 (expr -> expr * expr .)
    THEN            reduce using rule 36 (expr -> expr * expr .)
    ;               reduce using rule 36 (expr -> expr * expr .)
    IN              reduce using rule 36 (expr -> expr * expr .)
    OF              reduce using rule 36 (expr -> expr * expr .)
    LOOP            reduce using rule 36 (expr -> expr * expr .)
    ELSE            reduce using rule 36 (expr -> expr * expr .)
    POOL            reduce using rule 36 (expr -> expr * expr .)
    FI              reduce using rule 36 (expr -> expr * expr .)
    }               reduce using rule 36 (expr -> expr * expr .)
    DOT             shift and go to state 74
    @               shift and go to state 76

  ! DOT             [ reduce using rule 36 (expr -> expr * expr .) ]
  ! @               [ reduce using rule 36 (expr -> expr * expr .) ]
  ! +               [ shift and go to state 75 ]
  ! -               [ shift and go to state 73 ]
  ! *               [ shift and go to state 71 ]
  ! /               [ shift and go to state 69 ]
  ! <               [ shift and go to state 72 ]
  ! LE              [ shift and go to state 70 ]
  ! =               [ shift and go to state 68 ]


state 96

    (38) expr -> expr < expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 38 (expr -> expr < expr .)
    <               reduce using rule 38 (expr -> expr < expr .)
    LE              reduce using rule 38 (expr -> expr < expr .)
    =               reduce using rule 38 (expr -> expr < expr .)
    )               reduce using rule 38 (expr -> expr < expr .)
    THEN            reduce using rule 38 (expr -> expr < expr .)
    ;               reduce using rule 38 (expr -> expr < expr .)
    IN              reduce using rule 38 (expr -> expr < expr .)
    OF              reduce using rule 38 (expr -> expr < expr .)
    LOOP            reduce using rule 38 (expr -> expr < expr .)
    ELSE            reduce using rule 38 (expr -> expr < expr .)
    POOL            reduce using rule 38 (expr -> expr < expr .)
    FI              reduce using rule 38 (expr -> expr < expr .)
    }               reduce using rule 38 (expr -> expr < expr .)
    +               shift and go to state 75
    -               shift and go to state 73
    *               shift and go to state 71
    /               shift and go to state 69
    DOT             shift and go to state 74
    @               shift and go to state 76

  ! +               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! DOT             [ reduce using rule 38 (expr -> expr < expr .) ]
  ! @               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! <               [ shift and go to state 72 ]
  ! LE              [ shift and go to state 70 ]
  ! =               [ shift and go to state 68 ]


state 97

    (35) expr -> expr - expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 35 (expr -> expr - expr .)
    +               reduce using rule 35 (expr -> expr - expr .)
    -               reduce using rule 35 (expr -> expr - expr .)
    <               reduce using rule 35 (expr -> expr - expr .)
    LE              reduce using rule 35 (expr -> expr - expr .)
    =               reduce using rule 35 (expr -> expr - expr .)
    )               reduce using rule 35 (expr -> expr - expr .)
    THEN            reduce using rule 35 (expr -> expr - expr .)
    ;               reduce using rule 35 (expr -> expr - expr .)
    IN              reduce using rule 35 (expr -> expr - expr .)
    OF              reduce using rule 35 (expr -> expr - expr .)
    LOOP            reduce using rule 35 (expr -> expr - expr .)
    ELSE            reduce using rule 35 (expr -> expr - expr .)
    POOL            reduce using rule 35 (expr -> expr - expr .)
    FI              reduce using rule 35 (expr -> expr - expr .)
    }               reduce using rule 35 (expr -> expr - expr .)
    *               shift and go to state 71
    /               shift and go to state 69
    DOT             shift and go to state 74
    @               shift and go to state 76

  ! *               [ reduce using rule 35 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 35 (expr -> expr - expr .) ]
  ! DOT             [ reduce using rule 35 (expr -> expr - expr .) ]
  ! @               [ reduce using rule 35 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 75 ]
  ! -               [ shift and go to state 73 ]
  ! <               [ shift and go to state 72 ]
  ! LE              [ shift and go to state 70 ]
  ! =               [ shift and go to state 68 ]


state 98

    (47) methodinvoke -> expr DOT OBJECTID . ( actualargs )

    (               shift and go to state 112


state 99

    (34) expr -> expr + expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 34 (expr -> expr + expr .)
    +               reduce using rule 34 (expr -> expr + expr .)
    -               reduce using rule 34 (expr -> expr + expr .)
    <               reduce using rule 34 (expr -> expr + expr .)
    LE              reduce using rule 34 (expr -> expr + expr .)
    =               reduce using rule 34 (expr -> expr + expr .)
    )               reduce using rule 34 (expr -> expr + expr .)
    THEN            reduce using rule 34 (expr -> expr + expr .)
    ;               reduce using rule 34 (expr -> expr + expr .)
    IN              reduce using rule 34 (expr -> expr + expr .)
    OF              reduce using rule 34 (expr -> expr + expr .)
    LOOP            reduce using rule 34 (expr -> expr + expr .)
    ELSE            reduce using rule 34 (expr -> expr + expr .)
    POOL            reduce using rule 34 (expr -> expr + expr .)
    FI              reduce using rule 34 (expr -> expr + expr .)
    }               reduce using rule 34 (expr -> expr + expr .)
    *               shift and go to state 71
    /               shift and go to state 69
    DOT             shift and go to state 74
    @               shift and go to state 76

  ! *               [ reduce using rule 34 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 34 (expr -> expr + expr .) ]
  ! DOT             [ reduce using rule 34 (expr -> expr + expr .) ]
  ! @               [ reduce using rule 34 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 75 ]
  ! -               [ shift and go to state 73 ]
  ! <               [ shift and go to state 72 ]
  ! LE              [ shift and go to state 70 ]
  ! =               [ shift and go to state 68 ]


state 100

    (48) methodinvoke -> expr @ TYPEID . DOT OBJECTID ( actualargs )

    DOT             shift and go to state 113


state 101

    (10) methoddefinition -> OBJECTID ( formalargs ) : . TYPEID { expr }

    TYPEID          shift and go to state 114


state 102

    (15) formalargs -> variabledeclaration , formalargs .

    )               reduce using rule 15 (formalargs -> variabledeclaration , formalargs .)


state 103

    (50) ifthenelse -> IF expr THEN expr . ELSE expr FI
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ELSE            shift and go to state 115
    +               shift and go to state 75
    -               shift and go to state 73
    *               shift and go to state 71
    /               shift and go to state 69
    <               shift and go to state 72
    LE              shift and go to state 70
    =               shift and go to state 68
    DOT             shift and go to state 74
    @               shift and go to state 76


state 104

    (58) casestatements -> variabledeclaration . DARROW expr ; casestatements
    (59) casestatements -> variabledeclaration . DARROW expr ;

    DARROW          shift and go to state 116


state 105

    (57) caseexpr -> CASE expr OF casestatements . ESAC

    ESAC            shift and go to state 117


state 106

    (49) localmethodinvoke -> OBJECTID ( actualargs ) .

    +               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    -               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    *               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    /               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    <               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    LE              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    =               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    DOT             reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    @               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    ;               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    ,               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    IN              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    THEN            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    OF              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    )               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    LOOP            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    ELSE            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    POOL            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    FI              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    }               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)


state 107

    (18) actualargs -> expr , . actualargs
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    blockexpr                      shift and go to state 40
    letexpr                        shift and go to state 38
    actualargs                     shift and go to state 118
    caseexpr                       shift and go to state 45
    localmethodinvoke              shift and go to state 28
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    empty                          shift and go to state 84
    expr                           shift and go to state 83
    methodinvoke                   shift and go to state 48

state 108

    (55) variablelist -> variabledefinition , variablelist .

    IN              reduce using rule 55 (variablelist -> variabledefinition , variablelist .)


state 109

    (46) letexpr -> LET variablelist IN expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    THEN            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    ;               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    ,               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    IN              reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    OF              reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    )               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    LOOP            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    ELSE            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    POOL            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    FI              reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    }               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    +               shift and go to state 75
    -               shift and go to state 73
    *               shift and go to state 71
    /               shift and go to state 69
    <               shift and go to state 72
    LE              shift and go to state 70
    =               shift and go to state 68
    DOT             shift and go to state 74
    @               shift and go to state 76

  ! +               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! -               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! *               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! /               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! <               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! LE              [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! =               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! DOT             [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! @               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]


state 110

    (51) whileloop -> WHILE expr LOOP expr . POOL
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    POOL            shift and go to state 119
    +               shift and go to state 75
    -               shift and go to state 73
    *               shift and go to state 71
    /               shift and go to state 69
    <               shift and go to state 72
    LE              shift and go to state 70
    =               shift and go to state 68
    DOT             shift and go to state 74
    @               shift and go to state 76


state 111

    (53) blockstatements -> expr ; blockstatements .

    }               reduce using rule 53 (blockstatements -> expr ; blockstatements .)


state 112

    (47) methodinvoke -> expr DOT OBJECTID ( . actualargs )
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    blockexpr                      shift and go to state 40
    letexpr                        shift and go to state 38
    actualargs                     shift and go to state 120
    caseexpr                       shift and go to state 45
    localmethodinvoke              shift and go to state 28
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    empty                          shift and go to state 84
    expr                           shift and go to state 83
    methodinvoke                   shift and go to state 48

state 113

    (48) methodinvoke -> expr @ TYPEID DOT . OBJECTID ( actualargs )

    OBJECTID        shift and go to state 121


state 114

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID . { expr }

    {               shift and go to state 122


state 115

    (50) ifthenelse -> IF expr THEN expr ELSE . expr FI
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    blockexpr                      shift and go to state 40
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 123
    methodinvoke                   shift and go to state 48

state 116

    (58) casestatements -> variabledeclaration DARROW . expr ; casestatements
    (59) casestatements -> variabledeclaration DARROW . expr ;
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    blockexpr                      shift and go to state 40
    letexpr                        shift and go to state 38
    whileloop                      shift and go to state 32
    localmethodinvoke              shift and go to state 28
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 45
    expr                           shift and go to state 124
    methodinvoke                   shift and go to state 48

state 117

    (57) caseexpr -> CASE expr OF casestatements ESAC .

    +               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    -               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    *               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    /               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    <               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    LE              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    =               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    DOT             reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    @               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    ;               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    ,               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    IN              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    THEN            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    OF              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    )               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    LOOP            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    ELSE            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    POOL            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    FI              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    }               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)


state 118

    (18) actualargs -> expr , actualargs .

    )               reduce using rule 18 (actualargs -> expr , actualargs .)


state 119

    (51) whileloop -> WHILE expr LOOP expr POOL .

    +               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    -               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    *               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    /               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    <               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    LE              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    =               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    DOT             reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    @               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    ;               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    ,               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    IN              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    THEN            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    OF              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    )               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    LOOP            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    ELSE            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    POOL            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    FI              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    }               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)


state 120

    (47) methodinvoke -> expr DOT OBJECTID ( actualargs . )

    )               shift and go to state 125


state 121

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID . ( actualargs )

    (               shift and go to state 126


state 122

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID { . expr }
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    blockexpr                      shift and go to state 40
    letexpr                        shift and go to state 38
    localmethodinvoke              shift and go to state 28
    caseexpr                       shift and go to state 45
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    expr                           shift and go to state 127
    methodinvoke                   shift and go to state 48

state 123

    (50) ifthenelse -> IF expr THEN expr ELSE expr . FI
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    FI              shift and go to state 128
    +               shift and go to state 75
    -               shift and go to state 73
    *               shift and go to state 71
    /               shift and go to state 69
    <               shift and go to state 72
    LE              shift and go to state 70
    =               shift and go to state 68
    DOT             shift and go to state 74
    @               shift and go to state 76


state 124

    (58) casestatements -> variabledeclaration DARROW expr . ; casestatements
    (59) casestatements -> variabledeclaration DARROW expr . ;
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               shift and go to state 129
    +               shift and go to state 75
    -               shift and go to state 73
    *               shift and go to state 71
    /               shift and go to state 69
    <               shift and go to state 72
    LE              shift and go to state 70
    =               shift and go to state 68
    DOT             shift and go to state 74
    @               shift and go to state 76


state 125

    (47) methodinvoke -> expr DOT OBJECTID ( actualargs ) .

    )               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    +               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    -               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    *               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    /               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    <               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    LE              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    =               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    DOT             reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    @               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    ,               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    ;               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    POOL            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    }               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    IN              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    THEN            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    OF              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    LOOP            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    ELSE            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    FI              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)


state 126

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID ( . actualargs )
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 49
    ISVOID          shift and go to state 27
    NOT             shift and go to state 43
    ~               shift and go to state 42
    (               shift and go to state 34
    INT_CONST       shift and go to state 47
    STR_CONST       shift and go to state 41
    BOOL_CONST      shift and go to state 36
    OBJECTID        shift and go to state 33
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 30
    WHILE           shift and go to state 37
    {               shift and go to state 39
    LET             shift and go to state 35
    CASE            shift and go to state 31

    blockexpr                      shift and go to state 40
    letexpr                        shift and go to state 38
    actualargs                     shift and go to state 130
    caseexpr                       shift and go to state 45
    localmethodinvoke              shift and go to state 28
    ifthenelse                     shift and go to state 29
    assignment                     shift and go to state 46
    whileloop                      shift and go to state 32
    empty                          shift and go to state 84
    expr                           shift and go to state 83
    methodinvoke                   shift and go to state 48

state 127

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr . }
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    }               shift and go to state 131
    +               shift and go to state 75
    -               shift and go to state 73
    *               shift and go to state 71
    /               shift and go to state 69
    <               shift and go to state 72
    LE              shift and go to state 70
    =               shift and go to state 68
    DOT             shift and go to state 74
    @               shift and go to state 76


state 128

    (50) ifthenelse -> IF expr THEN expr ELSE expr FI .

    +               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    -               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    *               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    /               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    <               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    LE              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    =               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    DOT             reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    @               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    ;               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    ,               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    IN              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    THEN            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    OF              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    )               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    LOOP            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    ELSE            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    POOL            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    FI              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    }               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)


state 129

    (58) casestatements -> variabledeclaration DARROW expr ; . casestatements
    (59) casestatements -> variabledeclaration DARROW expr ; .
    (58) casestatements -> . variabledeclaration DARROW expr ; casestatements
    (59) casestatements -> . variabledeclaration DARROW expr ;
    (12) variabledeclaration -> . OBJECTID : TYPEID

    ESAC            reduce using rule 59 (casestatements -> variabledeclaration DARROW expr ; .)
    OBJECTID        shift and go to state 53

    variabledeclaration            shift and go to state 104
    casestatements                 shift and go to state 132

state 130

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs . )

    )               shift and go to state 133


state 131

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr } .

    ;               reduce using rule 10 (methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr } .)


state 132

    (58) casestatements -> variabledeclaration DARROW expr ; casestatements .

    ESAC            reduce using rule 58 (casestatements -> variabledeclaration DARROW expr ; casestatements .)


state 133

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .

    )               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    +               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    -               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    *               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    /               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    <               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    LE              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    =               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    DOT             reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    @               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    ,               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    ;               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    POOL            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    }               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    IN              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    THEN            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    OF              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    LOOP            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    ELSE            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    FI              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)

