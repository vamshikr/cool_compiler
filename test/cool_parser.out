Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT_SINGLELINE
    NEWLINE
    COMMENT_MULTILINE

Grammar

Rule 0     S' -> program
Rule 1     program -> class ; program
Rule 2     program -> class ;
Rule 3     class -> CLASS TYPEID baseclass { features }
Rule 4     baseclass -> INHERITS TYPEID
Rule 5     baseclass -> empty
Rule 6     features -> feature ; features
Rule 7     features -> empty
Rule 8     feature -> variabledefinition
Rule 9     feature -> methoddefinition
Rule 10    methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr }
Rule 11    variabledefinition -> variabledeclaration variableinitialization
Rule 12    variabledeclaration -> OBJECTID : TYPEID
Rule 13    variableinitialization -> ASSIGN expr
Rule 14    variableinitialization -> empty
Rule 15    formalargs -> variabledeclaration , formalargs
Rule 16    formalargs -> variabledeclaration
Rule 17    formalargs -> empty
Rule 18    actualargs -> expr , actualargs
Rule 19    actualargs -> expr
Rule 20    actualargs -> empty
Rule 21    expr -> assignment
Rule 22    expr -> methodinvoke
Rule 23    expr -> localmethodinvoke
Rule 24    expr -> ifthenelse
Rule 25    expr -> whileloop
Rule 26    expr -> blockexpr
Rule 27    expr -> letexpr
Rule 28    expr -> caseexpr
Rule 29    expr -> NEW TYPEID
Rule 30    expr -> ISVOID expr
Rule 31    expr -> NOT expr
Rule 32    expr -> ~ expr
Rule 33    expr -> ( expr )
Rule 34    expr -> expr + expr
Rule 35    expr -> expr - expr
Rule 36    expr -> expr * expr
Rule 37    expr -> expr / expr
Rule 38    expr -> expr < expr
Rule 39    expr -> expr LE expr
Rule 40    expr -> expr = expr
Rule 41    expr -> INT_CONST
Rule 42    expr -> STR_CONST
Rule 43    expr -> BOOL_CONST
Rule 44    expr -> OBJECTID
Rule 45    assignment -> OBJECTID ASSIGN expr
Rule 46    letexpr -> LET variablelist IN expr
Rule 47    methodinvoke -> expr DOT OBJECTID ( actualargs )
Rule 48    methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs )
Rule 49    localmethodinvoke -> OBJECTID ( actualargs )
Rule 50    ifthenelse -> IF expr THEN expr ELSE expr FI
Rule 51    whileloop -> WHILE expr LOOP expr POOL
Rule 52    blockexpr -> { blockstatements }
Rule 53    blockstatements -> expr ; blockstatements
Rule 54    blockstatements -> expr ;
Rule 55    variablelist -> variabledefinition , variablelist
Rule 56    variablelist -> variabledefinition
Rule 57    caseexpr -> CASE expr OF casestatements ESAC
Rule 58    casestatements -> variabledeclaration DARROW expr ; casestatements
Rule 59    casestatements -> variabledeclaration DARROW expr ;
Rule 60    empty -> <empty>

Terminals, with rules where they appear

(                    : 10 33 47 48 49
)                    : 10 33 47 48 49
*                    : 36
+                    : 34
,                    : 15 18 55
-                    : 35
/                    : 37
:                    : 10 12
;                    : 1 2 6 53 54 58 59
<                    : 38
=                    : 40
@                    : 48
ASSIGN               : 13 45
BOOL_CONST           : 43
CASE                 : 57
CLASS                : 3
COMMENT_MULTILINE    : 
COMMENT_SINGLELINE   : 
DARROW               : 58 59
DOT                  : 47 48
ELSE                 : 50
ESAC                 : 57
FI                   : 50
IF                   : 50
IN                   : 46
INHERITS             : 4
INT_CONST            : 41
ISVOID               : 30
LE                   : 39
LET                  : 46
LOOP                 : 51
NEW                  : 29
NEWLINE              : 
NOT                  : 31
OBJECTID             : 10 12 44 45 47 48 49
OF                   : 57
POOL                 : 51
STR_CONST            : 42
THEN                 : 50
TYPEID               : 3 4 10 12 29 48
WHILE                : 51
error                : 
{                    : 3 10 52
}                    : 3 10 52
~                    : 32

Nonterminals, with rules where they appear

actualargs           : 18 47 48 49
assignment           : 21
baseclass            : 3
blockexpr            : 26
blockstatements      : 52 53
caseexpr             : 28
casestatements       : 57 58
class                : 1 2
empty                : 5 7 14 17 20
expr                 : 10 13 18 19 30 31 32 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 45 46 47 48 50 50 50 51 51 53 54 57 58 59
feature              : 6
features             : 3 6
formalargs           : 10 15
ifthenelse           : 24
letexpr              : 27
localmethodinvoke    : 23
methoddefinition     : 9
methodinvoke         : 22
program              : 1 0
variabledeclaration  : 11 15 16 58 59
variabledefinition   : 8 55 56
variableinitialization : 11
variablelist         : 46 55
whileloop            : 25

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class ; program
    (2) program -> . class ;
    (3) class -> . CLASS TYPEID baseclass { features }

    CLASS           shift and go to state 3

    class                          shift and go to state 2
    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> class . ; program
    (2) program -> class . ;

    ;               shift and go to state 4


state 3

    (3) class -> CLASS . TYPEID baseclass { features }

    TYPEID          shift and go to state 5


state 4

    (1) program -> class ; . program
    (2) program -> class ; .
    (1) program -> . class ; program
    (2) program -> . class ;
    (3) class -> . CLASS TYPEID baseclass { features }

    $end            reduce using rule 2 (program -> class ; .)
    CLASS           shift and go to state 3

    class                          shift and go to state 2
    program                        shift and go to state 6

state 5

    (3) class -> CLASS TYPEID . baseclass { features }
    (4) baseclass -> . INHERITS TYPEID
    (5) baseclass -> . empty
    (60) empty -> .

    INHERITS        shift and go to state 7
    {               reduce using rule 60 (empty -> .)

    baseclass                      shift and go to state 8
    empty                          shift and go to state 9

state 6

    (1) program -> class ; program .

    $end            reduce using rule 1 (program -> class ; program .)


state 7

    (4) baseclass -> INHERITS . TYPEID

    TYPEID          shift and go to state 10


state 8

    (3) class -> CLASS TYPEID baseclass . { features }

    {               shift and go to state 11


state 9

    (5) baseclass -> empty .

    {               reduce using rule 5 (baseclass -> empty .)


state 10

    (4) baseclass -> INHERITS TYPEID .

    {               reduce using rule 4 (baseclass -> INHERITS TYPEID .)


state 11

    (3) class -> CLASS TYPEID baseclass { . features }
    (6) features -> . feature ; features
    (7) features -> . empty
    (8) feature -> . variabledefinition
    (9) feature -> . methoddefinition
    (60) empty -> .
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (10) methoddefinition -> . OBJECTID ( formalargs ) : TYPEID { expr }
    (12) variabledeclaration -> . OBJECTID : TYPEID

    }               reduce using rule 60 (empty -> .)
    OBJECTID        shift and go to state 17

    methoddefinition               shift and go to state 12
    feature                        shift and go to state 13
    empty                          shift and go to state 14
    features                       shift and go to state 16
    variabledefinition             shift and go to state 15
    variabledeclaration            shift and go to state 18

state 12

    (9) feature -> methoddefinition .

    ;               reduce using rule 9 (feature -> methoddefinition .)


state 13

    (6) features -> feature . ; features

    ;               shift and go to state 19


state 14

    (7) features -> empty .

    }               reduce using rule 7 (features -> empty .)


state 15

    (8) feature -> variabledefinition .

    ;               reduce using rule 8 (feature -> variabledefinition .)


state 16

    (3) class -> CLASS TYPEID baseclass { features . }

    }               shift and go to state 20


state 17

    (10) methoddefinition -> OBJECTID . ( formalargs ) : TYPEID { expr }
    (12) variabledeclaration -> OBJECTID . : TYPEID

    (               shift and go to state 21
    :               shift and go to state 22


state 18

    (11) variabledefinition -> variabledeclaration . variableinitialization
    (13) variableinitialization -> . ASSIGN expr
    (14) variableinitialization -> . empty
    (60) empty -> .

    ASSIGN          shift and go to state 24
    ;               reduce using rule 60 (empty -> .)
    ,               reduce using rule 60 (empty -> .)
    IN              reduce using rule 60 (empty -> .)

    variableinitialization         shift and go to state 23
    empty                          shift and go to state 25

state 19

    (6) features -> feature ; . features
    (6) features -> . feature ; features
    (7) features -> . empty
    (8) feature -> . variabledefinition
    (9) feature -> . methoddefinition
    (60) empty -> .
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (10) methoddefinition -> . OBJECTID ( formalargs ) : TYPEID { expr }
    (12) variabledeclaration -> . OBJECTID : TYPEID

    }               reduce using rule 60 (empty -> .)
    OBJECTID        shift and go to state 17

    methoddefinition               shift and go to state 12
    features                       shift and go to state 26
    empty                          shift and go to state 14
    variabledefinition             shift and go to state 15
    feature                        shift and go to state 13
    variabledeclaration            shift and go to state 18

state 20

    (3) class -> CLASS TYPEID baseclass { features } .

    ;               reduce using rule 3 (class -> CLASS TYPEID baseclass { features } .)


state 21

    (10) methoddefinition -> OBJECTID ( . formalargs ) : TYPEID { expr }
    (15) formalargs -> . variabledeclaration , formalargs
    (16) formalargs -> . variabledeclaration
    (17) formalargs -> . empty
    (12) variabledeclaration -> . OBJECTID : TYPEID
    (60) empty -> .

    OBJECTID        shift and go to state 29
    )               reduce using rule 60 (empty -> .)

    variabledeclaration            shift and go to state 30
    formalargs                     shift and go to state 28
    empty                          shift and go to state 27

state 22

    (12) variabledeclaration -> OBJECTID : . TYPEID

    TYPEID          shift and go to state 31


state 23

    (11) variabledefinition -> variabledeclaration variableinitialization .

    ;               reduce using rule 11 (variabledefinition -> variabledeclaration variableinitialization .)
    ,               reduce using rule 11 (variabledefinition -> variabledeclaration variableinitialization .)
    IN              reduce using rule 11 (variabledefinition -> variabledeclaration variableinitialization .)


state 24

    (13) variableinitialization -> ASSIGN . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 32
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    methodinvoke                   shift and go to state 52

state 25

    (14) variableinitialization -> empty .

    ;               reduce using rule 14 (variableinitialization -> empty .)
    ,               reduce using rule 14 (variableinitialization -> empty .)
    IN              reduce using rule 14 (variableinitialization -> empty .)


state 26

    (6) features -> feature ; features .

    }               reduce using rule 6 (features -> feature ; features .)


state 27

    (17) formalargs -> empty .

    )               reduce using rule 17 (formalargs -> empty .)


state 28

    (10) methoddefinition -> OBJECTID ( formalargs . ) : TYPEID { expr }

    )               shift and go to state 55


state 29

    (12) variabledeclaration -> OBJECTID . : TYPEID

    :               shift and go to state 22


state 30

    (15) formalargs -> variabledeclaration . , formalargs
    (16) formalargs -> variabledeclaration .

    ,               shift and go to state 56
    )               reduce using rule 16 (formalargs -> variabledeclaration .)


state 31

    (12) variabledeclaration -> OBJECTID : TYPEID .

    ASSIGN          reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    ,               reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    IN              reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    ;               reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    DARROW          reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    )               reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)


state 32

    (13) variableinitialization -> ASSIGN expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               reduce using rule 13 (variableinitialization -> ASSIGN expr .)
    ,               reduce using rule 13 (variableinitialization -> ASSIGN expr .)
    IN              reduce using rule 13 (variableinitialization -> ASSIGN expr .)
    +               shift and go to state 61
    -               shift and go to state 62
    *               shift and go to state 65
    /               shift and go to state 63
    <               shift and go to state 59
    LE              shift and go to state 60
    =               shift and go to state 64
    DOT             shift and go to state 57
    @               shift and go to state 58


state 33

    (33) expr -> ( . expr )
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 66
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    methodinvoke                   shift and go to state 52

state 34

    (30) expr -> ISVOID . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 67
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    methodinvoke                   shift and go to state 52

state 35

    (28) expr -> caseexpr .

    OF              reduce using rule 28 (expr -> caseexpr .)
    +               reduce using rule 28 (expr -> caseexpr .)
    -               reduce using rule 28 (expr -> caseexpr .)
    *               reduce using rule 28 (expr -> caseexpr .)
    /               reduce using rule 28 (expr -> caseexpr .)
    <               reduce using rule 28 (expr -> caseexpr .)
    LE              reduce using rule 28 (expr -> caseexpr .)
    =               reduce using rule 28 (expr -> caseexpr .)
    DOT             reduce using rule 28 (expr -> caseexpr .)
    @               reduce using rule 28 (expr -> caseexpr .)
    ;               reduce using rule 28 (expr -> caseexpr .)
    )               reduce using rule 28 (expr -> caseexpr .)
    ,               reduce using rule 28 (expr -> caseexpr .)
    IN              reduce using rule 28 (expr -> caseexpr .)
    THEN            reduce using rule 28 (expr -> caseexpr .)
    LOOP            reduce using rule 28 (expr -> caseexpr .)
    ELSE            reduce using rule 28 (expr -> caseexpr .)
    POOL            reduce using rule 28 (expr -> caseexpr .)
    }               reduce using rule 28 (expr -> caseexpr .)
    FI              reduce using rule 28 (expr -> caseexpr .)


state 36

    (50) ifthenelse -> IF . expr THEN expr ELSE expr FI
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 68
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    methodinvoke                   shift and go to state 52

state 37

    (43) expr -> BOOL_CONST .

    OF              reduce using rule 43 (expr -> BOOL_CONST .)
    +               reduce using rule 43 (expr -> BOOL_CONST .)
    -               reduce using rule 43 (expr -> BOOL_CONST .)
    *               reduce using rule 43 (expr -> BOOL_CONST .)
    /               reduce using rule 43 (expr -> BOOL_CONST .)
    <               reduce using rule 43 (expr -> BOOL_CONST .)
    LE              reduce using rule 43 (expr -> BOOL_CONST .)
    =               reduce using rule 43 (expr -> BOOL_CONST .)
    DOT             reduce using rule 43 (expr -> BOOL_CONST .)
    @               reduce using rule 43 (expr -> BOOL_CONST .)
    ;               reduce using rule 43 (expr -> BOOL_CONST .)
    )               reduce using rule 43 (expr -> BOOL_CONST .)
    ,               reduce using rule 43 (expr -> BOOL_CONST .)
    IN              reduce using rule 43 (expr -> BOOL_CONST .)
    THEN            reduce using rule 43 (expr -> BOOL_CONST .)
    LOOP            reduce using rule 43 (expr -> BOOL_CONST .)
    ELSE            reduce using rule 43 (expr -> BOOL_CONST .)
    POOL            reduce using rule 43 (expr -> BOOL_CONST .)
    }               reduce using rule 43 (expr -> BOOL_CONST .)
    FI              reduce using rule 43 (expr -> BOOL_CONST .)


state 38

    (46) letexpr -> LET . variablelist IN expr
    (55) variablelist -> . variabledefinition , variablelist
    (56) variablelist -> . variabledefinition
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (12) variabledeclaration -> . OBJECTID : TYPEID

    OBJECTID        shift and go to state 29

    variablelist                   shift and go to state 70
    variabledefinition             shift and go to state 69
    variabledeclaration            shift and go to state 18

state 39

    (32) expr -> ~ . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 71
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    methodinvoke                   shift and go to state 52

state 40

    (27) expr -> letexpr .

    OF              reduce using rule 27 (expr -> letexpr .)
    +               reduce using rule 27 (expr -> letexpr .)
    -               reduce using rule 27 (expr -> letexpr .)
    *               reduce using rule 27 (expr -> letexpr .)
    /               reduce using rule 27 (expr -> letexpr .)
    <               reduce using rule 27 (expr -> letexpr .)
    LE              reduce using rule 27 (expr -> letexpr .)
    =               reduce using rule 27 (expr -> letexpr .)
    DOT             reduce using rule 27 (expr -> letexpr .)
    @               reduce using rule 27 (expr -> letexpr .)
    ;               reduce using rule 27 (expr -> letexpr .)
    )               reduce using rule 27 (expr -> letexpr .)
    ,               reduce using rule 27 (expr -> letexpr .)
    IN              reduce using rule 27 (expr -> letexpr .)
    THEN            reduce using rule 27 (expr -> letexpr .)
    LOOP            reduce using rule 27 (expr -> letexpr .)
    ELSE            reduce using rule 27 (expr -> letexpr .)
    POOL            reduce using rule 27 (expr -> letexpr .)
    }               reduce using rule 27 (expr -> letexpr .)
    FI              reduce using rule 27 (expr -> letexpr .)


state 41

    (51) whileloop -> WHILE . expr LOOP expr POOL
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 72
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    methodinvoke                   shift and go to state 52

state 42

    (41) expr -> INT_CONST .

    OF              reduce using rule 41 (expr -> INT_CONST .)
    +               reduce using rule 41 (expr -> INT_CONST .)
    -               reduce using rule 41 (expr -> INT_CONST .)
    *               reduce using rule 41 (expr -> INT_CONST .)
    /               reduce using rule 41 (expr -> INT_CONST .)
    <               reduce using rule 41 (expr -> INT_CONST .)
    LE              reduce using rule 41 (expr -> INT_CONST .)
    =               reduce using rule 41 (expr -> INT_CONST .)
    DOT             reduce using rule 41 (expr -> INT_CONST .)
    @               reduce using rule 41 (expr -> INT_CONST .)
    ;               reduce using rule 41 (expr -> INT_CONST .)
    )               reduce using rule 41 (expr -> INT_CONST .)
    ,               reduce using rule 41 (expr -> INT_CONST .)
    IN              reduce using rule 41 (expr -> INT_CONST .)
    THEN            reduce using rule 41 (expr -> INT_CONST .)
    LOOP            reduce using rule 41 (expr -> INT_CONST .)
    ELSE            reduce using rule 41 (expr -> INT_CONST .)
    POOL            reduce using rule 41 (expr -> INT_CONST .)
    }               reduce using rule 41 (expr -> INT_CONST .)
    FI              reduce using rule 41 (expr -> INT_CONST .)


state 43

    (24) expr -> ifthenelse .

    OF              reduce using rule 24 (expr -> ifthenelse .)
    +               reduce using rule 24 (expr -> ifthenelse .)
    -               reduce using rule 24 (expr -> ifthenelse .)
    *               reduce using rule 24 (expr -> ifthenelse .)
    /               reduce using rule 24 (expr -> ifthenelse .)
    <               reduce using rule 24 (expr -> ifthenelse .)
    LE              reduce using rule 24 (expr -> ifthenelse .)
    =               reduce using rule 24 (expr -> ifthenelse .)
    DOT             reduce using rule 24 (expr -> ifthenelse .)
    @               reduce using rule 24 (expr -> ifthenelse .)
    ;               reduce using rule 24 (expr -> ifthenelse .)
    )               reduce using rule 24 (expr -> ifthenelse .)
    ,               reduce using rule 24 (expr -> ifthenelse .)
    IN              reduce using rule 24 (expr -> ifthenelse .)
    THEN            reduce using rule 24 (expr -> ifthenelse .)
    LOOP            reduce using rule 24 (expr -> ifthenelse .)
    ELSE            reduce using rule 24 (expr -> ifthenelse .)
    POOL            reduce using rule 24 (expr -> ifthenelse .)
    }               reduce using rule 24 (expr -> ifthenelse .)
    FI              reduce using rule 24 (expr -> ifthenelse .)


state 44

    (23) expr -> localmethodinvoke .

    OF              reduce using rule 23 (expr -> localmethodinvoke .)
    +               reduce using rule 23 (expr -> localmethodinvoke .)
    -               reduce using rule 23 (expr -> localmethodinvoke .)
    *               reduce using rule 23 (expr -> localmethodinvoke .)
    /               reduce using rule 23 (expr -> localmethodinvoke .)
    <               reduce using rule 23 (expr -> localmethodinvoke .)
    LE              reduce using rule 23 (expr -> localmethodinvoke .)
    =               reduce using rule 23 (expr -> localmethodinvoke .)
    DOT             reduce using rule 23 (expr -> localmethodinvoke .)
    @               reduce using rule 23 (expr -> localmethodinvoke .)
    ;               reduce using rule 23 (expr -> localmethodinvoke .)
    )               reduce using rule 23 (expr -> localmethodinvoke .)
    ,               reduce using rule 23 (expr -> localmethodinvoke .)
    IN              reduce using rule 23 (expr -> localmethodinvoke .)
    THEN            reduce using rule 23 (expr -> localmethodinvoke .)
    LOOP            reduce using rule 23 (expr -> localmethodinvoke .)
    ELSE            reduce using rule 23 (expr -> localmethodinvoke .)
    POOL            reduce using rule 23 (expr -> localmethodinvoke .)
    }               reduce using rule 23 (expr -> localmethodinvoke .)
    FI              reduce using rule 23 (expr -> localmethodinvoke .)


state 45

    (57) caseexpr -> CASE . expr OF casestatements ESAC
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 73
    methodinvoke                   shift and go to state 52
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35

state 46

    (21) expr -> assignment .

    OF              reduce using rule 21 (expr -> assignment .)
    +               reduce using rule 21 (expr -> assignment .)
    -               reduce using rule 21 (expr -> assignment .)
    *               reduce using rule 21 (expr -> assignment .)
    /               reduce using rule 21 (expr -> assignment .)
    <               reduce using rule 21 (expr -> assignment .)
    LE              reduce using rule 21 (expr -> assignment .)
    =               reduce using rule 21 (expr -> assignment .)
    DOT             reduce using rule 21 (expr -> assignment .)
    @               reduce using rule 21 (expr -> assignment .)
    ;               reduce using rule 21 (expr -> assignment .)
    )               reduce using rule 21 (expr -> assignment .)
    ,               reduce using rule 21 (expr -> assignment .)
    IN              reduce using rule 21 (expr -> assignment .)
    THEN            reduce using rule 21 (expr -> assignment .)
    LOOP            reduce using rule 21 (expr -> assignment .)
    ELSE            reduce using rule 21 (expr -> assignment .)
    POOL            reduce using rule 21 (expr -> assignment .)
    }               reduce using rule 21 (expr -> assignment .)
    FI              reduce using rule 21 (expr -> assignment .)


state 47

    (31) expr -> NOT . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 74
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    methodinvoke                   shift and go to state 52

state 48

    (29) expr -> NEW . TYPEID

    TYPEID          shift and go to state 75


state 49

    (42) expr -> STR_CONST .

    OF              reduce using rule 42 (expr -> STR_CONST .)
    +               reduce using rule 42 (expr -> STR_CONST .)
    -               reduce using rule 42 (expr -> STR_CONST .)
    *               reduce using rule 42 (expr -> STR_CONST .)
    /               reduce using rule 42 (expr -> STR_CONST .)
    <               reduce using rule 42 (expr -> STR_CONST .)
    LE              reduce using rule 42 (expr -> STR_CONST .)
    =               reduce using rule 42 (expr -> STR_CONST .)
    DOT             reduce using rule 42 (expr -> STR_CONST .)
    @               reduce using rule 42 (expr -> STR_CONST .)
    ;               reduce using rule 42 (expr -> STR_CONST .)
    )               reduce using rule 42 (expr -> STR_CONST .)
    ,               reduce using rule 42 (expr -> STR_CONST .)
    IN              reduce using rule 42 (expr -> STR_CONST .)
    THEN            reduce using rule 42 (expr -> STR_CONST .)
    LOOP            reduce using rule 42 (expr -> STR_CONST .)
    ELSE            reduce using rule 42 (expr -> STR_CONST .)
    POOL            reduce using rule 42 (expr -> STR_CONST .)
    }               reduce using rule 42 (expr -> STR_CONST .)
    FI              reduce using rule 42 (expr -> STR_CONST .)


state 50

    (44) expr -> OBJECTID .
    (45) assignment -> OBJECTID . ASSIGN expr
    (49) localmethodinvoke -> OBJECTID . ( actualargs )

    OF              reduce using rule 44 (expr -> OBJECTID .)
    +               reduce using rule 44 (expr -> OBJECTID .)
    -               reduce using rule 44 (expr -> OBJECTID .)
    *               reduce using rule 44 (expr -> OBJECTID .)
    /               reduce using rule 44 (expr -> OBJECTID .)
    <               reduce using rule 44 (expr -> OBJECTID .)
    LE              reduce using rule 44 (expr -> OBJECTID .)
    =               reduce using rule 44 (expr -> OBJECTID .)
    DOT             reduce using rule 44 (expr -> OBJECTID .)
    @               reduce using rule 44 (expr -> OBJECTID .)
    ;               reduce using rule 44 (expr -> OBJECTID .)
    )               reduce using rule 44 (expr -> OBJECTID .)
    ,               reduce using rule 44 (expr -> OBJECTID .)
    IN              reduce using rule 44 (expr -> OBJECTID .)
    THEN            reduce using rule 44 (expr -> OBJECTID .)
    LOOP            reduce using rule 44 (expr -> OBJECTID .)
    ELSE            reduce using rule 44 (expr -> OBJECTID .)
    POOL            reduce using rule 44 (expr -> OBJECTID .)
    }               reduce using rule 44 (expr -> OBJECTID .)
    FI              reduce using rule 44 (expr -> OBJECTID .)
    ASSIGN          shift and go to state 76
    (               shift and go to state 77


state 51

    (26) expr -> blockexpr .

    OF              reduce using rule 26 (expr -> blockexpr .)
    +               reduce using rule 26 (expr -> blockexpr .)
    -               reduce using rule 26 (expr -> blockexpr .)
    *               reduce using rule 26 (expr -> blockexpr .)
    /               reduce using rule 26 (expr -> blockexpr .)
    <               reduce using rule 26 (expr -> blockexpr .)
    LE              reduce using rule 26 (expr -> blockexpr .)
    =               reduce using rule 26 (expr -> blockexpr .)
    DOT             reduce using rule 26 (expr -> blockexpr .)
    @               reduce using rule 26 (expr -> blockexpr .)
    ;               reduce using rule 26 (expr -> blockexpr .)
    )               reduce using rule 26 (expr -> blockexpr .)
    ,               reduce using rule 26 (expr -> blockexpr .)
    IN              reduce using rule 26 (expr -> blockexpr .)
    THEN            reduce using rule 26 (expr -> blockexpr .)
    LOOP            reduce using rule 26 (expr -> blockexpr .)
    ELSE            reduce using rule 26 (expr -> blockexpr .)
    POOL            reduce using rule 26 (expr -> blockexpr .)
    }               reduce using rule 26 (expr -> blockexpr .)
    FI              reduce using rule 26 (expr -> blockexpr .)


state 52

    (22) expr -> methodinvoke .

    OF              reduce using rule 22 (expr -> methodinvoke .)
    +               reduce using rule 22 (expr -> methodinvoke .)
    -               reduce using rule 22 (expr -> methodinvoke .)
    *               reduce using rule 22 (expr -> methodinvoke .)
    /               reduce using rule 22 (expr -> methodinvoke .)
    <               reduce using rule 22 (expr -> methodinvoke .)
    LE              reduce using rule 22 (expr -> methodinvoke .)
    =               reduce using rule 22 (expr -> methodinvoke .)
    DOT             reduce using rule 22 (expr -> methodinvoke .)
    @               reduce using rule 22 (expr -> methodinvoke .)
    ;               reduce using rule 22 (expr -> methodinvoke .)
    )               reduce using rule 22 (expr -> methodinvoke .)
    ,               reduce using rule 22 (expr -> methodinvoke .)
    IN              reduce using rule 22 (expr -> methodinvoke .)
    THEN            reduce using rule 22 (expr -> methodinvoke .)
    LOOP            reduce using rule 22 (expr -> methodinvoke .)
    ELSE            reduce using rule 22 (expr -> methodinvoke .)
    POOL            reduce using rule 22 (expr -> methodinvoke .)
    }               reduce using rule 22 (expr -> methodinvoke .)
    FI              reduce using rule 22 (expr -> methodinvoke .)


state 53

    (25) expr -> whileloop .

    OF              reduce using rule 25 (expr -> whileloop .)
    +               reduce using rule 25 (expr -> whileloop .)
    -               reduce using rule 25 (expr -> whileloop .)
    *               reduce using rule 25 (expr -> whileloop .)
    /               reduce using rule 25 (expr -> whileloop .)
    <               reduce using rule 25 (expr -> whileloop .)
    LE              reduce using rule 25 (expr -> whileloop .)
    =               reduce using rule 25 (expr -> whileloop .)
    DOT             reduce using rule 25 (expr -> whileloop .)
    @               reduce using rule 25 (expr -> whileloop .)
    ;               reduce using rule 25 (expr -> whileloop .)
    )               reduce using rule 25 (expr -> whileloop .)
    ,               reduce using rule 25 (expr -> whileloop .)
    IN              reduce using rule 25 (expr -> whileloop .)
    THEN            reduce using rule 25 (expr -> whileloop .)
    LOOP            reduce using rule 25 (expr -> whileloop .)
    ELSE            reduce using rule 25 (expr -> whileloop .)
    POOL            reduce using rule 25 (expr -> whileloop .)
    }               reduce using rule 25 (expr -> whileloop .)
    FI              reduce using rule 25 (expr -> whileloop .)


state 54

    (52) blockexpr -> { . blockstatements }
    (53) blockstatements -> . expr ; blockstatements
    (54) blockstatements -> . expr ;
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    blockstatements                shift and go to state 79
    expr                           shift and go to state 78
    methodinvoke                   shift and go to state 52
    letexpr                        shift and go to state 40
    localmethodinvoke              shift and go to state 44
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    whileloop                      shift and go to state 53

state 55

    (10) methoddefinition -> OBJECTID ( formalargs ) . : TYPEID { expr }

    :               shift and go to state 80


state 56

    (15) formalargs -> variabledeclaration , . formalargs
    (15) formalargs -> . variabledeclaration , formalargs
    (16) formalargs -> . variabledeclaration
    (17) formalargs -> . empty
    (12) variabledeclaration -> . OBJECTID : TYPEID
    (60) empty -> .

    OBJECTID        shift and go to state 29
    )               reduce using rule 60 (empty -> .)

    formalargs                     shift and go to state 81
    variabledeclaration            shift and go to state 30
    empty                          shift and go to state 27

state 57

    (47) methodinvoke -> expr DOT . OBJECTID ( actualargs )

    OBJECTID        shift and go to state 82


state 58

    (48) methodinvoke -> expr @ . TYPEID DOT OBJECTID ( actualargs )

    TYPEID          shift and go to state 83


state 59

    (38) expr -> expr < . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 84
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    methodinvoke                   shift and go to state 52

state 60

    (39) expr -> expr LE . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 85
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    methodinvoke                   shift and go to state 52

state 61

    (34) expr -> expr + . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 86
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    methodinvoke                   shift and go to state 52

state 62

    (35) expr -> expr - . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 87
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    methodinvoke                   shift and go to state 52

state 63

    (37) expr -> expr / . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 88
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    methodinvoke                   shift and go to state 52

state 64

    (40) expr -> expr = . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 89
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    methodinvoke                   shift and go to state 52

state 65

    (36) expr -> expr * . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 90
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    methodinvoke                   shift and go to state 52

state 66

    (33) expr -> ( expr . )
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    )               shift and go to state 91
    +               shift and go to state 61
    -               shift and go to state 62
    *               shift and go to state 65
    /               shift and go to state 63
    <               shift and go to state 59
    LE              shift and go to state 60
    =               shift and go to state 64
    DOT             shift and go to state 57
    @               shift and go to state 58


state 67

    (30) expr -> ISVOID expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    OF              reduce using rule 30 (expr -> ISVOID expr .)
    +               reduce using rule 30 (expr -> ISVOID expr .)
    -               reduce using rule 30 (expr -> ISVOID expr .)
    *               reduce using rule 30 (expr -> ISVOID expr .)
    /               reduce using rule 30 (expr -> ISVOID expr .)
    <               reduce using rule 30 (expr -> ISVOID expr .)
    LE              reduce using rule 30 (expr -> ISVOID expr .)
    =               reduce using rule 30 (expr -> ISVOID expr .)
    ;               reduce using rule 30 (expr -> ISVOID expr .)
    )               reduce using rule 30 (expr -> ISVOID expr .)
    ,               reduce using rule 30 (expr -> ISVOID expr .)
    IN              reduce using rule 30 (expr -> ISVOID expr .)
    THEN            reduce using rule 30 (expr -> ISVOID expr .)
    LOOP            reduce using rule 30 (expr -> ISVOID expr .)
    ELSE            reduce using rule 30 (expr -> ISVOID expr .)
    POOL            reduce using rule 30 (expr -> ISVOID expr .)
    }               reduce using rule 30 (expr -> ISVOID expr .)
    FI              reduce using rule 30 (expr -> ISVOID expr .)
    DOT             shift and go to state 57
    @               shift and go to state 58

  ! DOT             [ reduce using rule 30 (expr -> ISVOID expr .) ]
  ! @               [ reduce using rule 30 (expr -> ISVOID expr .) ]
  ! +               [ shift and go to state 61 ]
  ! -               [ shift and go to state 62 ]
  ! *               [ shift and go to state 65 ]
  ! /               [ shift and go to state 63 ]
  ! <               [ shift and go to state 59 ]
  ! LE              [ shift and go to state 60 ]
  ! =               [ shift and go to state 64 ]


state 68

    (50) ifthenelse -> IF expr . THEN expr ELSE expr FI
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    THEN            shift and go to state 92
    +               shift and go to state 61
    -               shift and go to state 62
    *               shift and go to state 65
    /               shift and go to state 63
    <               shift and go to state 59
    LE              shift and go to state 60
    =               shift and go to state 64
    DOT             shift and go to state 57
    @               shift and go to state 58


state 69

    (55) variablelist -> variabledefinition . , variablelist
    (56) variablelist -> variabledefinition .

    ,               shift and go to state 93
    IN              reduce using rule 56 (variablelist -> variabledefinition .)


state 70

    (46) letexpr -> LET variablelist . IN expr

    IN              shift and go to state 94


state 71

    (32) expr -> ~ expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    OF              reduce using rule 32 (expr -> ~ expr .)
    +               reduce using rule 32 (expr -> ~ expr .)
    -               reduce using rule 32 (expr -> ~ expr .)
    *               reduce using rule 32 (expr -> ~ expr .)
    /               reduce using rule 32 (expr -> ~ expr .)
    <               reduce using rule 32 (expr -> ~ expr .)
    LE              reduce using rule 32 (expr -> ~ expr .)
    =               reduce using rule 32 (expr -> ~ expr .)
    ;               reduce using rule 32 (expr -> ~ expr .)
    )               reduce using rule 32 (expr -> ~ expr .)
    ,               reduce using rule 32 (expr -> ~ expr .)
    IN              reduce using rule 32 (expr -> ~ expr .)
    THEN            reduce using rule 32 (expr -> ~ expr .)
    LOOP            reduce using rule 32 (expr -> ~ expr .)
    ELSE            reduce using rule 32 (expr -> ~ expr .)
    POOL            reduce using rule 32 (expr -> ~ expr .)
    }               reduce using rule 32 (expr -> ~ expr .)
    FI              reduce using rule 32 (expr -> ~ expr .)
    DOT             shift and go to state 57
    @               shift and go to state 58

  ! DOT             [ reduce using rule 32 (expr -> ~ expr .) ]
  ! @               [ reduce using rule 32 (expr -> ~ expr .) ]
  ! +               [ shift and go to state 61 ]
  ! -               [ shift and go to state 62 ]
  ! *               [ shift and go to state 65 ]
  ! /               [ shift and go to state 63 ]
  ! <               [ shift and go to state 59 ]
  ! LE              [ shift and go to state 60 ]
  ! =               [ shift and go to state 64 ]


state 72

    (51) whileloop -> WHILE expr . LOOP expr POOL
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    LOOP            shift and go to state 95
    +               shift and go to state 61
    -               shift and go to state 62
    *               shift and go to state 65
    /               shift and go to state 63
    <               shift and go to state 59
    LE              shift and go to state 60
    =               shift and go to state 64
    DOT             shift and go to state 57
    @               shift and go to state 58


state 73

    (57) caseexpr -> CASE expr . OF casestatements ESAC
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    OF              shift and go to state 96
    +               shift and go to state 61
    -               shift and go to state 62
    *               shift and go to state 65
    /               shift and go to state 63
    <               shift and go to state 59
    LE              shift and go to state 60
    =               shift and go to state 64
    DOT             shift and go to state 57
    @               shift and go to state 58


state 74

    (31) expr -> NOT expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    OF              reduce using rule 31 (expr -> NOT expr .)
    ;               reduce using rule 31 (expr -> NOT expr .)
    )               reduce using rule 31 (expr -> NOT expr .)
    ,               reduce using rule 31 (expr -> NOT expr .)
    IN              reduce using rule 31 (expr -> NOT expr .)
    THEN            reduce using rule 31 (expr -> NOT expr .)
    LOOP            reduce using rule 31 (expr -> NOT expr .)
    ELSE            reduce using rule 31 (expr -> NOT expr .)
    POOL            reduce using rule 31 (expr -> NOT expr .)
    }               reduce using rule 31 (expr -> NOT expr .)
    FI              reduce using rule 31 (expr -> NOT expr .)
    +               shift and go to state 61
    -               shift and go to state 62
    *               shift and go to state 65
    /               shift and go to state 63
    <               shift and go to state 59
    LE              shift and go to state 60
    =               shift and go to state 64
    DOT             shift and go to state 57
    @               shift and go to state 58

  ! +               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! -               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! *               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! /               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! <               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! LE              [ reduce using rule 31 (expr -> NOT expr .) ]
  ! =               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! DOT             [ reduce using rule 31 (expr -> NOT expr .) ]
  ! @               [ reduce using rule 31 (expr -> NOT expr .) ]


state 75

    (29) expr -> NEW TYPEID .

    OF              reduce using rule 29 (expr -> NEW TYPEID .)
    +               reduce using rule 29 (expr -> NEW TYPEID .)
    -               reduce using rule 29 (expr -> NEW TYPEID .)
    *               reduce using rule 29 (expr -> NEW TYPEID .)
    /               reduce using rule 29 (expr -> NEW TYPEID .)
    <               reduce using rule 29 (expr -> NEW TYPEID .)
    LE              reduce using rule 29 (expr -> NEW TYPEID .)
    =               reduce using rule 29 (expr -> NEW TYPEID .)
    DOT             reduce using rule 29 (expr -> NEW TYPEID .)
    @               reduce using rule 29 (expr -> NEW TYPEID .)
    ;               reduce using rule 29 (expr -> NEW TYPEID .)
    )               reduce using rule 29 (expr -> NEW TYPEID .)
    ,               reduce using rule 29 (expr -> NEW TYPEID .)
    IN              reduce using rule 29 (expr -> NEW TYPEID .)
    THEN            reduce using rule 29 (expr -> NEW TYPEID .)
    LOOP            reduce using rule 29 (expr -> NEW TYPEID .)
    ELSE            reduce using rule 29 (expr -> NEW TYPEID .)
    POOL            reduce using rule 29 (expr -> NEW TYPEID .)
    }               reduce using rule 29 (expr -> NEW TYPEID .)
    FI              reduce using rule 29 (expr -> NEW TYPEID .)


state 76

    (45) assignment -> OBJECTID ASSIGN . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 97
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    methodinvoke                   shift and go to state 52

state 77

    (49) localmethodinvoke -> OBJECTID ( . actualargs )
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    empty                          shift and go to state 99
    expr                           shift and go to state 98
    methodinvoke                   shift and go to state 52
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    actualargs                     shift and go to state 100

state 78

    (53) blockstatements -> expr . ; blockstatements
    (54) blockstatements -> expr . ;
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               shift and go to state 101
    +               shift and go to state 61
    -               shift and go to state 62
    *               shift and go to state 65
    /               shift and go to state 63
    <               shift and go to state 59
    LE              shift and go to state 60
    =               shift and go to state 64
    DOT             shift and go to state 57
    @               shift and go to state 58


state 79

    (52) blockexpr -> { blockstatements . }

    }               shift and go to state 102


state 80

    (10) methoddefinition -> OBJECTID ( formalargs ) : . TYPEID { expr }

    TYPEID          shift and go to state 103


state 81

    (15) formalargs -> variabledeclaration , formalargs .

    )               reduce using rule 15 (formalargs -> variabledeclaration , formalargs .)


state 82

    (47) methodinvoke -> expr DOT OBJECTID . ( actualargs )

    (               shift and go to state 104


state 83

    (48) methodinvoke -> expr @ TYPEID . DOT OBJECTID ( actualargs )

    DOT             shift and go to state 105


state 84

    (38) expr -> expr < expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    OF              reduce using rule 38 (expr -> expr < expr .)
    <               reduce using rule 38 (expr -> expr < expr .)
    LE              reduce using rule 38 (expr -> expr < expr .)
    =               reduce using rule 38 (expr -> expr < expr .)
    ;               reduce using rule 38 (expr -> expr < expr .)
    )               reduce using rule 38 (expr -> expr < expr .)
    ,               reduce using rule 38 (expr -> expr < expr .)
    IN              reduce using rule 38 (expr -> expr < expr .)
    THEN            reduce using rule 38 (expr -> expr < expr .)
    LOOP            reduce using rule 38 (expr -> expr < expr .)
    ELSE            reduce using rule 38 (expr -> expr < expr .)
    POOL            reduce using rule 38 (expr -> expr < expr .)
    }               reduce using rule 38 (expr -> expr < expr .)
    FI              reduce using rule 38 (expr -> expr < expr .)
    +               shift and go to state 61
    -               shift and go to state 62
    *               shift and go to state 65
    /               shift and go to state 63
    DOT             shift and go to state 57
    @               shift and go to state 58

  ! +               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! DOT             [ reduce using rule 38 (expr -> expr < expr .) ]
  ! @               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! <               [ shift and go to state 59 ]
  ! LE              [ shift and go to state 60 ]
  ! =               [ shift and go to state 64 ]


state 85

    (39) expr -> expr LE expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    OF              reduce using rule 39 (expr -> expr LE expr .)
    <               reduce using rule 39 (expr -> expr LE expr .)
    LE              reduce using rule 39 (expr -> expr LE expr .)
    =               reduce using rule 39 (expr -> expr LE expr .)
    ;               reduce using rule 39 (expr -> expr LE expr .)
    )               reduce using rule 39 (expr -> expr LE expr .)
    ,               reduce using rule 39 (expr -> expr LE expr .)
    IN              reduce using rule 39 (expr -> expr LE expr .)
    THEN            reduce using rule 39 (expr -> expr LE expr .)
    LOOP            reduce using rule 39 (expr -> expr LE expr .)
    ELSE            reduce using rule 39 (expr -> expr LE expr .)
    POOL            reduce using rule 39 (expr -> expr LE expr .)
    }               reduce using rule 39 (expr -> expr LE expr .)
    FI              reduce using rule 39 (expr -> expr LE expr .)
    +               shift and go to state 61
    -               shift and go to state 62
    *               shift and go to state 65
    /               shift and go to state 63
    DOT             shift and go to state 57
    @               shift and go to state 58

  ! +               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! -               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! *               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! /               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! DOT             [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! @               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! <               [ shift and go to state 59 ]
  ! LE              [ shift and go to state 60 ]
  ! =               [ shift and go to state 64 ]


state 86

    (34) expr -> expr + expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    OF              reduce using rule 34 (expr -> expr + expr .)
    +               reduce using rule 34 (expr -> expr + expr .)
    -               reduce using rule 34 (expr -> expr + expr .)
    <               reduce using rule 34 (expr -> expr + expr .)
    LE              reduce using rule 34 (expr -> expr + expr .)
    =               reduce using rule 34 (expr -> expr + expr .)
    ;               reduce using rule 34 (expr -> expr + expr .)
    )               reduce using rule 34 (expr -> expr + expr .)
    ,               reduce using rule 34 (expr -> expr + expr .)
    IN              reduce using rule 34 (expr -> expr + expr .)
    THEN            reduce using rule 34 (expr -> expr + expr .)
    LOOP            reduce using rule 34 (expr -> expr + expr .)
    ELSE            reduce using rule 34 (expr -> expr + expr .)
    POOL            reduce using rule 34 (expr -> expr + expr .)
    }               reduce using rule 34 (expr -> expr + expr .)
    FI              reduce using rule 34 (expr -> expr + expr .)
    *               shift and go to state 65
    /               shift and go to state 63
    DOT             shift and go to state 57
    @               shift and go to state 58

  ! *               [ reduce using rule 34 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 34 (expr -> expr + expr .) ]
  ! DOT             [ reduce using rule 34 (expr -> expr + expr .) ]
  ! @               [ reduce using rule 34 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 61 ]
  ! -               [ shift and go to state 62 ]
  ! <               [ shift and go to state 59 ]
  ! LE              [ shift and go to state 60 ]
  ! =               [ shift and go to state 64 ]


state 87

    (35) expr -> expr - expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    OF              reduce using rule 35 (expr -> expr - expr .)
    +               reduce using rule 35 (expr -> expr - expr .)
    -               reduce using rule 35 (expr -> expr - expr .)
    <               reduce using rule 35 (expr -> expr - expr .)
    LE              reduce using rule 35 (expr -> expr - expr .)
    =               reduce using rule 35 (expr -> expr - expr .)
    ;               reduce using rule 35 (expr -> expr - expr .)
    )               reduce using rule 35 (expr -> expr - expr .)
    ,               reduce using rule 35 (expr -> expr - expr .)
    IN              reduce using rule 35 (expr -> expr - expr .)
    THEN            reduce using rule 35 (expr -> expr - expr .)
    LOOP            reduce using rule 35 (expr -> expr - expr .)
    ELSE            reduce using rule 35 (expr -> expr - expr .)
    POOL            reduce using rule 35 (expr -> expr - expr .)
    }               reduce using rule 35 (expr -> expr - expr .)
    FI              reduce using rule 35 (expr -> expr - expr .)
    *               shift and go to state 65
    /               shift and go to state 63
    DOT             shift and go to state 57
    @               shift and go to state 58

  ! *               [ reduce using rule 35 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 35 (expr -> expr - expr .) ]
  ! DOT             [ reduce using rule 35 (expr -> expr - expr .) ]
  ! @               [ reduce using rule 35 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 61 ]
  ! -               [ shift and go to state 62 ]
  ! <               [ shift and go to state 59 ]
  ! LE              [ shift and go to state 60 ]
  ! =               [ shift and go to state 64 ]


state 88

    (37) expr -> expr / expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    OF              reduce using rule 37 (expr -> expr / expr .)
    +               reduce using rule 37 (expr -> expr / expr .)
    -               reduce using rule 37 (expr -> expr / expr .)
    *               reduce using rule 37 (expr -> expr / expr .)
    /               reduce using rule 37 (expr -> expr / expr .)
    <               reduce using rule 37 (expr -> expr / expr .)
    LE              reduce using rule 37 (expr -> expr / expr .)
    =               reduce using rule 37 (expr -> expr / expr .)
    ;               reduce using rule 37 (expr -> expr / expr .)
    )               reduce using rule 37 (expr -> expr / expr .)
    ,               reduce using rule 37 (expr -> expr / expr .)
    IN              reduce using rule 37 (expr -> expr / expr .)
    THEN            reduce using rule 37 (expr -> expr / expr .)
    LOOP            reduce using rule 37 (expr -> expr / expr .)
    ELSE            reduce using rule 37 (expr -> expr / expr .)
    POOL            reduce using rule 37 (expr -> expr / expr .)
    }               reduce using rule 37 (expr -> expr / expr .)
    FI              reduce using rule 37 (expr -> expr / expr .)
    DOT             shift and go to state 57
    @               shift and go to state 58

  ! DOT             [ reduce using rule 37 (expr -> expr / expr .) ]
  ! @               [ reduce using rule 37 (expr -> expr / expr .) ]
  ! +               [ shift and go to state 61 ]
  ! -               [ shift and go to state 62 ]
  ! *               [ shift and go to state 65 ]
  ! /               [ shift and go to state 63 ]
  ! <               [ shift and go to state 59 ]
  ! LE              [ shift and go to state 60 ]
  ! =               [ shift and go to state 64 ]


state 89

    (40) expr -> expr = expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    OF              reduce using rule 40 (expr -> expr = expr .)
    <               reduce using rule 40 (expr -> expr = expr .)
    LE              reduce using rule 40 (expr -> expr = expr .)
    =               reduce using rule 40 (expr -> expr = expr .)
    ;               reduce using rule 40 (expr -> expr = expr .)
    )               reduce using rule 40 (expr -> expr = expr .)
    ,               reduce using rule 40 (expr -> expr = expr .)
    IN              reduce using rule 40 (expr -> expr = expr .)
    THEN            reduce using rule 40 (expr -> expr = expr .)
    LOOP            reduce using rule 40 (expr -> expr = expr .)
    ELSE            reduce using rule 40 (expr -> expr = expr .)
    POOL            reduce using rule 40 (expr -> expr = expr .)
    }               reduce using rule 40 (expr -> expr = expr .)
    FI              reduce using rule 40 (expr -> expr = expr .)
    +               shift and go to state 61
    -               shift and go to state 62
    *               shift and go to state 65
    /               shift and go to state 63
    DOT             shift and go to state 57
    @               shift and go to state 58

  ! +               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! -               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! *               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! /               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! DOT             [ reduce using rule 40 (expr -> expr = expr .) ]
  ! @               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! <               [ shift and go to state 59 ]
  ! LE              [ shift and go to state 60 ]
  ! =               [ shift and go to state 64 ]


state 90

    (36) expr -> expr * expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    OF              reduce using rule 36 (expr -> expr * expr .)
    +               reduce using rule 36 (expr -> expr * expr .)
    -               reduce using rule 36 (expr -> expr * expr .)
    *               reduce using rule 36 (expr -> expr * expr .)
    /               reduce using rule 36 (expr -> expr * expr .)
    <               reduce using rule 36 (expr -> expr * expr .)
    LE              reduce using rule 36 (expr -> expr * expr .)
    =               reduce using rule 36 (expr -> expr * expr .)
    ;               reduce using rule 36 (expr -> expr * expr .)
    )               reduce using rule 36 (expr -> expr * expr .)
    ,               reduce using rule 36 (expr -> expr * expr .)
    IN              reduce using rule 36 (expr -> expr * expr .)
    THEN            reduce using rule 36 (expr -> expr * expr .)
    LOOP            reduce using rule 36 (expr -> expr * expr .)
    ELSE            reduce using rule 36 (expr -> expr * expr .)
    POOL            reduce using rule 36 (expr -> expr * expr .)
    }               reduce using rule 36 (expr -> expr * expr .)
    FI              reduce using rule 36 (expr -> expr * expr .)
    DOT             shift and go to state 57
    @               shift and go to state 58

  ! DOT             [ reduce using rule 36 (expr -> expr * expr .) ]
  ! @               [ reduce using rule 36 (expr -> expr * expr .) ]
  ! +               [ shift and go to state 61 ]
  ! -               [ shift and go to state 62 ]
  ! *               [ shift and go to state 65 ]
  ! /               [ shift and go to state 63 ]
  ! <               [ shift and go to state 59 ]
  ! LE              [ shift and go to state 60 ]
  ! =               [ shift and go to state 64 ]


state 91

    (33) expr -> ( expr ) .

    OF              reduce using rule 33 (expr -> ( expr ) .)
    +               reduce using rule 33 (expr -> ( expr ) .)
    -               reduce using rule 33 (expr -> ( expr ) .)
    *               reduce using rule 33 (expr -> ( expr ) .)
    /               reduce using rule 33 (expr -> ( expr ) .)
    <               reduce using rule 33 (expr -> ( expr ) .)
    LE              reduce using rule 33 (expr -> ( expr ) .)
    =               reduce using rule 33 (expr -> ( expr ) .)
    DOT             reduce using rule 33 (expr -> ( expr ) .)
    @               reduce using rule 33 (expr -> ( expr ) .)
    ;               reduce using rule 33 (expr -> ( expr ) .)
    )               reduce using rule 33 (expr -> ( expr ) .)
    ,               reduce using rule 33 (expr -> ( expr ) .)
    IN              reduce using rule 33 (expr -> ( expr ) .)
    THEN            reduce using rule 33 (expr -> ( expr ) .)
    LOOP            reduce using rule 33 (expr -> ( expr ) .)
    ELSE            reduce using rule 33 (expr -> ( expr ) .)
    POOL            reduce using rule 33 (expr -> ( expr ) .)
    }               reduce using rule 33 (expr -> ( expr ) .)
    FI              reduce using rule 33 (expr -> ( expr ) .)


state 92

    (50) ifthenelse -> IF expr THEN . expr ELSE expr FI
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 106
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    methodinvoke                   shift and go to state 52

state 93

    (55) variablelist -> variabledefinition , . variablelist
    (55) variablelist -> . variabledefinition , variablelist
    (56) variablelist -> . variabledefinition
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (12) variabledeclaration -> . OBJECTID : TYPEID

    OBJECTID        shift and go to state 29

    variablelist                   shift and go to state 107
    variabledeclaration            shift and go to state 18
    variabledefinition             shift and go to state 69

state 94

    (46) letexpr -> LET variablelist IN . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 108
    methodinvoke                   shift and go to state 52
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35

state 95

    (51) whileloop -> WHILE expr LOOP . expr POOL
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 109
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    methodinvoke                   shift and go to state 52

state 96

    (57) caseexpr -> CASE expr OF . casestatements ESAC
    (58) casestatements -> . variabledeclaration DARROW expr ; casestatements
    (59) casestatements -> . variabledeclaration DARROW expr ;
    (12) variabledeclaration -> . OBJECTID : TYPEID

    OBJECTID        shift and go to state 29

    casestatements                 shift and go to state 110
    variabledeclaration            shift and go to state 111

state 97

    (45) assignment -> OBJECTID ASSIGN expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    }               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    ,               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    IN              reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    )               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    THEN            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    LOOP            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    OF              reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    ELSE            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    POOL            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    FI              reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    +               shift and go to state 61
    -               shift and go to state 62
    *               shift and go to state 65
    /               shift and go to state 63
    <               shift and go to state 59
    LE              shift and go to state 60
    =               shift and go to state 64
    DOT             shift and go to state 57
    @               shift and go to state 58

  ! +               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! -               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! *               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! /               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! <               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! LE              [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! =               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! DOT             [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! @               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]


state 98

    (18) actualargs -> expr . , actualargs
    (19) actualargs -> expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               shift and go to state 112
    )               reduce using rule 19 (actualargs -> expr .)
    +               shift and go to state 61
    -               shift and go to state 62
    *               shift and go to state 65
    /               shift and go to state 63
    <               shift and go to state 59
    LE              shift and go to state 60
    =               shift and go to state 64
    DOT             shift and go to state 57
    @               shift and go to state 58


state 99

    (20) actualargs -> empty .

    )               reduce using rule 20 (actualargs -> empty .)


state 100

    (49) localmethodinvoke -> OBJECTID ( actualargs . )

    )               shift and go to state 113


state 101

    (53) blockstatements -> expr ; . blockstatements
    (54) blockstatements -> expr ; .
    (53) blockstatements -> . expr ; blockstatements
    (54) blockstatements -> . expr ;
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    }               reduce using rule 54 (blockstatements -> expr ; .)
    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    blockstatements                shift and go to state 114
    expr                           shift and go to state 78
    methodinvoke                   shift and go to state 52
    letexpr                        shift and go to state 40
    localmethodinvoke              shift and go to state 44
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    whileloop                      shift and go to state 53

state 102

    (52) blockexpr -> { blockstatements } .

    ;               reduce using rule 52 (blockexpr -> { blockstatements } .)
    +               reduce using rule 52 (blockexpr -> { blockstatements } .)
    -               reduce using rule 52 (blockexpr -> { blockstatements } .)
    *               reduce using rule 52 (blockexpr -> { blockstatements } .)
    /               reduce using rule 52 (blockexpr -> { blockstatements } .)
    <               reduce using rule 52 (blockexpr -> { blockstatements } .)
    LE              reduce using rule 52 (blockexpr -> { blockstatements } .)
    =               reduce using rule 52 (blockexpr -> { blockstatements } .)
    DOT             reduce using rule 52 (blockexpr -> { blockstatements } .)
    @               reduce using rule 52 (blockexpr -> { blockstatements } .)
    ,               reduce using rule 52 (blockexpr -> { blockstatements } .)
    IN              reduce using rule 52 (blockexpr -> { blockstatements } .)
    )               reduce using rule 52 (blockexpr -> { blockstatements } .)
    THEN            reduce using rule 52 (blockexpr -> { blockstatements } .)
    LOOP            reduce using rule 52 (blockexpr -> { blockstatements } .)
    OF              reduce using rule 52 (blockexpr -> { blockstatements } .)
    ELSE            reduce using rule 52 (blockexpr -> { blockstatements } .)
    POOL            reduce using rule 52 (blockexpr -> { blockstatements } .)
    }               reduce using rule 52 (blockexpr -> { blockstatements } .)
    FI              reduce using rule 52 (blockexpr -> { blockstatements } .)


state 103

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID . { expr }

    {               shift and go to state 115


state 104

    (47) methodinvoke -> expr DOT OBJECTID ( . actualargs )
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    empty                          shift and go to state 99
    expr                           shift and go to state 98
    methodinvoke                   shift and go to state 52
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    actualargs                     shift and go to state 116

state 105

    (48) methodinvoke -> expr @ TYPEID DOT . OBJECTID ( actualargs )

    OBJECTID        shift and go to state 117


state 106

    (50) ifthenelse -> IF expr THEN expr . ELSE expr FI
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ELSE            shift and go to state 118
    +               shift and go to state 61
    -               shift and go to state 62
    *               shift and go to state 65
    /               shift and go to state 63
    <               shift and go to state 59
    LE              shift and go to state 60
    =               shift and go to state 64
    DOT             shift and go to state 57
    @               shift and go to state 58


state 107

    (55) variablelist -> variabledefinition , variablelist .

    IN              reduce using rule 55 (variablelist -> variabledefinition , variablelist .)


state 108

    (46) letexpr -> LET variablelist IN expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    ,               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    IN              reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    )               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    THEN            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    LOOP            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    OF              reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    ELSE            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    POOL            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    }               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    FI              reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    +               shift and go to state 61
    -               shift and go to state 62
    *               shift and go to state 65
    /               shift and go to state 63
    <               shift and go to state 59
    LE              shift and go to state 60
    =               shift and go to state 64
    DOT             shift and go to state 57
    @               shift and go to state 58

  ! +               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! -               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! *               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! /               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! <               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! LE              [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! =               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! DOT             [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! @               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]


state 109

    (51) whileloop -> WHILE expr LOOP expr . POOL
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    POOL            shift and go to state 119
    +               shift and go to state 61
    -               shift and go to state 62
    *               shift and go to state 65
    /               shift and go to state 63
    <               shift and go to state 59
    LE              shift and go to state 60
    =               shift and go to state 64
    DOT             shift and go to state 57
    @               shift and go to state 58


state 110

    (57) caseexpr -> CASE expr OF casestatements . ESAC

    ESAC            shift and go to state 120


state 111

    (58) casestatements -> variabledeclaration . DARROW expr ; casestatements
    (59) casestatements -> variabledeclaration . DARROW expr ;

    DARROW          shift and go to state 121


state 112

    (18) actualargs -> expr , . actualargs
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    empty                          shift and go to state 99
    expr                           shift and go to state 98
    methodinvoke                   shift and go to state 52
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    actualargs                     shift and go to state 122

state 113

    (49) localmethodinvoke -> OBJECTID ( actualargs ) .

    }               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    +               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    -               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    *               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    /               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    <               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    LE              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    =               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    DOT             reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    @               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    POOL            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    ,               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    )               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    ;               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    IN              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    THEN            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    LOOP            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    OF              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    ELSE            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    FI              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)


state 114

    (53) blockstatements -> expr ; blockstatements .

    }               reduce using rule 53 (blockstatements -> expr ; blockstatements .)


state 115

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID { . expr }
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 123
    methodinvoke                   shift and go to state 52
    letexpr                        shift and go to state 40
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    whileloop                      shift and go to state 53

state 116

    (47) methodinvoke -> expr DOT OBJECTID ( actualargs . )

    )               shift and go to state 124


state 117

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID . ( actualargs )

    (               shift and go to state 125


state 118

    (50) ifthenelse -> IF expr THEN expr ELSE . expr FI
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 126
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    methodinvoke                   shift and go to state 52

state 119

    (51) whileloop -> WHILE expr LOOP expr POOL .

    FI              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    +               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    -               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    *               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    /               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    <               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    LE              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    =               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    DOT             reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    @               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    ;               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    ,               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    IN              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    )               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    THEN            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    LOOP            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    OF              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    ELSE            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    POOL            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    }               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)


state 120

    (57) caseexpr -> CASE expr OF casestatements ESAC .

    +               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    -               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    *               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    /               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    <               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    LE              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    =               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    DOT             reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    @               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    ;               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    ,               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    IN              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    )               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    THEN            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    LOOP            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    OF              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    ELSE            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    POOL            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    }               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    FI              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)


state 121

    (58) casestatements -> variabledeclaration DARROW . expr ; casestatements
    (59) casestatements -> variabledeclaration DARROW . expr ;
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    expr                           shift and go to state 127
    methodinvoke                   shift and go to state 52
    letexpr                        shift and go to state 40
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    whileloop                      shift and go to state 53

state 122

    (18) actualargs -> expr , actualargs .

    )               reduce using rule 18 (actualargs -> expr , actualargs .)


state 123

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr . }
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    }               shift and go to state 128
    +               shift and go to state 61
    -               shift and go to state 62
    *               shift and go to state 65
    /               shift and go to state 63
    <               shift and go to state 59
    LE              shift and go to state 60
    =               shift and go to state 64
    DOT             shift and go to state 57
    @               shift and go to state 58


state 124

    (47) methodinvoke -> expr DOT OBJECTID ( actualargs ) .

    +               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    -               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    *               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    /               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    <               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    LE              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    =               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    DOT             reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    @               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    ;               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    ,               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    IN              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    )               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    THEN            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    LOOP            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    OF              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    ELSE            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    POOL            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    }               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    FI              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)


state 125

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID ( . actualargs )
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 48
    ISVOID          shift and go to state 34
    NOT             shift and go to state 47
    ~               shift and go to state 39
    (               shift and go to state 33
    INT_CONST       shift and go to state 42
    STR_CONST       shift and go to state 49
    BOOL_CONST      shift and go to state 37
    OBJECTID        shift and go to state 50
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 36
    WHILE           shift and go to state 41
    {               shift and go to state 54
    LET             shift and go to state 38
    CASE            shift and go to state 45

    ifthenelse                     shift and go to state 43
    localmethodinvoke              shift and go to state 44
    empty                          shift and go to state 99
    expr                           shift and go to state 98
    methodinvoke                   shift and go to state 52
    letexpr                        shift and go to state 40
    whileloop                      shift and go to state 53
    blockexpr                      shift and go to state 51
    assignment                     shift and go to state 46
    caseexpr                       shift and go to state 35
    actualargs                     shift and go to state 129

state 126

    (50) ifthenelse -> IF expr THEN expr ELSE expr . FI
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    FI              shift and go to state 130
    +               shift and go to state 61
    -               shift and go to state 62
    *               shift and go to state 65
    /               shift and go to state 63
    <               shift and go to state 59
    LE              shift and go to state 60
    =               shift and go to state 64
    DOT             shift and go to state 57
    @               shift and go to state 58


state 127

    (58) casestatements -> variabledeclaration DARROW expr . ; casestatements
    (59) casestatements -> variabledeclaration DARROW expr . ;
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               shift and go to state 131
    +               shift and go to state 61
    -               shift and go to state 62
    *               shift and go to state 65
    /               shift and go to state 63
    <               shift and go to state 59
    LE              shift and go to state 60
    =               shift and go to state 64
    DOT             shift and go to state 57
    @               shift and go to state 58


state 128

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr } .

    ;               reduce using rule 10 (methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr } .)


state 129

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs . )

    )               shift and go to state 132


state 130

    (50) ifthenelse -> IF expr THEN expr ELSE expr FI .

    THEN            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    +               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    -               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    *               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    /               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    <               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    LE              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    =               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    DOT             reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    @               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    ;               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    ,               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    IN              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    )               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    LOOP            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    OF              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    ELSE            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    POOL            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    }               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    FI              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)


state 131

    (58) casestatements -> variabledeclaration DARROW expr ; . casestatements
    (59) casestatements -> variabledeclaration DARROW expr ; .
    (58) casestatements -> . variabledeclaration DARROW expr ; casestatements
    (59) casestatements -> . variabledeclaration DARROW expr ;
    (12) variabledeclaration -> . OBJECTID : TYPEID

    ESAC            reduce using rule 59 (casestatements -> variabledeclaration DARROW expr ; .)
    OBJECTID        shift and go to state 29

    casestatements                 shift and go to state 133
    variabledeclaration            shift and go to state 111

state 132

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .

    +               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    -               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    *               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    /               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    <               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    LE              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    =               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    DOT             reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    @               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    ;               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    ,               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    IN              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    )               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    THEN            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    LOOP            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    OF              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    ELSE            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    POOL            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    }               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    FI              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)


state 133

    (58) casestatements -> variabledeclaration DARROW expr ; casestatements .

    ESAC            reduce using rule 58 (casestatements -> variabledeclaration DARROW expr ; casestatements .)

