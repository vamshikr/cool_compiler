Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT_MULTILINE
    NEWLINE
    COMMENT_SINGLELINE

Grammar

Rule 0     S' -> program
Rule 1     program -> class ; program
Rule 2     program -> class ;
Rule 3     class -> CLASS TYPEID baseclass { features }
Rule 4     baseclass -> INHERITS TYPEID
Rule 5     baseclass -> empty
Rule 6     features -> feature ; features
Rule 7     features -> empty
Rule 8     feature -> variabledefinition
Rule 9     feature -> methoddefinition
Rule 10    methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr }
Rule 11    variabledefinition -> variabledeclaration variableinitialization
Rule 12    variabledeclaration -> OBJECTID : TYPEID
Rule 13    variableinitialization -> ASSIGN expr
Rule 14    variableinitialization -> empty
Rule 15    formalargs -> variabledeclaration , formalargs
Rule 16    formalargs -> variabledeclaration
Rule 17    formalargs -> empty
Rule 18    actualargs -> expr , actualargs
Rule 19    actualargs -> expr
Rule 20    actualargs -> empty
Rule 21    expr -> assignment
Rule 22    expr -> methodinvoke
Rule 23    expr -> localmethodinvoke
Rule 24    expr -> ifthenelse
Rule 25    expr -> whileloop
Rule 26    expr -> blockexpr
Rule 27    expr -> letexpr
Rule 28    expr -> caseexpr
Rule 29    expr -> NEW TYPEID
Rule 30    expr -> ISVOID expr
Rule 31    expr -> NOT expr
Rule 32    expr -> ~ expr
Rule 33    expr -> ( expr )
Rule 34    expr -> expr + expr
Rule 35    expr -> expr - expr
Rule 36    expr -> expr * expr
Rule 37    expr -> expr / expr
Rule 38    expr -> expr < expr
Rule 39    expr -> expr LE expr
Rule 40    expr -> expr = expr
Rule 41    expr -> INT_CONST
Rule 42    expr -> STR_CONST
Rule 43    expr -> BOOL_CONST
Rule 44    expr -> OBJECTID
Rule 45    assignment -> OBJECTID ASSIGN expr
Rule 46    letexpr -> LET variablelist IN expr
Rule 47    methodinvoke -> expr DOT OBJECTID ( actualargs )
Rule 48    methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs )
Rule 49    localmethodinvoke -> OBJECTID ( actualargs )
Rule 50    ifthenelse -> IF expr THEN expr ELSE expr FI
Rule 51    whileloop -> WHILE expr LOOP expr POOL
Rule 52    blockexpr -> { blockstatements }
Rule 53    blockstatements -> expr ; blockstatements
Rule 54    blockstatements -> expr ;
Rule 55    variablelist -> variabledefinition , variablelist
Rule 56    variablelist -> variabledefinition
Rule 57    caseexpr -> CASE expr OF casestatements ESAC
Rule 58    casestatements -> variabledeclaration DARROW expr ; casestatements
Rule 59    casestatements -> variabledeclaration DARROW expr ;
Rule 60    empty -> <empty>

Terminals, with rules where they appear

(                    : 10 33 47 48 49
)                    : 10 33 47 48 49
*                    : 36
+                    : 34
,                    : 15 18 55
-                    : 35
/                    : 37
:                    : 10 12
;                    : 1 2 6 53 54 58 59
<                    : 38
=                    : 40
@                    : 48
ASSIGN               : 13 45
BOOL_CONST           : 43
CASE                 : 57
CLASS                : 3
COMMENT_MULTILINE    : 
COMMENT_SINGLELINE   : 
DARROW               : 58 59
DOT                  : 47 48
ELSE                 : 50
ESAC                 : 57
FI                   : 50
IF                   : 50
IN                   : 46
INHERITS             : 4
INT_CONST            : 41
ISVOID               : 30
LE                   : 39
LET                  : 46
LOOP                 : 51
NEW                  : 29
NEWLINE              : 
NOT                  : 31
OBJECTID             : 10 12 44 45 47 48 49
OF                   : 57
POOL                 : 51
STR_CONST            : 42
THEN                 : 50
TYPEID               : 3 4 10 12 29 48
WHILE                : 51
error                : 
{                    : 3 10 52
}                    : 3 10 52
~                    : 32

Nonterminals, with rules where they appear

actualargs           : 18 47 48 49
assignment           : 21
baseclass            : 3
blockexpr            : 26
blockstatements      : 52 53
caseexpr             : 28
casestatements       : 57 58
class                : 1 2
empty                : 5 7 14 17 20
expr                 : 10 13 18 19 30 31 32 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 45 46 47 48 50 50 50 51 51 53 54 57 58 59
feature              : 6
features             : 3 6
formalargs           : 10 15
ifthenelse           : 24
letexpr              : 27
localmethodinvoke    : 23
methoddefinition     : 9
methodinvoke         : 22
program              : 1 0
variabledeclaration  : 11 15 16 58 59
variabledefinition   : 8 55 56
variableinitialization : 11
variablelist         : 46 55
whileloop            : 25

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class ; program
    (2) program -> . class ;
    (3) class -> . CLASS TYPEID baseclass { features }

    CLASS           shift and go to state 2

    class                          shift and go to state 1
    program                        shift and go to state 3

state 1

    (1) program -> class . ; program
    (2) program -> class . ;

    ;               shift and go to state 4


state 2

    (3) class -> CLASS . TYPEID baseclass { features }

    TYPEID          shift and go to state 5


state 3

    (0) S' -> program .



state 4

    (1) program -> class ; . program
    (2) program -> class ; .
    (1) program -> . class ; program
    (2) program -> . class ;
    (3) class -> . CLASS TYPEID baseclass { features }

    $end            reduce using rule 2 (program -> class ; .)
    CLASS           shift and go to state 2

    class                          shift and go to state 1
    program                        shift and go to state 6

state 5

    (3) class -> CLASS TYPEID . baseclass { features }
    (4) baseclass -> . INHERITS TYPEID
    (5) baseclass -> . empty
    (60) empty -> .

    INHERITS        shift and go to state 9
    {               reduce using rule 60 (empty -> .)

    baseclass                      shift and go to state 7
    empty                          shift and go to state 8

state 6

    (1) program -> class ; program .

    $end            reduce using rule 1 (program -> class ; program .)


state 7

    (3) class -> CLASS TYPEID baseclass . { features }

    {               shift and go to state 10


state 8

    (5) baseclass -> empty .

    {               reduce using rule 5 (baseclass -> empty .)


state 9

    (4) baseclass -> INHERITS . TYPEID

    TYPEID          shift and go to state 11


state 10

    (3) class -> CLASS TYPEID baseclass { . features }
    (6) features -> . feature ; features
    (7) features -> . empty
    (8) feature -> . variabledefinition
    (9) feature -> . methoddefinition
    (60) empty -> .
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (10) methoddefinition -> . OBJECTID ( formalargs ) : TYPEID { expr }
    (12) variabledeclaration -> . OBJECTID : TYPEID

    }               reduce using rule 60 (empty -> .)
    OBJECTID        shift and go to state 18

    features                       shift and go to state 12
    empty                          shift and go to state 13
    variabledefinition             shift and go to state 15
    feature                        shift and go to state 16
    methoddefinition               shift and go to state 14
    variabledeclaration            shift and go to state 17

state 11

    (4) baseclass -> INHERITS TYPEID .

    {               reduce using rule 4 (baseclass -> INHERITS TYPEID .)


state 12

    (3) class -> CLASS TYPEID baseclass { features . }

    }               shift and go to state 19


state 13

    (7) features -> empty .

    }               reduce using rule 7 (features -> empty .)


state 14

    (9) feature -> methoddefinition .

    ;               reduce using rule 9 (feature -> methoddefinition .)


state 15

    (8) feature -> variabledefinition .

    ;               reduce using rule 8 (feature -> variabledefinition .)


state 16

    (6) features -> feature . ; features

    ;               shift and go to state 20


state 17

    (11) variabledefinition -> variabledeclaration . variableinitialization
    (13) variableinitialization -> . ASSIGN expr
    (14) variableinitialization -> . empty
    (60) empty -> .

    ASSIGN          shift and go to state 23
    ;               reduce using rule 60 (empty -> .)
    ,               reduce using rule 60 (empty -> .)
    IN              reduce using rule 60 (empty -> .)

    empty                          shift and go to state 21
    variableinitialization         shift and go to state 22

state 18

    (10) methoddefinition -> OBJECTID . ( formalargs ) : TYPEID { expr }
    (12) variabledeclaration -> OBJECTID . : TYPEID

    (               shift and go to state 24
    :               shift and go to state 25


state 19

    (3) class -> CLASS TYPEID baseclass { features } .

    ;               reduce using rule 3 (class -> CLASS TYPEID baseclass { features } .)


state 20

    (6) features -> feature ; . features
    (6) features -> . feature ; features
    (7) features -> . empty
    (8) feature -> . variabledefinition
    (9) feature -> . methoddefinition
    (60) empty -> .
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (10) methoddefinition -> . OBJECTID ( formalargs ) : TYPEID { expr }
    (12) variabledeclaration -> . OBJECTID : TYPEID

    }               reduce using rule 60 (empty -> .)
    OBJECTID        shift and go to state 18

    features                       shift and go to state 26
    feature                        shift and go to state 16
    empty                          shift and go to state 13
    methoddefinition               shift and go to state 14
    variabledefinition             shift and go to state 15
    variabledeclaration            shift and go to state 17

state 21

    (14) variableinitialization -> empty .

    ;               reduce using rule 14 (variableinitialization -> empty .)
    ,               reduce using rule 14 (variableinitialization -> empty .)
    IN              reduce using rule 14 (variableinitialization -> empty .)


state 22

    (11) variabledefinition -> variabledeclaration variableinitialization .

    ,               reduce using rule 11 (variabledefinition -> variabledeclaration variableinitialization .)
    IN              reduce using rule 11 (variabledefinition -> variabledeclaration variableinitialization .)
    ;               reduce using rule 11 (variabledefinition -> variabledeclaration variableinitialization .)


state 23

    (13) variableinitialization -> ASSIGN . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 27
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 24

    (10) methoddefinition -> OBJECTID ( . formalargs ) : TYPEID { expr }
    (15) formalargs -> . variabledeclaration , formalargs
    (16) formalargs -> . variabledeclaration
    (17) formalargs -> . empty
    (12) variabledeclaration -> . OBJECTID : TYPEID
    (60) empty -> .

    OBJECTID        shift and go to state 53
    )               reduce using rule 60 (empty -> .)

    empty                          shift and go to state 52
    variabledeclaration            shift and go to state 50
    formalargs                     shift and go to state 51

state 25

    (12) variabledeclaration -> OBJECTID : . TYPEID

    TYPEID          shift and go to state 54


state 26

    (6) features -> feature ; features .

    }               reduce using rule 6 (features -> feature ; features .)


state 27

    (13) variableinitialization -> ASSIGN expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               reduce using rule 13 (variableinitialization -> ASSIGN expr .)
    ,               reduce using rule 13 (variableinitialization -> ASSIGN expr .)
    IN              reduce using rule 13 (variableinitialization -> ASSIGN expr .)
    +               shift and go to state 60
    -               shift and go to state 55
    *               shift and go to state 59
    /               shift and go to state 63
    <               shift and go to state 57
    LE              shift and go to state 62
    =               shift and go to state 58
    DOT             shift and go to state 56
    @               shift and go to state 61


state 28

    (27) expr -> letexpr .

    ,               reduce using rule 27 (expr -> letexpr .)
    +               reduce using rule 27 (expr -> letexpr .)
    -               reduce using rule 27 (expr -> letexpr .)
    *               reduce using rule 27 (expr -> letexpr .)
    /               reduce using rule 27 (expr -> letexpr .)
    <               reduce using rule 27 (expr -> letexpr .)
    LE              reduce using rule 27 (expr -> letexpr .)
    =               reduce using rule 27 (expr -> letexpr .)
    DOT             reduce using rule 27 (expr -> letexpr .)
    @               reduce using rule 27 (expr -> letexpr .)
    )               reduce using rule 27 (expr -> letexpr .)
    ;               reduce using rule 27 (expr -> letexpr .)
    IN              reduce using rule 27 (expr -> letexpr .)
    OF              reduce using rule 27 (expr -> letexpr .)
    THEN            reduce using rule 27 (expr -> letexpr .)
    LOOP            reduce using rule 27 (expr -> letexpr .)
    ELSE            reduce using rule 27 (expr -> letexpr .)
    POOL            reduce using rule 27 (expr -> letexpr .)
    FI              reduce using rule 27 (expr -> letexpr .)
    }               reduce using rule 27 (expr -> letexpr .)


state 29

    (57) caseexpr -> CASE . expr OF casestatements ESAC
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 64
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 30

    (41) expr -> INT_CONST .

    ,               reduce using rule 41 (expr -> INT_CONST .)
    +               reduce using rule 41 (expr -> INT_CONST .)
    -               reduce using rule 41 (expr -> INT_CONST .)
    *               reduce using rule 41 (expr -> INT_CONST .)
    /               reduce using rule 41 (expr -> INT_CONST .)
    <               reduce using rule 41 (expr -> INT_CONST .)
    LE              reduce using rule 41 (expr -> INT_CONST .)
    =               reduce using rule 41 (expr -> INT_CONST .)
    DOT             reduce using rule 41 (expr -> INT_CONST .)
    @               reduce using rule 41 (expr -> INT_CONST .)
    )               reduce using rule 41 (expr -> INT_CONST .)
    ;               reduce using rule 41 (expr -> INT_CONST .)
    IN              reduce using rule 41 (expr -> INT_CONST .)
    OF              reduce using rule 41 (expr -> INT_CONST .)
    THEN            reduce using rule 41 (expr -> INT_CONST .)
    LOOP            reduce using rule 41 (expr -> INT_CONST .)
    ELSE            reduce using rule 41 (expr -> INT_CONST .)
    POOL            reduce using rule 41 (expr -> INT_CONST .)
    FI              reduce using rule 41 (expr -> INT_CONST .)
    }               reduce using rule 41 (expr -> INT_CONST .)


state 31

    (31) expr -> NOT . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 65
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 32

    (43) expr -> BOOL_CONST .

    ,               reduce using rule 43 (expr -> BOOL_CONST .)
    +               reduce using rule 43 (expr -> BOOL_CONST .)
    -               reduce using rule 43 (expr -> BOOL_CONST .)
    *               reduce using rule 43 (expr -> BOOL_CONST .)
    /               reduce using rule 43 (expr -> BOOL_CONST .)
    <               reduce using rule 43 (expr -> BOOL_CONST .)
    LE              reduce using rule 43 (expr -> BOOL_CONST .)
    =               reduce using rule 43 (expr -> BOOL_CONST .)
    DOT             reduce using rule 43 (expr -> BOOL_CONST .)
    @               reduce using rule 43 (expr -> BOOL_CONST .)
    )               reduce using rule 43 (expr -> BOOL_CONST .)
    ;               reduce using rule 43 (expr -> BOOL_CONST .)
    IN              reduce using rule 43 (expr -> BOOL_CONST .)
    OF              reduce using rule 43 (expr -> BOOL_CONST .)
    THEN            reduce using rule 43 (expr -> BOOL_CONST .)
    LOOP            reduce using rule 43 (expr -> BOOL_CONST .)
    ELSE            reduce using rule 43 (expr -> BOOL_CONST .)
    POOL            reduce using rule 43 (expr -> BOOL_CONST .)
    FI              reduce using rule 43 (expr -> BOOL_CONST .)
    }               reduce using rule 43 (expr -> BOOL_CONST .)


state 33

    (21) expr -> assignment .

    ,               reduce using rule 21 (expr -> assignment .)
    +               reduce using rule 21 (expr -> assignment .)
    -               reduce using rule 21 (expr -> assignment .)
    *               reduce using rule 21 (expr -> assignment .)
    /               reduce using rule 21 (expr -> assignment .)
    <               reduce using rule 21 (expr -> assignment .)
    LE              reduce using rule 21 (expr -> assignment .)
    =               reduce using rule 21 (expr -> assignment .)
    DOT             reduce using rule 21 (expr -> assignment .)
    @               reduce using rule 21 (expr -> assignment .)
    )               reduce using rule 21 (expr -> assignment .)
    ;               reduce using rule 21 (expr -> assignment .)
    IN              reduce using rule 21 (expr -> assignment .)
    OF              reduce using rule 21 (expr -> assignment .)
    THEN            reduce using rule 21 (expr -> assignment .)
    LOOP            reduce using rule 21 (expr -> assignment .)
    ELSE            reduce using rule 21 (expr -> assignment .)
    POOL            reduce using rule 21 (expr -> assignment .)
    FI              reduce using rule 21 (expr -> assignment .)
    }               reduce using rule 21 (expr -> assignment .)


state 34

    (46) letexpr -> LET . variablelist IN expr
    (55) variablelist -> . variabledefinition , variablelist
    (56) variablelist -> . variabledefinition
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (12) variabledeclaration -> . OBJECTID : TYPEID

    OBJECTID        shift and go to state 53

    variablelist                   shift and go to state 66
    variabledeclaration            shift and go to state 17
    variabledefinition             shift and go to state 67

state 35

    (30) expr -> ISVOID . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 68
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 36

    (52) blockexpr -> { . blockstatements }
    (53) blockstatements -> . expr ; blockstatements
    (54) blockstatements -> . expr ;
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 69
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    blockstatements                shift and go to state 70
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 37

    (50) ifthenelse -> IF . expr THEN expr ELSE expr FI
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 71
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 38

    (24) expr -> ifthenelse .

    ,               reduce using rule 24 (expr -> ifthenelse .)
    +               reduce using rule 24 (expr -> ifthenelse .)
    -               reduce using rule 24 (expr -> ifthenelse .)
    *               reduce using rule 24 (expr -> ifthenelse .)
    /               reduce using rule 24 (expr -> ifthenelse .)
    <               reduce using rule 24 (expr -> ifthenelse .)
    LE              reduce using rule 24 (expr -> ifthenelse .)
    =               reduce using rule 24 (expr -> ifthenelse .)
    DOT             reduce using rule 24 (expr -> ifthenelse .)
    @               reduce using rule 24 (expr -> ifthenelse .)
    )               reduce using rule 24 (expr -> ifthenelse .)
    ;               reduce using rule 24 (expr -> ifthenelse .)
    IN              reduce using rule 24 (expr -> ifthenelse .)
    OF              reduce using rule 24 (expr -> ifthenelse .)
    THEN            reduce using rule 24 (expr -> ifthenelse .)
    LOOP            reduce using rule 24 (expr -> ifthenelse .)
    ELSE            reduce using rule 24 (expr -> ifthenelse .)
    POOL            reduce using rule 24 (expr -> ifthenelse .)
    FI              reduce using rule 24 (expr -> ifthenelse .)
    }               reduce using rule 24 (expr -> ifthenelse .)


state 39

    (23) expr -> localmethodinvoke .

    ,               reduce using rule 23 (expr -> localmethodinvoke .)
    +               reduce using rule 23 (expr -> localmethodinvoke .)
    -               reduce using rule 23 (expr -> localmethodinvoke .)
    *               reduce using rule 23 (expr -> localmethodinvoke .)
    /               reduce using rule 23 (expr -> localmethodinvoke .)
    <               reduce using rule 23 (expr -> localmethodinvoke .)
    LE              reduce using rule 23 (expr -> localmethodinvoke .)
    =               reduce using rule 23 (expr -> localmethodinvoke .)
    DOT             reduce using rule 23 (expr -> localmethodinvoke .)
    @               reduce using rule 23 (expr -> localmethodinvoke .)
    )               reduce using rule 23 (expr -> localmethodinvoke .)
    ;               reduce using rule 23 (expr -> localmethodinvoke .)
    IN              reduce using rule 23 (expr -> localmethodinvoke .)
    OF              reduce using rule 23 (expr -> localmethodinvoke .)
    THEN            reduce using rule 23 (expr -> localmethodinvoke .)
    LOOP            reduce using rule 23 (expr -> localmethodinvoke .)
    ELSE            reduce using rule 23 (expr -> localmethodinvoke .)
    POOL            reduce using rule 23 (expr -> localmethodinvoke .)
    FI              reduce using rule 23 (expr -> localmethodinvoke .)
    }               reduce using rule 23 (expr -> localmethodinvoke .)


state 40

    (32) expr -> ~ . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 72
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 41

    (29) expr -> NEW . TYPEID

    TYPEID          shift and go to state 73


state 42

    (25) expr -> whileloop .

    ,               reduce using rule 25 (expr -> whileloop .)
    +               reduce using rule 25 (expr -> whileloop .)
    -               reduce using rule 25 (expr -> whileloop .)
    *               reduce using rule 25 (expr -> whileloop .)
    /               reduce using rule 25 (expr -> whileloop .)
    <               reduce using rule 25 (expr -> whileloop .)
    LE              reduce using rule 25 (expr -> whileloop .)
    =               reduce using rule 25 (expr -> whileloop .)
    DOT             reduce using rule 25 (expr -> whileloop .)
    @               reduce using rule 25 (expr -> whileloop .)
    )               reduce using rule 25 (expr -> whileloop .)
    ;               reduce using rule 25 (expr -> whileloop .)
    IN              reduce using rule 25 (expr -> whileloop .)
    OF              reduce using rule 25 (expr -> whileloop .)
    THEN            reduce using rule 25 (expr -> whileloop .)
    LOOP            reduce using rule 25 (expr -> whileloop .)
    ELSE            reduce using rule 25 (expr -> whileloop .)
    POOL            reduce using rule 25 (expr -> whileloop .)
    FI              reduce using rule 25 (expr -> whileloop .)
    }               reduce using rule 25 (expr -> whileloop .)


state 43

    (22) expr -> methodinvoke .

    ,               reduce using rule 22 (expr -> methodinvoke .)
    +               reduce using rule 22 (expr -> methodinvoke .)
    -               reduce using rule 22 (expr -> methodinvoke .)
    *               reduce using rule 22 (expr -> methodinvoke .)
    /               reduce using rule 22 (expr -> methodinvoke .)
    <               reduce using rule 22 (expr -> methodinvoke .)
    LE              reduce using rule 22 (expr -> methodinvoke .)
    =               reduce using rule 22 (expr -> methodinvoke .)
    DOT             reduce using rule 22 (expr -> methodinvoke .)
    @               reduce using rule 22 (expr -> methodinvoke .)
    )               reduce using rule 22 (expr -> methodinvoke .)
    ;               reduce using rule 22 (expr -> methodinvoke .)
    IN              reduce using rule 22 (expr -> methodinvoke .)
    OF              reduce using rule 22 (expr -> methodinvoke .)
    THEN            reduce using rule 22 (expr -> methodinvoke .)
    LOOP            reduce using rule 22 (expr -> methodinvoke .)
    ELSE            reduce using rule 22 (expr -> methodinvoke .)
    POOL            reduce using rule 22 (expr -> methodinvoke .)
    FI              reduce using rule 22 (expr -> methodinvoke .)
    }               reduce using rule 22 (expr -> methodinvoke .)


state 44

    (28) expr -> caseexpr .

    ,               reduce using rule 28 (expr -> caseexpr .)
    +               reduce using rule 28 (expr -> caseexpr .)
    -               reduce using rule 28 (expr -> caseexpr .)
    *               reduce using rule 28 (expr -> caseexpr .)
    /               reduce using rule 28 (expr -> caseexpr .)
    <               reduce using rule 28 (expr -> caseexpr .)
    LE              reduce using rule 28 (expr -> caseexpr .)
    =               reduce using rule 28 (expr -> caseexpr .)
    DOT             reduce using rule 28 (expr -> caseexpr .)
    @               reduce using rule 28 (expr -> caseexpr .)
    )               reduce using rule 28 (expr -> caseexpr .)
    ;               reduce using rule 28 (expr -> caseexpr .)
    IN              reduce using rule 28 (expr -> caseexpr .)
    OF              reduce using rule 28 (expr -> caseexpr .)
    THEN            reduce using rule 28 (expr -> caseexpr .)
    LOOP            reduce using rule 28 (expr -> caseexpr .)
    ELSE            reduce using rule 28 (expr -> caseexpr .)
    POOL            reduce using rule 28 (expr -> caseexpr .)
    FI              reduce using rule 28 (expr -> caseexpr .)
    }               reduce using rule 28 (expr -> caseexpr .)


state 45

    (26) expr -> blockexpr .

    ,               reduce using rule 26 (expr -> blockexpr .)
    +               reduce using rule 26 (expr -> blockexpr .)
    -               reduce using rule 26 (expr -> blockexpr .)
    *               reduce using rule 26 (expr -> blockexpr .)
    /               reduce using rule 26 (expr -> blockexpr .)
    <               reduce using rule 26 (expr -> blockexpr .)
    LE              reduce using rule 26 (expr -> blockexpr .)
    =               reduce using rule 26 (expr -> blockexpr .)
    DOT             reduce using rule 26 (expr -> blockexpr .)
    @               reduce using rule 26 (expr -> blockexpr .)
    )               reduce using rule 26 (expr -> blockexpr .)
    ;               reduce using rule 26 (expr -> blockexpr .)
    IN              reduce using rule 26 (expr -> blockexpr .)
    OF              reduce using rule 26 (expr -> blockexpr .)
    THEN            reduce using rule 26 (expr -> blockexpr .)
    LOOP            reduce using rule 26 (expr -> blockexpr .)
    ELSE            reduce using rule 26 (expr -> blockexpr .)
    POOL            reduce using rule 26 (expr -> blockexpr .)
    FI              reduce using rule 26 (expr -> blockexpr .)
    }               reduce using rule 26 (expr -> blockexpr .)


state 46

    (42) expr -> STR_CONST .

    ,               reduce using rule 42 (expr -> STR_CONST .)
    +               reduce using rule 42 (expr -> STR_CONST .)
    -               reduce using rule 42 (expr -> STR_CONST .)
    *               reduce using rule 42 (expr -> STR_CONST .)
    /               reduce using rule 42 (expr -> STR_CONST .)
    <               reduce using rule 42 (expr -> STR_CONST .)
    LE              reduce using rule 42 (expr -> STR_CONST .)
    =               reduce using rule 42 (expr -> STR_CONST .)
    DOT             reduce using rule 42 (expr -> STR_CONST .)
    @               reduce using rule 42 (expr -> STR_CONST .)
    )               reduce using rule 42 (expr -> STR_CONST .)
    ;               reduce using rule 42 (expr -> STR_CONST .)
    IN              reduce using rule 42 (expr -> STR_CONST .)
    OF              reduce using rule 42 (expr -> STR_CONST .)
    THEN            reduce using rule 42 (expr -> STR_CONST .)
    LOOP            reduce using rule 42 (expr -> STR_CONST .)
    ELSE            reduce using rule 42 (expr -> STR_CONST .)
    POOL            reduce using rule 42 (expr -> STR_CONST .)
    FI              reduce using rule 42 (expr -> STR_CONST .)
    }               reduce using rule 42 (expr -> STR_CONST .)


state 47

    (51) whileloop -> WHILE . expr LOOP expr POOL
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 74
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 48

    (33) expr -> ( . expr )
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 75
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 49

    (44) expr -> OBJECTID .
    (45) assignment -> OBJECTID . ASSIGN expr
    (49) localmethodinvoke -> OBJECTID . ( actualargs )

    ,               reduce using rule 44 (expr -> OBJECTID .)
    +               reduce using rule 44 (expr -> OBJECTID .)
    -               reduce using rule 44 (expr -> OBJECTID .)
    *               reduce using rule 44 (expr -> OBJECTID .)
    /               reduce using rule 44 (expr -> OBJECTID .)
    <               reduce using rule 44 (expr -> OBJECTID .)
    LE              reduce using rule 44 (expr -> OBJECTID .)
    =               reduce using rule 44 (expr -> OBJECTID .)
    DOT             reduce using rule 44 (expr -> OBJECTID .)
    @               reduce using rule 44 (expr -> OBJECTID .)
    )               reduce using rule 44 (expr -> OBJECTID .)
    ;               reduce using rule 44 (expr -> OBJECTID .)
    IN              reduce using rule 44 (expr -> OBJECTID .)
    OF              reduce using rule 44 (expr -> OBJECTID .)
    THEN            reduce using rule 44 (expr -> OBJECTID .)
    LOOP            reduce using rule 44 (expr -> OBJECTID .)
    ELSE            reduce using rule 44 (expr -> OBJECTID .)
    POOL            reduce using rule 44 (expr -> OBJECTID .)
    FI              reduce using rule 44 (expr -> OBJECTID .)
    }               reduce using rule 44 (expr -> OBJECTID .)
    ASSIGN          shift and go to state 77
    (               shift and go to state 76


state 50

    (15) formalargs -> variabledeclaration . , formalargs
    (16) formalargs -> variabledeclaration .

    ,               shift and go to state 78
    )               reduce using rule 16 (formalargs -> variabledeclaration .)


state 51

    (10) methoddefinition -> OBJECTID ( formalargs . ) : TYPEID { expr }

    )               shift and go to state 79


state 52

    (17) formalargs -> empty .

    )               reduce using rule 17 (formalargs -> empty .)


state 53

    (12) variabledeclaration -> OBJECTID . : TYPEID

    :               shift and go to state 25


state 54

    (12) variabledeclaration -> OBJECTID : TYPEID .

    ASSIGN          reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    ;               reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    ,               reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    )               reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    DARROW          reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    IN              reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)


state 55

    (35) expr -> expr - . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 80
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 56

    (47) methodinvoke -> expr DOT . OBJECTID ( actualargs )

    OBJECTID        shift and go to state 81


state 57

    (38) expr -> expr < . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 82
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 58

    (40) expr -> expr = . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 83
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 59

    (36) expr -> expr * . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 84
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 60

    (34) expr -> expr + . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 85
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 61

    (48) methodinvoke -> expr @ . TYPEID DOT OBJECTID ( actualargs )

    TYPEID          shift and go to state 86


state 62

    (39) expr -> expr LE . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 87
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 63

    (37) expr -> expr / . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 88
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 64

    (57) caseexpr -> CASE expr . OF casestatements ESAC
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    OF              shift and go to state 89
    +               shift and go to state 60
    -               shift and go to state 55
    *               shift and go to state 59
    /               shift and go to state 63
    <               shift and go to state 57
    LE              shift and go to state 62
    =               shift and go to state 58
    DOT             shift and go to state 56
    @               shift and go to state 61


state 65

    (31) expr -> NOT expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 31 (expr -> NOT expr .)
    )               reduce using rule 31 (expr -> NOT expr .)
    ;               reduce using rule 31 (expr -> NOT expr .)
    IN              reduce using rule 31 (expr -> NOT expr .)
    OF              reduce using rule 31 (expr -> NOT expr .)
    THEN            reduce using rule 31 (expr -> NOT expr .)
    LOOP            reduce using rule 31 (expr -> NOT expr .)
    ELSE            reduce using rule 31 (expr -> NOT expr .)
    POOL            reduce using rule 31 (expr -> NOT expr .)
    FI              reduce using rule 31 (expr -> NOT expr .)
    }               reduce using rule 31 (expr -> NOT expr .)
    +               shift and go to state 60
    -               shift and go to state 55
    *               shift and go to state 59
    /               shift and go to state 63
    <               shift and go to state 57
    LE              shift and go to state 62
    =               shift and go to state 58
    DOT             shift and go to state 56
    @               shift and go to state 61

  ! +               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! -               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! *               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! /               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! <               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! LE              [ reduce using rule 31 (expr -> NOT expr .) ]
  ! =               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! DOT             [ reduce using rule 31 (expr -> NOT expr .) ]
  ! @               [ reduce using rule 31 (expr -> NOT expr .) ]


state 66

    (46) letexpr -> LET variablelist . IN expr

    IN              shift and go to state 90


state 67

    (55) variablelist -> variabledefinition . , variablelist
    (56) variablelist -> variabledefinition .

    ,               shift and go to state 91
    IN              reduce using rule 56 (variablelist -> variabledefinition .)


state 68

    (30) expr -> ISVOID expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 30 (expr -> ISVOID expr .)
    +               reduce using rule 30 (expr -> ISVOID expr .)
    -               reduce using rule 30 (expr -> ISVOID expr .)
    *               reduce using rule 30 (expr -> ISVOID expr .)
    /               reduce using rule 30 (expr -> ISVOID expr .)
    <               reduce using rule 30 (expr -> ISVOID expr .)
    LE              reduce using rule 30 (expr -> ISVOID expr .)
    =               reduce using rule 30 (expr -> ISVOID expr .)
    )               reduce using rule 30 (expr -> ISVOID expr .)
    ;               reduce using rule 30 (expr -> ISVOID expr .)
    IN              reduce using rule 30 (expr -> ISVOID expr .)
    OF              reduce using rule 30 (expr -> ISVOID expr .)
    THEN            reduce using rule 30 (expr -> ISVOID expr .)
    LOOP            reduce using rule 30 (expr -> ISVOID expr .)
    ELSE            reduce using rule 30 (expr -> ISVOID expr .)
    POOL            reduce using rule 30 (expr -> ISVOID expr .)
    FI              reduce using rule 30 (expr -> ISVOID expr .)
    }               reduce using rule 30 (expr -> ISVOID expr .)
    DOT             shift and go to state 56
    @               shift and go to state 61

  ! DOT             [ reduce using rule 30 (expr -> ISVOID expr .) ]
  ! @               [ reduce using rule 30 (expr -> ISVOID expr .) ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 55 ]
  ! *               [ shift and go to state 59 ]
  ! /               [ shift and go to state 63 ]
  ! <               [ shift and go to state 57 ]
  ! LE              [ shift and go to state 62 ]
  ! =               [ shift and go to state 58 ]


state 69

    (53) blockstatements -> expr . ; blockstatements
    (54) blockstatements -> expr . ;
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               shift and go to state 92
    +               shift and go to state 60
    -               shift and go to state 55
    *               shift and go to state 59
    /               shift and go to state 63
    <               shift and go to state 57
    LE              shift and go to state 62
    =               shift and go to state 58
    DOT             shift and go to state 56
    @               shift and go to state 61


state 70

    (52) blockexpr -> { blockstatements . }

    }               shift and go to state 93


state 71

    (50) ifthenelse -> IF expr . THEN expr ELSE expr FI
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    THEN            shift and go to state 94
    +               shift and go to state 60
    -               shift and go to state 55
    *               shift and go to state 59
    /               shift and go to state 63
    <               shift and go to state 57
    LE              shift and go to state 62
    =               shift and go to state 58
    DOT             shift and go to state 56
    @               shift and go to state 61


state 72

    (32) expr -> ~ expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 32 (expr -> ~ expr .)
    +               reduce using rule 32 (expr -> ~ expr .)
    -               reduce using rule 32 (expr -> ~ expr .)
    *               reduce using rule 32 (expr -> ~ expr .)
    /               reduce using rule 32 (expr -> ~ expr .)
    <               reduce using rule 32 (expr -> ~ expr .)
    LE              reduce using rule 32 (expr -> ~ expr .)
    =               reduce using rule 32 (expr -> ~ expr .)
    )               reduce using rule 32 (expr -> ~ expr .)
    ;               reduce using rule 32 (expr -> ~ expr .)
    IN              reduce using rule 32 (expr -> ~ expr .)
    OF              reduce using rule 32 (expr -> ~ expr .)
    THEN            reduce using rule 32 (expr -> ~ expr .)
    LOOP            reduce using rule 32 (expr -> ~ expr .)
    ELSE            reduce using rule 32 (expr -> ~ expr .)
    POOL            reduce using rule 32 (expr -> ~ expr .)
    FI              reduce using rule 32 (expr -> ~ expr .)
    }               reduce using rule 32 (expr -> ~ expr .)
    DOT             shift and go to state 56
    @               shift and go to state 61

  ! DOT             [ reduce using rule 32 (expr -> ~ expr .) ]
  ! @               [ reduce using rule 32 (expr -> ~ expr .) ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 55 ]
  ! *               [ shift and go to state 59 ]
  ! /               [ shift and go to state 63 ]
  ! <               [ shift and go to state 57 ]
  ! LE              [ shift and go to state 62 ]
  ! =               [ shift and go to state 58 ]


state 73

    (29) expr -> NEW TYPEID .

    ,               reduce using rule 29 (expr -> NEW TYPEID .)
    +               reduce using rule 29 (expr -> NEW TYPEID .)
    -               reduce using rule 29 (expr -> NEW TYPEID .)
    *               reduce using rule 29 (expr -> NEW TYPEID .)
    /               reduce using rule 29 (expr -> NEW TYPEID .)
    <               reduce using rule 29 (expr -> NEW TYPEID .)
    LE              reduce using rule 29 (expr -> NEW TYPEID .)
    =               reduce using rule 29 (expr -> NEW TYPEID .)
    DOT             reduce using rule 29 (expr -> NEW TYPEID .)
    @               reduce using rule 29 (expr -> NEW TYPEID .)
    )               reduce using rule 29 (expr -> NEW TYPEID .)
    ;               reduce using rule 29 (expr -> NEW TYPEID .)
    IN              reduce using rule 29 (expr -> NEW TYPEID .)
    OF              reduce using rule 29 (expr -> NEW TYPEID .)
    THEN            reduce using rule 29 (expr -> NEW TYPEID .)
    LOOP            reduce using rule 29 (expr -> NEW TYPEID .)
    ELSE            reduce using rule 29 (expr -> NEW TYPEID .)
    POOL            reduce using rule 29 (expr -> NEW TYPEID .)
    FI              reduce using rule 29 (expr -> NEW TYPEID .)
    }               reduce using rule 29 (expr -> NEW TYPEID .)


state 74

    (51) whileloop -> WHILE expr . LOOP expr POOL
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    LOOP            shift and go to state 95
    +               shift and go to state 60
    -               shift and go to state 55
    *               shift and go to state 59
    /               shift and go to state 63
    <               shift and go to state 57
    LE              shift and go to state 62
    =               shift and go to state 58
    DOT             shift and go to state 56
    @               shift and go to state 61


state 75

    (33) expr -> ( expr . )
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    )               shift and go to state 96
    +               shift and go to state 60
    -               shift and go to state 55
    *               shift and go to state 59
    /               shift and go to state 63
    <               shift and go to state 57
    LE              shift and go to state 62
    =               shift and go to state 58
    DOT             shift and go to state 56
    @               shift and go to state 61


state 76

    (49) localmethodinvoke -> OBJECTID ( . actualargs )
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 97
    letexpr                        shift and go to state 28
    empty                          shift and go to state 99
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    actualargs                     shift and go to state 98
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 77

    (45) assignment -> OBJECTID ASSIGN . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 100
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 78

    (15) formalargs -> variabledeclaration , . formalargs
    (15) formalargs -> . variabledeclaration , formalargs
    (16) formalargs -> . variabledeclaration
    (17) formalargs -> . empty
    (12) variabledeclaration -> . OBJECTID : TYPEID
    (60) empty -> .

    OBJECTID        shift and go to state 53
    )               reduce using rule 60 (empty -> .)

    empty                          shift and go to state 52
    variabledeclaration            shift and go to state 50
    formalargs                     shift and go to state 101

state 79

    (10) methoddefinition -> OBJECTID ( formalargs ) . : TYPEID { expr }

    :               shift and go to state 102


state 80

    (35) expr -> expr - expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 35 (expr -> expr - expr .)
    +               reduce using rule 35 (expr -> expr - expr .)
    -               reduce using rule 35 (expr -> expr - expr .)
    <               reduce using rule 35 (expr -> expr - expr .)
    LE              reduce using rule 35 (expr -> expr - expr .)
    =               reduce using rule 35 (expr -> expr - expr .)
    )               reduce using rule 35 (expr -> expr - expr .)
    ;               reduce using rule 35 (expr -> expr - expr .)
    IN              reduce using rule 35 (expr -> expr - expr .)
    OF              reduce using rule 35 (expr -> expr - expr .)
    THEN            reduce using rule 35 (expr -> expr - expr .)
    LOOP            reduce using rule 35 (expr -> expr - expr .)
    ELSE            reduce using rule 35 (expr -> expr - expr .)
    POOL            reduce using rule 35 (expr -> expr - expr .)
    FI              reduce using rule 35 (expr -> expr - expr .)
    }               reduce using rule 35 (expr -> expr - expr .)
    *               shift and go to state 59
    /               shift and go to state 63
    DOT             shift and go to state 56
    @               shift and go to state 61

  ! *               [ reduce using rule 35 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 35 (expr -> expr - expr .) ]
  ! DOT             [ reduce using rule 35 (expr -> expr - expr .) ]
  ! @               [ reduce using rule 35 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 55 ]
  ! <               [ shift and go to state 57 ]
  ! LE              [ shift and go to state 62 ]
  ! =               [ shift and go to state 58 ]


state 81

    (47) methodinvoke -> expr DOT OBJECTID . ( actualargs )

    (               shift and go to state 103


state 82

    (38) expr -> expr < expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 38 (expr -> expr < expr .)
    <               reduce using rule 38 (expr -> expr < expr .)
    LE              reduce using rule 38 (expr -> expr < expr .)
    =               reduce using rule 38 (expr -> expr < expr .)
    )               reduce using rule 38 (expr -> expr < expr .)
    ;               reduce using rule 38 (expr -> expr < expr .)
    IN              reduce using rule 38 (expr -> expr < expr .)
    OF              reduce using rule 38 (expr -> expr < expr .)
    THEN            reduce using rule 38 (expr -> expr < expr .)
    LOOP            reduce using rule 38 (expr -> expr < expr .)
    ELSE            reduce using rule 38 (expr -> expr < expr .)
    POOL            reduce using rule 38 (expr -> expr < expr .)
    FI              reduce using rule 38 (expr -> expr < expr .)
    }               reduce using rule 38 (expr -> expr < expr .)
    +               shift and go to state 60
    -               shift and go to state 55
    *               shift and go to state 59
    /               shift and go to state 63
    DOT             shift and go to state 56
    @               shift and go to state 61

  ! +               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! DOT             [ reduce using rule 38 (expr -> expr < expr .) ]
  ! @               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! <               [ shift and go to state 57 ]
  ! LE              [ shift and go to state 62 ]
  ! =               [ shift and go to state 58 ]


state 83

    (40) expr -> expr = expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 40 (expr -> expr = expr .)
    <               reduce using rule 40 (expr -> expr = expr .)
    LE              reduce using rule 40 (expr -> expr = expr .)
    =               reduce using rule 40 (expr -> expr = expr .)
    )               reduce using rule 40 (expr -> expr = expr .)
    ;               reduce using rule 40 (expr -> expr = expr .)
    IN              reduce using rule 40 (expr -> expr = expr .)
    OF              reduce using rule 40 (expr -> expr = expr .)
    THEN            reduce using rule 40 (expr -> expr = expr .)
    LOOP            reduce using rule 40 (expr -> expr = expr .)
    ELSE            reduce using rule 40 (expr -> expr = expr .)
    POOL            reduce using rule 40 (expr -> expr = expr .)
    FI              reduce using rule 40 (expr -> expr = expr .)
    }               reduce using rule 40 (expr -> expr = expr .)
    +               shift and go to state 60
    -               shift and go to state 55
    *               shift and go to state 59
    /               shift and go to state 63
    DOT             shift and go to state 56
    @               shift and go to state 61

  ! +               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! -               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! *               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! /               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! DOT             [ reduce using rule 40 (expr -> expr = expr .) ]
  ! @               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! <               [ shift and go to state 57 ]
  ! LE              [ shift and go to state 62 ]
  ! =               [ shift and go to state 58 ]


state 84

    (36) expr -> expr * expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 36 (expr -> expr * expr .)
    +               reduce using rule 36 (expr -> expr * expr .)
    -               reduce using rule 36 (expr -> expr * expr .)
    *               reduce using rule 36 (expr -> expr * expr .)
    /               reduce using rule 36 (expr -> expr * expr .)
    <               reduce using rule 36 (expr -> expr * expr .)
    LE              reduce using rule 36 (expr -> expr * expr .)
    =               reduce using rule 36 (expr -> expr * expr .)
    )               reduce using rule 36 (expr -> expr * expr .)
    ;               reduce using rule 36 (expr -> expr * expr .)
    IN              reduce using rule 36 (expr -> expr * expr .)
    OF              reduce using rule 36 (expr -> expr * expr .)
    THEN            reduce using rule 36 (expr -> expr * expr .)
    LOOP            reduce using rule 36 (expr -> expr * expr .)
    ELSE            reduce using rule 36 (expr -> expr * expr .)
    POOL            reduce using rule 36 (expr -> expr * expr .)
    FI              reduce using rule 36 (expr -> expr * expr .)
    }               reduce using rule 36 (expr -> expr * expr .)
    DOT             shift and go to state 56
    @               shift and go to state 61

  ! DOT             [ reduce using rule 36 (expr -> expr * expr .) ]
  ! @               [ reduce using rule 36 (expr -> expr * expr .) ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 55 ]
  ! *               [ shift and go to state 59 ]
  ! /               [ shift and go to state 63 ]
  ! <               [ shift and go to state 57 ]
  ! LE              [ shift and go to state 62 ]
  ! =               [ shift and go to state 58 ]


state 85

    (34) expr -> expr + expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 34 (expr -> expr + expr .)
    +               reduce using rule 34 (expr -> expr + expr .)
    -               reduce using rule 34 (expr -> expr + expr .)
    <               reduce using rule 34 (expr -> expr + expr .)
    LE              reduce using rule 34 (expr -> expr + expr .)
    =               reduce using rule 34 (expr -> expr + expr .)
    )               reduce using rule 34 (expr -> expr + expr .)
    ;               reduce using rule 34 (expr -> expr + expr .)
    IN              reduce using rule 34 (expr -> expr + expr .)
    OF              reduce using rule 34 (expr -> expr + expr .)
    THEN            reduce using rule 34 (expr -> expr + expr .)
    LOOP            reduce using rule 34 (expr -> expr + expr .)
    ELSE            reduce using rule 34 (expr -> expr + expr .)
    POOL            reduce using rule 34 (expr -> expr + expr .)
    FI              reduce using rule 34 (expr -> expr + expr .)
    }               reduce using rule 34 (expr -> expr + expr .)
    *               shift and go to state 59
    /               shift and go to state 63
    DOT             shift and go to state 56
    @               shift and go to state 61

  ! *               [ reduce using rule 34 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 34 (expr -> expr + expr .) ]
  ! DOT             [ reduce using rule 34 (expr -> expr + expr .) ]
  ! @               [ reduce using rule 34 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 55 ]
  ! <               [ shift and go to state 57 ]
  ! LE              [ shift and go to state 62 ]
  ! =               [ shift and go to state 58 ]


state 86

    (48) methodinvoke -> expr @ TYPEID . DOT OBJECTID ( actualargs )

    DOT             shift and go to state 104


state 87

    (39) expr -> expr LE expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 39 (expr -> expr LE expr .)
    <               reduce using rule 39 (expr -> expr LE expr .)
    LE              reduce using rule 39 (expr -> expr LE expr .)
    =               reduce using rule 39 (expr -> expr LE expr .)
    )               reduce using rule 39 (expr -> expr LE expr .)
    ;               reduce using rule 39 (expr -> expr LE expr .)
    IN              reduce using rule 39 (expr -> expr LE expr .)
    OF              reduce using rule 39 (expr -> expr LE expr .)
    THEN            reduce using rule 39 (expr -> expr LE expr .)
    LOOP            reduce using rule 39 (expr -> expr LE expr .)
    ELSE            reduce using rule 39 (expr -> expr LE expr .)
    POOL            reduce using rule 39 (expr -> expr LE expr .)
    FI              reduce using rule 39 (expr -> expr LE expr .)
    }               reduce using rule 39 (expr -> expr LE expr .)
    +               shift and go to state 60
    -               shift and go to state 55
    *               shift and go to state 59
    /               shift and go to state 63
    DOT             shift and go to state 56
    @               shift and go to state 61

  ! +               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! -               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! *               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! /               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! DOT             [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! @               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! <               [ shift and go to state 57 ]
  ! LE              [ shift and go to state 62 ]
  ! =               [ shift and go to state 58 ]


state 88

    (37) expr -> expr / expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 37 (expr -> expr / expr .)
    +               reduce using rule 37 (expr -> expr / expr .)
    -               reduce using rule 37 (expr -> expr / expr .)
    *               reduce using rule 37 (expr -> expr / expr .)
    /               reduce using rule 37 (expr -> expr / expr .)
    <               reduce using rule 37 (expr -> expr / expr .)
    LE              reduce using rule 37 (expr -> expr / expr .)
    =               reduce using rule 37 (expr -> expr / expr .)
    )               reduce using rule 37 (expr -> expr / expr .)
    ;               reduce using rule 37 (expr -> expr / expr .)
    IN              reduce using rule 37 (expr -> expr / expr .)
    OF              reduce using rule 37 (expr -> expr / expr .)
    THEN            reduce using rule 37 (expr -> expr / expr .)
    LOOP            reduce using rule 37 (expr -> expr / expr .)
    ELSE            reduce using rule 37 (expr -> expr / expr .)
    POOL            reduce using rule 37 (expr -> expr / expr .)
    FI              reduce using rule 37 (expr -> expr / expr .)
    }               reduce using rule 37 (expr -> expr / expr .)
    DOT             shift and go to state 56
    @               shift and go to state 61

  ! DOT             [ reduce using rule 37 (expr -> expr / expr .) ]
  ! @               [ reduce using rule 37 (expr -> expr / expr .) ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 55 ]
  ! *               [ shift and go to state 59 ]
  ! /               [ shift and go to state 63 ]
  ! <               [ shift and go to state 57 ]
  ! LE              [ shift and go to state 62 ]
  ! =               [ shift and go to state 58 ]


state 89

    (57) caseexpr -> CASE expr OF . casestatements ESAC
    (58) casestatements -> . variabledeclaration DARROW expr ; casestatements
    (59) casestatements -> . variabledeclaration DARROW expr ;
    (12) variabledeclaration -> . OBJECTID : TYPEID

    OBJECTID        shift and go to state 53

    variabledeclaration            shift and go to state 105
    casestatements                 shift and go to state 106

state 90

    (46) letexpr -> LET variablelist IN . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 107
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 91

    (55) variablelist -> variabledefinition , . variablelist
    (55) variablelist -> . variabledefinition , variablelist
    (56) variablelist -> . variabledefinition
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (12) variabledeclaration -> . OBJECTID : TYPEID

    OBJECTID        shift and go to state 53

    variablelist                   shift and go to state 108
    variabledeclaration            shift and go to state 17
    variabledefinition             shift and go to state 67

state 92

    (53) blockstatements -> expr ; . blockstatements
    (54) blockstatements -> expr ; .
    (53) blockstatements -> . expr ; blockstatements
    (54) blockstatements -> . expr ;
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    }               reduce using rule 54 (blockstatements -> expr ; .)
    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 69
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    blockstatements                shift and go to state 109
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 93

    (52) blockexpr -> { blockstatements } .

    ;               reduce using rule 52 (blockexpr -> { blockstatements } .)
    +               reduce using rule 52 (blockexpr -> { blockstatements } .)
    -               reduce using rule 52 (blockexpr -> { blockstatements } .)
    *               reduce using rule 52 (blockexpr -> { blockstatements } .)
    /               reduce using rule 52 (blockexpr -> { blockstatements } .)
    <               reduce using rule 52 (blockexpr -> { blockstatements } .)
    LE              reduce using rule 52 (blockexpr -> { blockstatements } .)
    =               reduce using rule 52 (blockexpr -> { blockstatements } .)
    DOT             reduce using rule 52 (blockexpr -> { blockstatements } .)
    @               reduce using rule 52 (blockexpr -> { blockstatements } .)
    ,               reduce using rule 52 (blockexpr -> { blockstatements } .)
    IN              reduce using rule 52 (blockexpr -> { blockstatements } .)
    OF              reduce using rule 52 (blockexpr -> { blockstatements } .)
    THEN            reduce using rule 52 (blockexpr -> { blockstatements } .)
    LOOP            reduce using rule 52 (blockexpr -> { blockstatements } .)
    )               reduce using rule 52 (blockexpr -> { blockstatements } .)
    ELSE            reduce using rule 52 (blockexpr -> { blockstatements } .)
    POOL            reduce using rule 52 (blockexpr -> { blockstatements } .)
    FI              reduce using rule 52 (blockexpr -> { blockstatements } .)
    }               reduce using rule 52 (blockexpr -> { blockstatements } .)


state 94

    (50) ifthenelse -> IF expr THEN . expr ELSE expr FI
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 110
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 95

    (51) whileloop -> WHILE expr LOOP . expr POOL
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 111
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 96

    (33) expr -> ( expr ) .

    ,               reduce using rule 33 (expr -> ( expr ) .)
    +               reduce using rule 33 (expr -> ( expr ) .)
    -               reduce using rule 33 (expr -> ( expr ) .)
    *               reduce using rule 33 (expr -> ( expr ) .)
    /               reduce using rule 33 (expr -> ( expr ) .)
    <               reduce using rule 33 (expr -> ( expr ) .)
    LE              reduce using rule 33 (expr -> ( expr ) .)
    =               reduce using rule 33 (expr -> ( expr ) .)
    DOT             reduce using rule 33 (expr -> ( expr ) .)
    @               reduce using rule 33 (expr -> ( expr ) .)
    )               reduce using rule 33 (expr -> ( expr ) .)
    ;               reduce using rule 33 (expr -> ( expr ) .)
    IN              reduce using rule 33 (expr -> ( expr ) .)
    OF              reduce using rule 33 (expr -> ( expr ) .)
    THEN            reduce using rule 33 (expr -> ( expr ) .)
    LOOP            reduce using rule 33 (expr -> ( expr ) .)
    ELSE            reduce using rule 33 (expr -> ( expr ) .)
    POOL            reduce using rule 33 (expr -> ( expr ) .)
    FI              reduce using rule 33 (expr -> ( expr ) .)
    }               reduce using rule 33 (expr -> ( expr ) .)


state 97

    (18) actualargs -> expr . , actualargs
    (19) actualargs -> expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               shift and go to state 112
    )               reduce using rule 19 (actualargs -> expr .)
    +               shift and go to state 60
    -               shift and go to state 55
    *               shift and go to state 59
    /               shift and go to state 63
    <               shift and go to state 57
    LE              shift and go to state 62
    =               shift and go to state 58
    DOT             shift and go to state 56
    @               shift and go to state 61


state 98

    (49) localmethodinvoke -> OBJECTID ( actualargs . )

    )               shift and go to state 113


state 99

    (20) actualargs -> empty .

    )               reduce using rule 20 (actualargs -> empty .)


state 100

    (45) assignment -> OBJECTID ASSIGN expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    THEN            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    ,               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    )               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    OF              reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    ;               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    LOOP            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    IN              reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    ELSE            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    POOL            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    FI              reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    }               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    +               shift and go to state 60
    -               shift and go to state 55
    *               shift and go to state 59
    /               shift and go to state 63
    <               shift and go to state 57
    LE              shift and go to state 62
    =               shift and go to state 58
    DOT             shift and go to state 56
    @               shift and go to state 61

  ! +               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! -               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! *               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! /               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! <               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! LE              [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! =               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! DOT             [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! @               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]


state 101

    (15) formalargs -> variabledeclaration , formalargs .

    )               reduce using rule 15 (formalargs -> variabledeclaration , formalargs .)


state 102

    (10) methoddefinition -> OBJECTID ( formalargs ) : . TYPEID { expr }

    TYPEID          shift and go to state 114


state 103

    (47) methodinvoke -> expr DOT OBJECTID ( . actualargs )
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 97
    letexpr                        shift and go to state 28
    empty                          shift and go to state 99
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    actualargs                     shift and go to state 115
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 104

    (48) methodinvoke -> expr @ TYPEID DOT . OBJECTID ( actualargs )

    OBJECTID        shift and go to state 116


state 105

    (58) casestatements -> variabledeclaration . DARROW expr ; casestatements
    (59) casestatements -> variabledeclaration . DARROW expr ;

    DARROW          shift and go to state 117


state 106

    (57) caseexpr -> CASE expr OF casestatements . ESAC

    ESAC            shift and go to state 118


state 107

    (46) letexpr -> LET variablelist IN expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    ,               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    IN              reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    OF              reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    THEN            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    LOOP            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    )               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    ELSE            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    POOL            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    FI              reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    }               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    +               shift and go to state 60
    -               shift and go to state 55
    *               shift and go to state 59
    /               shift and go to state 63
    <               shift and go to state 57
    LE              shift and go to state 62
    =               shift and go to state 58
    DOT             shift and go to state 56
    @               shift and go to state 61

  ! +               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! -               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! *               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! /               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! <               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! LE              [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! =               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! DOT             [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! @               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]


state 108

    (55) variablelist -> variabledefinition , variablelist .

    IN              reduce using rule 55 (variablelist -> variabledefinition , variablelist .)


state 109

    (53) blockstatements -> expr ; blockstatements .

    }               reduce using rule 53 (blockstatements -> expr ; blockstatements .)


state 110

    (50) ifthenelse -> IF expr THEN expr . ELSE expr FI
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ELSE            shift and go to state 119
    +               shift and go to state 60
    -               shift and go to state 55
    *               shift and go to state 59
    /               shift and go to state 63
    <               shift and go to state 57
    LE              shift and go to state 62
    =               shift and go to state 58
    DOT             shift and go to state 56
    @               shift and go to state 61


state 111

    (51) whileloop -> WHILE expr LOOP expr . POOL
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    POOL            shift and go to state 120
    +               shift and go to state 60
    -               shift and go to state 55
    *               shift and go to state 59
    /               shift and go to state 63
    <               shift and go to state 57
    LE              shift and go to state 62
    =               shift and go to state 58
    DOT             shift and go to state 56
    @               shift and go to state 61


state 112

    (18) actualargs -> expr , . actualargs
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 97
    letexpr                        shift and go to state 28
    empty                          shift and go to state 99
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    actualargs                     shift and go to state 121
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 113

    (49) localmethodinvoke -> OBJECTID ( actualargs ) .

    }               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    +               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    -               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    *               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    /               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    <               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    LE              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    =               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    DOT             reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    @               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    ;               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    ,               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    IN              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    OF              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    THEN            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    LOOP            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    )               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    ELSE            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    POOL            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    FI              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)


state 114

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID . { expr }

    {               shift and go to state 122


state 115

    (47) methodinvoke -> expr DOT OBJECTID ( actualargs . )

    )               shift and go to state 123


state 116

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID . ( actualargs )

    (               shift and go to state 124


state 117

    (58) casestatements -> variabledeclaration DARROW . expr ; casestatements
    (59) casestatements -> variabledeclaration DARROW . expr ;
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 125
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 118

    (57) caseexpr -> CASE expr OF casestatements ESAC .

    ;               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    +               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    -               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    *               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    /               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    <               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    LE              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    =               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    DOT             reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    @               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    ,               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    IN              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    OF              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    THEN            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    LOOP            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    )               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    ELSE            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    POOL            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    FI              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    }               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)


state 119

    (50) ifthenelse -> IF expr THEN expr ELSE . expr FI
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 126
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 120

    (51) whileloop -> WHILE expr LOOP expr POOL .

    +               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    -               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    *               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    /               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    <               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    LE              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    =               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    DOT             reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    @               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    ;               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    ,               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    IN              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    OF              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    THEN            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    LOOP            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    )               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    ELSE            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    POOL            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    FI              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    }               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)


state 121

    (18) actualargs -> expr , actualargs .

    )               reduce using rule 18 (actualargs -> expr , actualargs .)


state 122

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID { . expr }
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 127
    letexpr                        shift and go to state 28
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 123

    (47) methodinvoke -> expr DOT OBJECTID ( actualargs ) .

    LOOP            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    +               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    -               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    *               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    /               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    <               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    LE              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    =               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    DOT             reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    @               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    POOL            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    ;               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    ,               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    IN              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    OF              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    THEN            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    )               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    ELSE            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    FI              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    }               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)


state 124

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID ( . actualargs )
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 41
    ISVOID          shift and go to state 35
    NOT             shift and go to state 31
    ~               shift and go to state 40
    (               shift and go to state 48
    INT_CONST       shift and go to state 30
    STR_CONST       shift and go to state 46
    BOOL_CONST      shift and go to state 32
    OBJECTID        shift and go to state 49
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 37
    WHILE           shift and go to state 47
    {               shift and go to state 36
    LET             shift and go to state 34
    CASE            shift and go to state 29

    expr                           shift and go to state 97
    letexpr                        shift and go to state 28
    empty                          shift and go to state 99
    assignment                     shift and go to state 33
    blockexpr                      shift and go to state 45
    whileloop                      shift and go to state 42
    actualargs                     shift and go to state 128
    caseexpr                       shift and go to state 44
    methodinvoke                   shift and go to state 43
    localmethodinvoke              shift and go to state 39
    ifthenelse                     shift and go to state 38

state 125

    (58) casestatements -> variabledeclaration DARROW expr . ; casestatements
    (59) casestatements -> variabledeclaration DARROW expr . ;
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               shift and go to state 129
    +               shift and go to state 60
    -               shift and go to state 55
    *               shift and go to state 59
    /               shift and go to state 63
    <               shift and go to state 57
    LE              shift and go to state 62
    =               shift and go to state 58
    DOT             shift and go to state 56
    @               shift and go to state 61


state 126

    (50) ifthenelse -> IF expr THEN expr ELSE expr . FI
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    FI              shift and go to state 130
    +               shift and go to state 60
    -               shift and go to state 55
    *               shift and go to state 59
    /               shift and go to state 63
    <               shift and go to state 57
    LE              shift and go to state 62
    =               shift and go to state 58
    DOT             shift and go to state 56
    @               shift and go to state 61


state 127

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr . }
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    }               shift and go to state 131
    +               shift and go to state 60
    -               shift and go to state 55
    *               shift and go to state 59
    /               shift and go to state 63
    <               shift and go to state 57
    LE              shift and go to state 62
    =               shift and go to state 58
    DOT             shift and go to state 56
    @               shift and go to state 61


state 128

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs . )

    )               shift and go to state 132


state 129

    (58) casestatements -> variabledeclaration DARROW expr ; . casestatements
    (59) casestatements -> variabledeclaration DARROW expr ; .
    (58) casestatements -> . variabledeclaration DARROW expr ; casestatements
    (59) casestatements -> . variabledeclaration DARROW expr ;
    (12) variabledeclaration -> . OBJECTID : TYPEID

    ESAC            reduce using rule 59 (casestatements -> variabledeclaration DARROW expr ; .)
    OBJECTID        shift and go to state 53

    variabledeclaration            shift and go to state 105
    casestatements                 shift and go to state 133

state 130

    (50) ifthenelse -> IF expr THEN expr ELSE expr FI .

    THEN            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    +               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    -               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    *               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    /               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    <               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    LE              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    =               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    DOT             reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    @               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    ;               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    ,               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    IN              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    OF              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    LOOP            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    )               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    ELSE            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    POOL            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    FI              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    }               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)


state 131

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr } .

    ;               reduce using rule 10 (methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr } .)


state 132

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .

    LOOP            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    +               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    -               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    *               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    /               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    <               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    LE              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    =               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    DOT             reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    @               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    POOL            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    ;               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    ,               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    IN              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    OF              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    THEN            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    )               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    ELSE            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    FI              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    }               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)


state 133

    (58) casestatements -> variabledeclaration DARROW expr ; casestatements .

    ESAC            reduce using rule 58 (casestatements -> variabledeclaration DARROW expr ; casestatements .)

