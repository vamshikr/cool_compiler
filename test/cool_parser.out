Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT_MULTILINE
    COMMENT_SINGLELINE
    NEWLINE

Grammar

Rule 0     S' -> program
Rule 1     program -> class ; program
Rule 2     program -> class ;
Rule 3     class -> CLASS TYPEID baseclass { features }
Rule 4     baseclass -> INHERITS TYPEID
Rule 5     baseclass -> empty
Rule 6     features -> feature ; features
Rule 7     features -> empty
Rule 8     feature -> variabledefinition
Rule 9     feature -> methoddefinition
Rule 10    methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr }
Rule 11    variabledefinition -> variabledeclaration variableinitialization
Rule 12    variabledeclaration -> OBJECTID : TYPEID
Rule 13    variableinitialization -> ASSIGN expr
Rule 14    variableinitialization -> empty
Rule 15    formalargs -> variabledeclaration , formalargs
Rule 16    formalargs -> variabledeclaration
Rule 17    formalargs -> empty
Rule 18    actualargs -> expr , actualargs
Rule 19    actualargs -> expr
Rule 20    actualargs -> empty
Rule 21    expr -> assignment
Rule 22    expr -> methodinvoke
Rule 23    expr -> localmethodinvoke
Rule 24    expr -> ifthenelse
Rule 25    expr -> whileloop
Rule 26    expr -> blockexpr
Rule 27    expr -> letexpr
Rule 28    expr -> caseexpr
Rule 29    expr -> NEW TYPEID
Rule 30    expr -> ISVOID expr
Rule 31    expr -> NOT expr
Rule 32    expr -> ~ expr
Rule 33    expr -> ( expr )
Rule 34    expr -> expr + expr
Rule 35    expr -> expr - expr
Rule 36    expr -> expr * expr
Rule 37    expr -> expr / expr
Rule 38    expr -> expr < expr
Rule 39    expr -> expr LE expr
Rule 40    expr -> expr = expr
Rule 41    expr -> INT_CONST
Rule 42    expr -> STR_CONST
Rule 43    expr -> BOOL_CONST
Rule 44    expr -> OBJECTID
Rule 45    assignment -> OBJECTID ASSIGN expr
Rule 46    letexpr -> LET variablelist IN expr
Rule 47    methodinvoke -> expr DOT OBJECTID ( actualargs )
Rule 48    methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs )
Rule 49    localmethodinvoke -> OBJECTID ( actualargs )
Rule 50    ifthenelse -> IF expr THEN expr ELSE expr FI
Rule 51    whileloop -> WHILE expr LOOP expr POOL
Rule 52    blockexpr -> { blockstatements }
Rule 53    blockstatements -> expr ; blockstatements
Rule 54    blockstatements -> expr ;
Rule 55    variablelist -> variabledefinition , variablelist
Rule 56    variablelist -> variabledefinition
Rule 57    caseexpr -> CASE expr OF casestatements ESAC
Rule 58    casestatements -> variabledeclaration DARROW expr ; casestatements
Rule 59    casestatements -> variabledeclaration DARROW expr ;
Rule 60    empty -> <empty>

Terminals, with rules where they appear

(                    : 10 33 47 48 49
)                    : 10 33 47 48 49
*                    : 36
+                    : 34
,                    : 15 18 55
-                    : 35
/                    : 37
:                    : 10 12
;                    : 1 2 6 53 54 58 59
<                    : 38
=                    : 40
@                    : 48
ASSIGN               : 13 45
BOOL_CONST           : 43
CASE                 : 57
CLASS                : 3
COMMENT_MULTILINE    : 
COMMENT_SINGLELINE   : 
DARROW               : 58 59
DOT                  : 47 48
ELSE                 : 50
ESAC                 : 57
FI                   : 50
IF                   : 50
IN                   : 46
INHERITS             : 4
INT_CONST            : 41
ISVOID               : 30
LE                   : 39
LET                  : 46
LOOP                 : 51
NEW                  : 29
NEWLINE              : 
NOT                  : 31
OBJECTID             : 10 12 44 45 47 48 49
OF                   : 57
POOL                 : 51
STR_CONST            : 42
THEN                 : 50
TYPEID               : 3 4 10 12 29 48
WHILE                : 51
error                : 
{                    : 3 10 52
}                    : 3 10 52
~                    : 32

Nonterminals, with rules where they appear

actualargs           : 18 47 48 49
assignment           : 21
baseclass            : 3
blockexpr            : 26
blockstatements      : 52 53
caseexpr             : 28
casestatements       : 57 58
class                : 1 2
empty                : 5 7 14 17 20
expr                 : 10 13 18 19 30 31 32 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 45 46 47 48 50 50 50 51 51 53 54 57 58 59
feature              : 6
features             : 3 6
formalargs           : 10 15
ifthenelse           : 24
letexpr              : 27
localmethodinvoke    : 23
methoddefinition     : 9
methodinvoke         : 22
program              : 1 0
variabledeclaration  : 11 15 16 58 59
variabledefinition   : 8 55 56
variableinitialization : 11
variablelist         : 46 55
whileloop            : 25

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . class ; program
    (2) program -> . class ;
    (3) class -> . CLASS TYPEID baseclass { features }

    CLASS           shift and go to state 1

    program                        shift and go to state 3
    class                          shift and go to state 2

state 1

    (3) class -> CLASS . TYPEID baseclass { features }

    TYPEID          shift and go to state 4


state 2

    (1) program -> class . ; program
    (2) program -> class . ;

    ;               shift and go to state 5


state 3

    (0) S' -> program .



state 4

    (3) class -> CLASS TYPEID . baseclass { features }
    (4) baseclass -> . INHERITS TYPEID
    (5) baseclass -> . empty
    (60) empty -> .

    INHERITS        shift and go to state 6
    {               reduce using rule 60 (empty -> .)

    empty                          shift and go to state 8
    baseclass                      shift and go to state 7

state 5

    (1) program -> class ; . program
    (2) program -> class ; .
    (1) program -> . class ; program
    (2) program -> . class ;
    (3) class -> . CLASS TYPEID baseclass { features }

    $end            reduce using rule 2 (program -> class ; .)
    CLASS           shift and go to state 1

    program                        shift and go to state 9
    class                          shift and go to state 2

state 6

    (4) baseclass -> INHERITS . TYPEID

    TYPEID          shift and go to state 10


state 7

    (3) class -> CLASS TYPEID baseclass . { features }

    {               shift and go to state 11


state 8

    (5) baseclass -> empty .

    {               reduce using rule 5 (baseclass -> empty .)


state 9

    (1) program -> class ; program .

    $end            reduce using rule 1 (program -> class ; program .)


state 10

    (4) baseclass -> INHERITS TYPEID .

    {               reduce using rule 4 (baseclass -> INHERITS TYPEID .)


state 11

    (3) class -> CLASS TYPEID baseclass { . features }
    (6) features -> . feature ; features
    (7) features -> . empty
    (8) feature -> . variabledefinition
    (9) feature -> . methoddefinition
    (60) empty -> .
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (10) methoddefinition -> . OBJECTID ( formalargs ) : TYPEID { expr }
    (12) variabledeclaration -> . OBJECTID : TYPEID

    }               reduce using rule 60 (empty -> .)
    OBJECTID        shift and go to state 13

    variabledeclaration            shift and go to state 16
    feature                        shift and go to state 12
    empty                          shift and go to state 17
    variabledefinition             shift and go to state 14
    methoddefinition               shift and go to state 15
    features                       shift and go to state 18

state 12

    (6) features -> feature . ; features

    ;               shift and go to state 19


state 13

    (10) methoddefinition -> OBJECTID . ( formalargs ) : TYPEID { expr }
    (12) variabledeclaration -> OBJECTID . : TYPEID

    (               shift and go to state 21
    :               shift and go to state 20


state 14

    (8) feature -> variabledefinition .

    ;               reduce using rule 8 (feature -> variabledefinition .)


state 15

    (9) feature -> methoddefinition .

    ;               reduce using rule 9 (feature -> methoddefinition .)


state 16

    (11) variabledefinition -> variabledeclaration . variableinitialization
    (13) variableinitialization -> . ASSIGN expr
    (14) variableinitialization -> . empty
    (60) empty -> .

    ASSIGN          shift and go to state 23
    ;               reduce using rule 60 (empty -> .)
    ,               reduce using rule 60 (empty -> .)
    IN              reduce using rule 60 (empty -> .)

    variableinitialization         shift and go to state 22
    empty                          shift and go to state 24

state 17

    (7) features -> empty .

    }               reduce using rule 7 (features -> empty .)


state 18

    (3) class -> CLASS TYPEID baseclass { features . }

    }               shift and go to state 25


state 19

    (6) features -> feature ; . features
    (6) features -> . feature ; features
    (7) features -> . empty
    (8) feature -> . variabledefinition
    (9) feature -> . methoddefinition
    (60) empty -> .
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (10) methoddefinition -> . OBJECTID ( formalargs ) : TYPEID { expr }
    (12) variabledeclaration -> . OBJECTID : TYPEID

    }               reduce using rule 60 (empty -> .)
    OBJECTID        shift and go to state 13

    variabledeclaration            shift and go to state 16
    feature                        shift and go to state 12
    variabledefinition             shift and go to state 14
    empty                          shift and go to state 17
    methoddefinition               shift and go to state 15
    features                       shift and go to state 26

state 20

    (12) variabledeclaration -> OBJECTID : . TYPEID

    TYPEID          shift and go to state 27


state 21

    (10) methoddefinition -> OBJECTID ( . formalargs ) : TYPEID { expr }
    (15) formalargs -> . variabledeclaration , formalargs
    (16) formalargs -> . variabledeclaration
    (17) formalargs -> . empty
    (12) variabledeclaration -> . OBJECTID : TYPEID
    (60) empty -> .

    OBJECTID        shift and go to state 30
    )               reduce using rule 60 (empty -> .)

    variabledeclaration            shift and go to state 29
    formalargs                     shift and go to state 28
    empty                          shift and go to state 31

state 22

    (11) variabledefinition -> variabledeclaration variableinitialization .

    ;               reduce using rule 11 (variabledefinition -> variabledeclaration variableinitialization .)
    ,               reduce using rule 11 (variabledefinition -> variabledeclaration variableinitialization .)
    IN              reduce using rule 11 (variabledefinition -> variabledeclaration variableinitialization .)


state 23

    (13) variableinitialization -> ASSIGN . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 53
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 24

    (14) variableinitialization -> empty .

    ;               reduce using rule 14 (variableinitialization -> empty .)
    ,               reduce using rule 14 (variableinitialization -> empty .)
    IN              reduce using rule 14 (variableinitialization -> empty .)


state 25

    (3) class -> CLASS TYPEID baseclass { features } .

    ;               reduce using rule 3 (class -> CLASS TYPEID baseclass { features } .)


state 26

    (6) features -> feature ; features .

    }               reduce using rule 6 (features -> feature ; features .)


state 27

    (12) variabledeclaration -> OBJECTID : TYPEID .

    ASSIGN          reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    ;               reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    ,               reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    )               reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    DARROW          reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)
    IN              reduce using rule 12 (variabledeclaration -> OBJECTID : TYPEID .)


state 28

    (10) methoddefinition -> OBJECTID ( formalargs . ) : TYPEID { expr }

    )               shift and go to state 55


state 29

    (15) formalargs -> variabledeclaration . , formalargs
    (16) formalargs -> variabledeclaration .

    ,               shift and go to state 56
    )               reduce using rule 16 (formalargs -> variabledeclaration .)


state 30

    (12) variabledeclaration -> OBJECTID . : TYPEID

    :               shift and go to state 20


state 31

    (17) formalargs -> empty .

    )               reduce using rule 17 (formalargs -> empty .)


state 32

    (50) ifthenelse -> IF . expr THEN expr ELSE expr FI
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 57
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 33

    (33) expr -> ( . expr )
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 58
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 34

    (26) expr -> blockexpr .

    ,               reduce using rule 26 (expr -> blockexpr .)
    +               reduce using rule 26 (expr -> blockexpr .)
    -               reduce using rule 26 (expr -> blockexpr .)
    *               reduce using rule 26 (expr -> blockexpr .)
    /               reduce using rule 26 (expr -> blockexpr .)
    <               reduce using rule 26 (expr -> blockexpr .)
    LE              reduce using rule 26 (expr -> blockexpr .)
    =               reduce using rule 26 (expr -> blockexpr .)
    DOT             reduce using rule 26 (expr -> blockexpr .)
    @               reduce using rule 26 (expr -> blockexpr .)
    )               reduce using rule 26 (expr -> blockexpr .)
    POOL            reduce using rule 26 (expr -> blockexpr .)
    ELSE            reduce using rule 26 (expr -> blockexpr .)
    ;               reduce using rule 26 (expr -> blockexpr .)
    IN              reduce using rule 26 (expr -> blockexpr .)
    THEN            reduce using rule 26 (expr -> blockexpr .)
    OF              reduce using rule 26 (expr -> blockexpr .)
    LOOP            reduce using rule 26 (expr -> blockexpr .)
    }               reduce using rule 26 (expr -> blockexpr .)
    FI              reduce using rule 26 (expr -> blockexpr .)


state 35

    (22) expr -> methodinvoke .

    ,               reduce using rule 22 (expr -> methodinvoke .)
    +               reduce using rule 22 (expr -> methodinvoke .)
    -               reduce using rule 22 (expr -> methodinvoke .)
    *               reduce using rule 22 (expr -> methodinvoke .)
    /               reduce using rule 22 (expr -> methodinvoke .)
    <               reduce using rule 22 (expr -> methodinvoke .)
    LE              reduce using rule 22 (expr -> methodinvoke .)
    =               reduce using rule 22 (expr -> methodinvoke .)
    DOT             reduce using rule 22 (expr -> methodinvoke .)
    @               reduce using rule 22 (expr -> methodinvoke .)
    )               reduce using rule 22 (expr -> methodinvoke .)
    POOL            reduce using rule 22 (expr -> methodinvoke .)
    ELSE            reduce using rule 22 (expr -> methodinvoke .)
    ;               reduce using rule 22 (expr -> methodinvoke .)
    IN              reduce using rule 22 (expr -> methodinvoke .)
    THEN            reduce using rule 22 (expr -> methodinvoke .)
    OF              reduce using rule 22 (expr -> methodinvoke .)
    LOOP            reduce using rule 22 (expr -> methodinvoke .)
    }               reduce using rule 22 (expr -> methodinvoke .)
    FI              reduce using rule 22 (expr -> methodinvoke .)


state 36

    (32) expr -> ~ . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 59
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 37

    (28) expr -> caseexpr .

    ,               reduce using rule 28 (expr -> caseexpr .)
    +               reduce using rule 28 (expr -> caseexpr .)
    -               reduce using rule 28 (expr -> caseexpr .)
    *               reduce using rule 28 (expr -> caseexpr .)
    /               reduce using rule 28 (expr -> caseexpr .)
    <               reduce using rule 28 (expr -> caseexpr .)
    LE              reduce using rule 28 (expr -> caseexpr .)
    =               reduce using rule 28 (expr -> caseexpr .)
    DOT             reduce using rule 28 (expr -> caseexpr .)
    @               reduce using rule 28 (expr -> caseexpr .)
    )               reduce using rule 28 (expr -> caseexpr .)
    POOL            reduce using rule 28 (expr -> caseexpr .)
    ELSE            reduce using rule 28 (expr -> caseexpr .)
    ;               reduce using rule 28 (expr -> caseexpr .)
    IN              reduce using rule 28 (expr -> caseexpr .)
    THEN            reduce using rule 28 (expr -> caseexpr .)
    OF              reduce using rule 28 (expr -> caseexpr .)
    LOOP            reduce using rule 28 (expr -> caseexpr .)
    }               reduce using rule 28 (expr -> caseexpr .)
    FI              reduce using rule 28 (expr -> caseexpr .)


state 38

    (21) expr -> assignment .

    ,               reduce using rule 21 (expr -> assignment .)
    +               reduce using rule 21 (expr -> assignment .)
    -               reduce using rule 21 (expr -> assignment .)
    *               reduce using rule 21 (expr -> assignment .)
    /               reduce using rule 21 (expr -> assignment .)
    <               reduce using rule 21 (expr -> assignment .)
    LE              reduce using rule 21 (expr -> assignment .)
    =               reduce using rule 21 (expr -> assignment .)
    DOT             reduce using rule 21 (expr -> assignment .)
    @               reduce using rule 21 (expr -> assignment .)
    )               reduce using rule 21 (expr -> assignment .)
    POOL            reduce using rule 21 (expr -> assignment .)
    ELSE            reduce using rule 21 (expr -> assignment .)
    ;               reduce using rule 21 (expr -> assignment .)
    IN              reduce using rule 21 (expr -> assignment .)
    THEN            reduce using rule 21 (expr -> assignment .)
    OF              reduce using rule 21 (expr -> assignment .)
    LOOP            reduce using rule 21 (expr -> assignment .)
    }               reduce using rule 21 (expr -> assignment .)
    FI              reduce using rule 21 (expr -> assignment .)


state 39

    (57) caseexpr -> CASE . expr OF casestatements ESAC
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    expr                           shift and go to state 60
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 40

    (29) expr -> NEW . TYPEID

    TYPEID          shift and go to state 61


state 41

    (43) expr -> BOOL_CONST .

    ,               reduce using rule 43 (expr -> BOOL_CONST .)
    +               reduce using rule 43 (expr -> BOOL_CONST .)
    -               reduce using rule 43 (expr -> BOOL_CONST .)
    *               reduce using rule 43 (expr -> BOOL_CONST .)
    /               reduce using rule 43 (expr -> BOOL_CONST .)
    <               reduce using rule 43 (expr -> BOOL_CONST .)
    LE              reduce using rule 43 (expr -> BOOL_CONST .)
    =               reduce using rule 43 (expr -> BOOL_CONST .)
    DOT             reduce using rule 43 (expr -> BOOL_CONST .)
    @               reduce using rule 43 (expr -> BOOL_CONST .)
    )               reduce using rule 43 (expr -> BOOL_CONST .)
    POOL            reduce using rule 43 (expr -> BOOL_CONST .)
    ELSE            reduce using rule 43 (expr -> BOOL_CONST .)
    ;               reduce using rule 43 (expr -> BOOL_CONST .)
    IN              reduce using rule 43 (expr -> BOOL_CONST .)
    THEN            reduce using rule 43 (expr -> BOOL_CONST .)
    OF              reduce using rule 43 (expr -> BOOL_CONST .)
    LOOP            reduce using rule 43 (expr -> BOOL_CONST .)
    }               reduce using rule 43 (expr -> BOOL_CONST .)
    FI              reduce using rule 43 (expr -> BOOL_CONST .)


state 42

    (25) expr -> whileloop .

    ,               reduce using rule 25 (expr -> whileloop .)
    +               reduce using rule 25 (expr -> whileloop .)
    -               reduce using rule 25 (expr -> whileloop .)
    *               reduce using rule 25 (expr -> whileloop .)
    /               reduce using rule 25 (expr -> whileloop .)
    <               reduce using rule 25 (expr -> whileloop .)
    LE              reduce using rule 25 (expr -> whileloop .)
    =               reduce using rule 25 (expr -> whileloop .)
    DOT             reduce using rule 25 (expr -> whileloop .)
    @               reduce using rule 25 (expr -> whileloop .)
    )               reduce using rule 25 (expr -> whileloop .)
    POOL            reduce using rule 25 (expr -> whileloop .)
    ELSE            reduce using rule 25 (expr -> whileloop .)
    ;               reduce using rule 25 (expr -> whileloop .)
    IN              reduce using rule 25 (expr -> whileloop .)
    THEN            reduce using rule 25 (expr -> whileloop .)
    OF              reduce using rule 25 (expr -> whileloop .)
    LOOP            reduce using rule 25 (expr -> whileloop .)
    }               reduce using rule 25 (expr -> whileloop .)
    FI              reduce using rule 25 (expr -> whileloop .)


state 43

    (51) whileloop -> WHILE . expr LOOP expr POOL
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 62
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 44

    (41) expr -> INT_CONST .

    ,               reduce using rule 41 (expr -> INT_CONST .)
    +               reduce using rule 41 (expr -> INT_CONST .)
    -               reduce using rule 41 (expr -> INT_CONST .)
    *               reduce using rule 41 (expr -> INT_CONST .)
    /               reduce using rule 41 (expr -> INT_CONST .)
    <               reduce using rule 41 (expr -> INT_CONST .)
    LE              reduce using rule 41 (expr -> INT_CONST .)
    =               reduce using rule 41 (expr -> INT_CONST .)
    DOT             reduce using rule 41 (expr -> INT_CONST .)
    @               reduce using rule 41 (expr -> INT_CONST .)
    )               reduce using rule 41 (expr -> INT_CONST .)
    POOL            reduce using rule 41 (expr -> INT_CONST .)
    ELSE            reduce using rule 41 (expr -> INT_CONST .)
    ;               reduce using rule 41 (expr -> INT_CONST .)
    IN              reduce using rule 41 (expr -> INT_CONST .)
    THEN            reduce using rule 41 (expr -> INT_CONST .)
    OF              reduce using rule 41 (expr -> INT_CONST .)
    LOOP            reduce using rule 41 (expr -> INT_CONST .)
    }               reduce using rule 41 (expr -> INT_CONST .)
    FI              reduce using rule 41 (expr -> INT_CONST .)


state 45

    (30) expr -> ISVOID . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 63
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 46

    (27) expr -> letexpr .

    ,               reduce using rule 27 (expr -> letexpr .)
    +               reduce using rule 27 (expr -> letexpr .)
    -               reduce using rule 27 (expr -> letexpr .)
    *               reduce using rule 27 (expr -> letexpr .)
    /               reduce using rule 27 (expr -> letexpr .)
    <               reduce using rule 27 (expr -> letexpr .)
    LE              reduce using rule 27 (expr -> letexpr .)
    =               reduce using rule 27 (expr -> letexpr .)
    DOT             reduce using rule 27 (expr -> letexpr .)
    @               reduce using rule 27 (expr -> letexpr .)
    )               reduce using rule 27 (expr -> letexpr .)
    POOL            reduce using rule 27 (expr -> letexpr .)
    ELSE            reduce using rule 27 (expr -> letexpr .)
    ;               reduce using rule 27 (expr -> letexpr .)
    IN              reduce using rule 27 (expr -> letexpr .)
    THEN            reduce using rule 27 (expr -> letexpr .)
    OF              reduce using rule 27 (expr -> letexpr .)
    LOOP            reduce using rule 27 (expr -> letexpr .)
    }               reduce using rule 27 (expr -> letexpr .)
    FI              reduce using rule 27 (expr -> letexpr .)


state 47

    (52) blockexpr -> { . blockstatements }
    (53) blockstatements -> . expr ; blockstatements
    (54) blockstatements -> . expr ;
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    assignment                     shift and go to state 38
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    blockstatements                shift and go to state 64
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    expr                           shift and go to state 65
    caseexpr                       shift and go to state 37
    localmethodinvoke              shift and go to state 49

state 48

    (42) expr -> STR_CONST .

    ,               reduce using rule 42 (expr -> STR_CONST .)
    +               reduce using rule 42 (expr -> STR_CONST .)
    -               reduce using rule 42 (expr -> STR_CONST .)
    *               reduce using rule 42 (expr -> STR_CONST .)
    /               reduce using rule 42 (expr -> STR_CONST .)
    <               reduce using rule 42 (expr -> STR_CONST .)
    LE              reduce using rule 42 (expr -> STR_CONST .)
    =               reduce using rule 42 (expr -> STR_CONST .)
    DOT             reduce using rule 42 (expr -> STR_CONST .)
    @               reduce using rule 42 (expr -> STR_CONST .)
    )               reduce using rule 42 (expr -> STR_CONST .)
    POOL            reduce using rule 42 (expr -> STR_CONST .)
    ELSE            reduce using rule 42 (expr -> STR_CONST .)
    ;               reduce using rule 42 (expr -> STR_CONST .)
    IN              reduce using rule 42 (expr -> STR_CONST .)
    THEN            reduce using rule 42 (expr -> STR_CONST .)
    OF              reduce using rule 42 (expr -> STR_CONST .)
    LOOP            reduce using rule 42 (expr -> STR_CONST .)
    }               reduce using rule 42 (expr -> STR_CONST .)
    FI              reduce using rule 42 (expr -> STR_CONST .)


state 49

    (23) expr -> localmethodinvoke .

    ,               reduce using rule 23 (expr -> localmethodinvoke .)
    +               reduce using rule 23 (expr -> localmethodinvoke .)
    -               reduce using rule 23 (expr -> localmethodinvoke .)
    *               reduce using rule 23 (expr -> localmethodinvoke .)
    /               reduce using rule 23 (expr -> localmethodinvoke .)
    <               reduce using rule 23 (expr -> localmethodinvoke .)
    LE              reduce using rule 23 (expr -> localmethodinvoke .)
    =               reduce using rule 23 (expr -> localmethodinvoke .)
    DOT             reduce using rule 23 (expr -> localmethodinvoke .)
    @               reduce using rule 23 (expr -> localmethodinvoke .)
    )               reduce using rule 23 (expr -> localmethodinvoke .)
    POOL            reduce using rule 23 (expr -> localmethodinvoke .)
    ELSE            reduce using rule 23 (expr -> localmethodinvoke .)
    ;               reduce using rule 23 (expr -> localmethodinvoke .)
    IN              reduce using rule 23 (expr -> localmethodinvoke .)
    THEN            reduce using rule 23 (expr -> localmethodinvoke .)
    OF              reduce using rule 23 (expr -> localmethodinvoke .)
    LOOP            reduce using rule 23 (expr -> localmethodinvoke .)
    }               reduce using rule 23 (expr -> localmethodinvoke .)
    FI              reduce using rule 23 (expr -> localmethodinvoke .)


state 50

    (31) expr -> NOT . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 66
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 51

    (24) expr -> ifthenelse .

    ,               reduce using rule 24 (expr -> ifthenelse .)
    +               reduce using rule 24 (expr -> ifthenelse .)
    -               reduce using rule 24 (expr -> ifthenelse .)
    *               reduce using rule 24 (expr -> ifthenelse .)
    /               reduce using rule 24 (expr -> ifthenelse .)
    <               reduce using rule 24 (expr -> ifthenelse .)
    LE              reduce using rule 24 (expr -> ifthenelse .)
    =               reduce using rule 24 (expr -> ifthenelse .)
    DOT             reduce using rule 24 (expr -> ifthenelse .)
    @               reduce using rule 24 (expr -> ifthenelse .)
    )               reduce using rule 24 (expr -> ifthenelse .)
    POOL            reduce using rule 24 (expr -> ifthenelse .)
    ELSE            reduce using rule 24 (expr -> ifthenelse .)
    ;               reduce using rule 24 (expr -> ifthenelse .)
    IN              reduce using rule 24 (expr -> ifthenelse .)
    THEN            reduce using rule 24 (expr -> ifthenelse .)
    OF              reduce using rule 24 (expr -> ifthenelse .)
    LOOP            reduce using rule 24 (expr -> ifthenelse .)
    }               reduce using rule 24 (expr -> ifthenelse .)
    FI              reduce using rule 24 (expr -> ifthenelse .)


state 52

    (44) expr -> OBJECTID .
    (45) assignment -> OBJECTID . ASSIGN expr
    (49) localmethodinvoke -> OBJECTID . ( actualargs )

    ,               reduce using rule 44 (expr -> OBJECTID .)
    +               reduce using rule 44 (expr -> OBJECTID .)
    -               reduce using rule 44 (expr -> OBJECTID .)
    *               reduce using rule 44 (expr -> OBJECTID .)
    /               reduce using rule 44 (expr -> OBJECTID .)
    <               reduce using rule 44 (expr -> OBJECTID .)
    LE              reduce using rule 44 (expr -> OBJECTID .)
    =               reduce using rule 44 (expr -> OBJECTID .)
    DOT             reduce using rule 44 (expr -> OBJECTID .)
    @               reduce using rule 44 (expr -> OBJECTID .)
    )               reduce using rule 44 (expr -> OBJECTID .)
    POOL            reduce using rule 44 (expr -> OBJECTID .)
    ELSE            reduce using rule 44 (expr -> OBJECTID .)
    ;               reduce using rule 44 (expr -> OBJECTID .)
    IN              reduce using rule 44 (expr -> OBJECTID .)
    THEN            reduce using rule 44 (expr -> OBJECTID .)
    OF              reduce using rule 44 (expr -> OBJECTID .)
    LOOP            reduce using rule 44 (expr -> OBJECTID .)
    }               reduce using rule 44 (expr -> OBJECTID .)
    FI              reduce using rule 44 (expr -> OBJECTID .)
    ASSIGN          shift and go to state 67
    (               shift and go to state 68


state 53

    (13) variableinitialization -> ASSIGN expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               reduce using rule 13 (variableinitialization -> ASSIGN expr .)
    ,               reduce using rule 13 (variableinitialization -> ASSIGN expr .)
    IN              reduce using rule 13 (variableinitialization -> ASSIGN expr .)
    +               shift and go to state 74
    -               shift and go to state 71
    *               shift and go to state 72
    /               shift and go to state 77
    <               shift and go to state 75
    LE              shift and go to state 73
    =               shift and go to state 69
    DOT             shift and go to state 70
    @               shift and go to state 76


state 54

    (46) letexpr -> LET . variablelist IN expr
    (55) variablelist -> . variabledefinition , variablelist
    (56) variablelist -> . variabledefinition
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (12) variabledeclaration -> . OBJECTID : TYPEID

    OBJECTID        shift and go to state 30

    variabledefinition             shift and go to state 79
    variabledeclaration            shift and go to state 16
    variablelist                   shift and go to state 78

state 55

    (10) methoddefinition -> OBJECTID ( formalargs ) . : TYPEID { expr }

    :               shift and go to state 80


state 56

    (15) formalargs -> variabledeclaration , . formalargs
    (15) formalargs -> . variabledeclaration , formalargs
    (16) formalargs -> . variabledeclaration
    (17) formalargs -> . empty
    (12) variabledeclaration -> . OBJECTID : TYPEID
    (60) empty -> .

    OBJECTID        shift and go to state 30
    )               reduce using rule 60 (empty -> .)

    variabledeclaration            shift and go to state 29
    formalargs                     shift and go to state 81
    empty                          shift and go to state 31

state 57

    (50) ifthenelse -> IF expr . THEN expr ELSE expr FI
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    THEN            shift and go to state 82
    +               shift and go to state 74
    -               shift and go to state 71
    *               shift and go to state 72
    /               shift and go to state 77
    <               shift and go to state 75
    LE              shift and go to state 73
    =               shift and go to state 69
    DOT             shift and go to state 70
    @               shift and go to state 76


state 58

    (33) expr -> ( expr . )
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    )               shift and go to state 83
    +               shift and go to state 74
    -               shift and go to state 71
    *               shift and go to state 72
    /               shift and go to state 77
    <               shift and go to state 75
    LE              shift and go to state 73
    =               shift and go to state 69
    DOT             shift and go to state 70
    @               shift and go to state 76


state 59

    (32) expr -> ~ expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 32 (expr -> ~ expr .)
    +               reduce using rule 32 (expr -> ~ expr .)
    -               reduce using rule 32 (expr -> ~ expr .)
    *               reduce using rule 32 (expr -> ~ expr .)
    /               reduce using rule 32 (expr -> ~ expr .)
    <               reduce using rule 32 (expr -> ~ expr .)
    LE              reduce using rule 32 (expr -> ~ expr .)
    =               reduce using rule 32 (expr -> ~ expr .)
    )               reduce using rule 32 (expr -> ~ expr .)
    POOL            reduce using rule 32 (expr -> ~ expr .)
    ELSE            reduce using rule 32 (expr -> ~ expr .)
    ;               reduce using rule 32 (expr -> ~ expr .)
    IN              reduce using rule 32 (expr -> ~ expr .)
    THEN            reduce using rule 32 (expr -> ~ expr .)
    OF              reduce using rule 32 (expr -> ~ expr .)
    LOOP            reduce using rule 32 (expr -> ~ expr .)
    }               reduce using rule 32 (expr -> ~ expr .)
    FI              reduce using rule 32 (expr -> ~ expr .)
    DOT             shift and go to state 70
    @               shift and go to state 76

  ! DOT             [ reduce using rule 32 (expr -> ~ expr .) ]
  ! @               [ reduce using rule 32 (expr -> ~ expr .) ]
  ! +               [ shift and go to state 74 ]
  ! -               [ shift and go to state 71 ]
  ! *               [ shift and go to state 72 ]
  ! /               [ shift and go to state 77 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 73 ]
  ! =               [ shift and go to state 69 ]


state 60

    (57) caseexpr -> CASE expr . OF casestatements ESAC
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    OF              shift and go to state 84
    +               shift and go to state 74
    -               shift and go to state 71
    *               shift and go to state 72
    /               shift and go to state 77
    <               shift and go to state 75
    LE              shift and go to state 73
    =               shift and go to state 69
    DOT             shift and go to state 70
    @               shift and go to state 76


state 61

    (29) expr -> NEW TYPEID .

    ,               reduce using rule 29 (expr -> NEW TYPEID .)
    +               reduce using rule 29 (expr -> NEW TYPEID .)
    -               reduce using rule 29 (expr -> NEW TYPEID .)
    *               reduce using rule 29 (expr -> NEW TYPEID .)
    /               reduce using rule 29 (expr -> NEW TYPEID .)
    <               reduce using rule 29 (expr -> NEW TYPEID .)
    LE              reduce using rule 29 (expr -> NEW TYPEID .)
    =               reduce using rule 29 (expr -> NEW TYPEID .)
    DOT             reduce using rule 29 (expr -> NEW TYPEID .)
    @               reduce using rule 29 (expr -> NEW TYPEID .)
    )               reduce using rule 29 (expr -> NEW TYPEID .)
    POOL            reduce using rule 29 (expr -> NEW TYPEID .)
    ELSE            reduce using rule 29 (expr -> NEW TYPEID .)
    ;               reduce using rule 29 (expr -> NEW TYPEID .)
    IN              reduce using rule 29 (expr -> NEW TYPEID .)
    THEN            reduce using rule 29 (expr -> NEW TYPEID .)
    OF              reduce using rule 29 (expr -> NEW TYPEID .)
    LOOP            reduce using rule 29 (expr -> NEW TYPEID .)
    }               reduce using rule 29 (expr -> NEW TYPEID .)
    FI              reduce using rule 29 (expr -> NEW TYPEID .)


state 62

    (51) whileloop -> WHILE expr . LOOP expr POOL
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    LOOP            shift and go to state 85
    +               shift and go to state 74
    -               shift and go to state 71
    *               shift and go to state 72
    /               shift and go to state 77
    <               shift and go to state 75
    LE              shift and go to state 73
    =               shift and go to state 69
    DOT             shift and go to state 70
    @               shift and go to state 76


state 63

    (30) expr -> ISVOID expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 30 (expr -> ISVOID expr .)
    +               reduce using rule 30 (expr -> ISVOID expr .)
    -               reduce using rule 30 (expr -> ISVOID expr .)
    *               reduce using rule 30 (expr -> ISVOID expr .)
    /               reduce using rule 30 (expr -> ISVOID expr .)
    <               reduce using rule 30 (expr -> ISVOID expr .)
    LE              reduce using rule 30 (expr -> ISVOID expr .)
    =               reduce using rule 30 (expr -> ISVOID expr .)
    )               reduce using rule 30 (expr -> ISVOID expr .)
    POOL            reduce using rule 30 (expr -> ISVOID expr .)
    ELSE            reduce using rule 30 (expr -> ISVOID expr .)
    ;               reduce using rule 30 (expr -> ISVOID expr .)
    IN              reduce using rule 30 (expr -> ISVOID expr .)
    THEN            reduce using rule 30 (expr -> ISVOID expr .)
    OF              reduce using rule 30 (expr -> ISVOID expr .)
    LOOP            reduce using rule 30 (expr -> ISVOID expr .)
    }               reduce using rule 30 (expr -> ISVOID expr .)
    FI              reduce using rule 30 (expr -> ISVOID expr .)
    DOT             shift and go to state 70
    @               shift and go to state 76

  ! DOT             [ reduce using rule 30 (expr -> ISVOID expr .) ]
  ! @               [ reduce using rule 30 (expr -> ISVOID expr .) ]
  ! +               [ shift and go to state 74 ]
  ! -               [ shift and go to state 71 ]
  ! *               [ shift and go to state 72 ]
  ! /               [ shift and go to state 77 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 73 ]
  ! =               [ shift and go to state 69 ]


state 64

    (52) blockexpr -> { blockstatements . }

    }               shift and go to state 86


state 65

    (53) blockstatements -> expr . ; blockstatements
    (54) blockstatements -> expr . ;
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               shift and go to state 87
    +               shift and go to state 74
    -               shift and go to state 71
    *               shift and go to state 72
    /               shift and go to state 77
    <               shift and go to state 75
    LE              shift and go to state 73
    =               shift and go to state 69
    DOT             shift and go to state 70
    @               shift and go to state 76


state 66

    (31) expr -> NOT expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 31 (expr -> NOT expr .)
    )               reduce using rule 31 (expr -> NOT expr .)
    POOL            reduce using rule 31 (expr -> NOT expr .)
    ELSE            reduce using rule 31 (expr -> NOT expr .)
    ;               reduce using rule 31 (expr -> NOT expr .)
    IN              reduce using rule 31 (expr -> NOT expr .)
    THEN            reduce using rule 31 (expr -> NOT expr .)
    OF              reduce using rule 31 (expr -> NOT expr .)
    LOOP            reduce using rule 31 (expr -> NOT expr .)
    }               reduce using rule 31 (expr -> NOT expr .)
    FI              reduce using rule 31 (expr -> NOT expr .)
    +               shift and go to state 74
    -               shift and go to state 71
    *               shift and go to state 72
    /               shift and go to state 77
    <               shift and go to state 75
    LE              shift and go to state 73
    =               shift and go to state 69
    DOT             shift and go to state 70
    @               shift and go to state 76

  ! +               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! -               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! *               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! /               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! <               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! LE              [ reduce using rule 31 (expr -> NOT expr .) ]
  ! =               [ reduce using rule 31 (expr -> NOT expr .) ]
  ! DOT             [ reduce using rule 31 (expr -> NOT expr .) ]
  ! @               [ reduce using rule 31 (expr -> NOT expr .) ]


state 67

    (45) assignment -> OBJECTID ASSIGN . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 88
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 68

    (49) localmethodinvoke -> OBJECTID ( . actualargs )
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    assignment                     shift and go to state 38
    blockexpr                      shift and go to state 34
    empty                          shift and go to state 89
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    ifthenelse                     shift and go to state 51
    caseexpr                       shift and go to state 37
    expr                           shift and go to state 90
    letexpr                        shift and go to state 46
    localmethodinvoke              shift and go to state 49
    actualargs                     shift and go to state 91

state 69

    (40) expr -> expr = . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 92
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 70

    (47) methodinvoke -> expr DOT . OBJECTID ( actualargs )

    OBJECTID        shift and go to state 93


state 71

    (35) expr -> expr - . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 94
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 72

    (36) expr -> expr * . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 95
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 73

    (39) expr -> expr LE . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 96
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 74

    (34) expr -> expr + . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 97
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 75

    (38) expr -> expr < . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 98
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 76

    (48) methodinvoke -> expr @ . TYPEID DOT OBJECTID ( actualargs )

    TYPEID          shift and go to state 99


state 77

    (37) expr -> expr / . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 100
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 78

    (46) letexpr -> LET variablelist . IN expr

    IN              shift and go to state 101


state 79

    (55) variablelist -> variabledefinition . , variablelist
    (56) variablelist -> variabledefinition .

    ,               shift and go to state 102
    IN              reduce using rule 56 (variablelist -> variabledefinition .)


state 80

    (10) methoddefinition -> OBJECTID ( formalargs ) : . TYPEID { expr }

    TYPEID          shift and go to state 103


state 81

    (15) formalargs -> variabledeclaration , formalargs .

    )               reduce using rule 15 (formalargs -> variabledeclaration , formalargs .)


state 82

    (50) ifthenelse -> IF expr THEN . expr ELSE expr FI
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 104
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 83

    (33) expr -> ( expr ) .

    ,               reduce using rule 33 (expr -> ( expr ) .)
    +               reduce using rule 33 (expr -> ( expr ) .)
    -               reduce using rule 33 (expr -> ( expr ) .)
    *               reduce using rule 33 (expr -> ( expr ) .)
    /               reduce using rule 33 (expr -> ( expr ) .)
    <               reduce using rule 33 (expr -> ( expr ) .)
    LE              reduce using rule 33 (expr -> ( expr ) .)
    =               reduce using rule 33 (expr -> ( expr ) .)
    DOT             reduce using rule 33 (expr -> ( expr ) .)
    @               reduce using rule 33 (expr -> ( expr ) .)
    )               reduce using rule 33 (expr -> ( expr ) .)
    POOL            reduce using rule 33 (expr -> ( expr ) .)
    ELSE            reduce using rule 33 (expr -> ( expr ) .)
    ;               reduce using rule 33 (expr -> ( expr ) .)
    IN              reduce using rule 33 (expr -> ( expr ) .)
    THEN            reduce using rule 33 (expr -> ( expr ) .)
    OF              reduce using rule 33 (expr -> ( expr ) .)
    LOOP            reduce using rule 33 (expr -> ( expr ) .)
    }               reduce using rule 33 (expr -> ( expr ) .)
    FI              reduce using rule 33 (expr -> ( expr ) .)


state 84

    (57) caseexpr -> CASE expr OF . casestatements ESAC
    (58) casestatements -> . variabledeclaration DARROW expr ; casestatements
    (59) casestatements -> . variabledeclaration DARROW expr ;
    (12) variabledeclaration -> . OBJECTID : TYPEID

    OBJECTID        shift and go to state 30

    variabledeclaration            shift and go to state 105
    casestatements                 shift and go to state 106

state 85

    (51) whileloop -> WHILE expr LOOP . expr POOL
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 107
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 86

    (52) blockexpr -> { blockstatements } .

    ,               reduce using rule 52 (blockexpr -> { blockstatements } .)
    +               reduce using rule 52 (blockexpr -> { blockstatements } .)
    -               reduce using rule 52 (blockexpr -> { blockstatements } .)
    *               reduce using rule 52 (blockexpr -> { blockstatements } .)
    /               reduce using rule 52 (blockexpr -> { blockstatements } .)
    <               reduce using rule 52 (blockexpr -> { blockstatements } .)
    LE              reduce using rule 52 (blockexpr -> { blockstatements } .)
    =               reduce using rule 52 (blockexpr -> { blockstatements } .)
    DOT             reduce using rule 52 (blockexpr -> { blockstatements } .)
    @               reduce using rule 52 (blockexpr -> { blockstatements } .)
    )               reduce using rule 52 (blockexpr -> { blockstatements } .)
    THEN            reduce using rule 52 (blockexpr -> { blockstatements } .)
    POOL            reduce using rule 52 (blockexpr -> { blockstatements } .)
    }               reduce using rule 52 (blockexpr -> { blockstatements } .)
    ;               reduce using rule 52 (blockexpr -> { blockstatements } .)
    IN              reduce using rule 52 (blockexpr -> { blockstatements } .)
    OF              reduce using rule 52 (blockexpr -> { blockstatements } .)
    LOOP            reduce using rule 52 (blockexpr -> { blockstatements } .)
    ELSE            reduce using rule 52 (blockexpr -> { blockstatements } .)
    FI              reduce using rule 52 (blockexpr -> { blockstatements } .)


state 87

    (53) blockstatements -> expr ; . blockstatements
    (54) blockstatements -> expr ; .
    (53) blockstatements -> . expr ; blockstatements
    (54) blockstatements -> . expr ;
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    }               reduce using rule 54 (blockstatements -> expr ; .)
    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    assignment                     shift and go to state 38
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 65
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    blockstatements                shift and go to state 108
    caseexpr                       shift and go to state 37
    localmethodinvoke              shift and go to state 49

state 88

    (45) assignment -> OBJECTID ASSIGN expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    ,               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    IN              reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    THEN            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    )               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    OF              reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    LOOP            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    ELSE            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    POOL            reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    }               reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    FI              reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .)
    +               shift and go to state 74
    -               shift and go to state 71
    *               shift and go to state 72
    /               shift and go to state 77
    <               shift and go to state 75
    LE              shift and go to state 73
    =               shift and go to state 69
    DOT             shift and go to state 70
    @               shift and go to state 76

  ! +               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! -               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! *               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! /               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! <               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! LE              [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! =               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! DOT             [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]
  ! @               [ reduce using rule 45 (assignment -> OBJECTID ASSIGN expr .) ]


state 89

    (20) actualargs -> empty .

    )               reduce using rule 20 (actualargs -> empty .)


state 90

    (18) actualargs -> expr . , actualargs
    (19) actualargs -> expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               shift and go to state 109
    )               reduce using rule 19 (actualargs -> expr .)
    +               shift and go to state 74
    -               shift and go to state 71
    *               shift and go to state 72
    /               shift and go to state 77
    <               shift and go to state 75
    LE              shift and go to state 73
    =               shift and go to state 69
    DOT             shift and go to state 70
    @               shift and go to state 76


state 91

    (49) localmethodinvoke -> OBJECTID ( actualargs . )

    )               shift and go to state 110


state 92

    (40) expr -> expr = expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 40 (expr -> expr = expr .)
    <               reduce using rule 40 (expr -> expr = expr .)
    LE              reduce using rule 40 (expr -> expr = expr .)
    =               reduce using rule 40 (expr -> expr = expr .)
    )               reduce using rule 40 (expr -> expr = expr .)
    POOL            reduce using rule 40 (expr -> expr = expr .)
    ELSE            reduce using rule 40 (expr -> expr = expr .)
    ;               reduce using rule 40 (expr -> expr = expr .)
    IN              reduce using rule 40 (expr -> expr = expr .)
    THEN            reduce using rule 40 (expr -> expr = expr .)
    OF              reduce using rule 40 (expr -> expr = expr .)
    LOOP            reduce using rule 40 (expr -> expr = expr .)
    }               reduce using rule 40 (expr -> expr = expr .)
    FI              reduce using rule 40 (expr -> expr = expr .)
    +               shift and go to state 74
    -               shift and go to state 71
    *               shift and go to state 72
    /               shift and go to state 77
    DOT             shift and go to state 70
    @               shift and go to state 76

  ! +               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! -               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! *               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! /               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! DOT             [ reduce using rule 40 (expr -> expr = expr .) ]
  ! @               [ reduce using rule 40 (expr -> expr = expr .) ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 73 ]
  ! =               [ shift and go to state 69 ]


state 93

    (47) methodinvoke -> expr DOT OBJECTID . ( actualargs )

    (               shift and go to state 111


state 94

    (35) expr -> expr - expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 35 (expr -> expr - expr .)
    +               reduce using rule 35 (expr -> expr - expr .)
    -               reduce using rule 35 (expr -> expr - expr .)
    <               reduce using rule 35 (expr -> expr - expr .)
    LE              reduce using rule 35 (expr -> expr - expr .)
    =               reduce using rule 35 (expr -> expr - expr .)
    )               reduce using rule 35 (expr -> expr - expr .)
    POOL            reduce using rule 35 (expr -> expr - expr .)
    ELSE            reduce using rule 35 (expr -> expr - expr .)
    ;               reduce using rule 35 (expr -> expr - expr .)
    IN              reduce using rule 35 (expr -> expr - expr .)
    THEN            reduce using rule 35 (expr -> expr - expr .)
    OF              reduce using rule 35 (expr -> expr - expr .)
    LOOP            reduce using rule 35 (expr -> expr - expr .)
    }               reduce using rule 35 (expr -> expr - expr .)
    FI              reduce using rule 35 (expr -> expr - expr .)
    *               shift and go to state 72
    /               shift and go to state 77
    DOT             shift and go to state 70
    @               shift and go to state 76

  ! *               [ reduce using rule 35 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 35 (expr -> expr - expr .) ]
  ! DOT             [ reduce using rule 35 (expr -> expr - expr .) ]
  ! @               [ reduce using rule 35 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 74 ]
  ! -               [ shift and go to state 71 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 73 ]
  ! =               [ shift and go to state 69 ]


state 95

    (36) expr -> expr * expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 36 (expr -> expr * expr .)
    +               reduce using rule 36 (expr -> expr * expr .)
    -               reduce using rule 36 (expr -> expr * expr .)
    *               reduce using rule 36 (expr -> expr * expr .)
    /               reduce using rule 36 (expr -> expr * expr .)
    <               reduce using rule 36 (expr -> expr * expr .)
    LE              reduce using rule 36 (expr -> expr * expr .)
    =               reduce using rule 36 (expr -> expr * expr .)
    )               reduce using rule 36 (expr -> expr * expr .)
    POOL            reduce using rule 36 (expr -> expr * expr .)
    ELSE            reduce using rule 36 (expr -> expr * expr .)
    ;               reduce using rule 36 (expr -> expr * expr .)
    IN              reduce using rule 36 (expr -> expr * expr .)
    THEN            reduce using rule 36 (expr -> expr * expr .)
    OF              reduce using rule 36 (expr -> expr * expr .)
    LOOP            reduce using rule 36 (expr -> expr * expr .)
    }               reduce using rule 36 (expr -> expr * expr .)
    FI              reduce using rule 36 (expr -> expr * expr .)
    DOT             shift and go to state 70
    @               shift and go to state 76

  ! DOT             [ reduce using rule 36 (expr -> expr * expr .) ]
  ! @               [ reduce using rule 36 (expr -> expr * expr .) ]
  ! +               [ shift and go to state 74 ]
  ! -               [ shift and go to state 71 ]
  ! *               [ shift and go to state 72 ]
  ! /               [ shift and go to state 77 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 73 ]
  ! =               [ shift and go to state 69 ]


state 96

    (39) expr -> expr LE expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 39 (expr -> expr LE expr .)
    <               reduce using rule 39 (expr -> expr LE expr .)
    LE              reduce using rule 39 (expr -> expr LE expr .)
    =               reduce using rule 39 (expr -> expr LE expr .)
    )               reduce using rule 39 (expr -> expr LE expr .)
    POOL            reduce using rule 39 (expr -> expr LE expr .)
    ELSE            reduce using rule 39 (expr -> expr LE expr .)
    ;               reduce using rule 39 (expr -> expr LE expr .)
    IN              reduce using rule 39 (expr -> expr LE expr .)
    THEN            reduce using rule 39 (expr -> expr LE expr .)
    OF              reduce using rule 39 (expr -> expr LE expr .)
    LOOP            reduce using rule 39 (expr -> expr LE expr .)
    }               reduce using rule 39 (expr -> expr LE expr .)
    FI              reduce using rule 39 (expr -> expr LE expr .)
    +               shift and go to state 74
    -               shift and go to state 71
    *               shift and go to state 72
    /               shift and go to state 77
    DOT             shift and go to state 70
    @               shift and go to state 76

  ! +               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! -               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! *               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! /               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! DOT             [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! @               [ reduce using rule 39 (expr -> expr LE expr .) ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 73 ]
  ! =               [ shift and go to state 69 ]


state 97

    (34) expr -> expr + expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 34 (expr -> expr + expr .)
    +               reduce using rule 34 (expr -> expr + expr .)
    -               reduce using rule 34 (expr -> expr + expr .)
    <               reduce using rule 34 (expr -> expr + expr .)
    LE              reduce using rule 34 (expr -> expr + expr .)
    =               reduce using rule 34 (expr -> expr + expr .)
    )               reduce using rule 34 (expr -> expr + expr .)
    POOL            reduce using rule 34 (expr -> expr + expr .)
    ELSE            reduce using rule 34 (expr -> expr + expr .)
    ;               reduce using rule 34 (expr -> expr + expr .)
    IN              reduce using rule 34 (expr -> expr + expr .)
    THEN            reduce using rule 34 (expr -> expr + expr .)
    OF              reduce using rule 34 (expr -> expr + expr .)
    LOOP            reduce using rule 34 (expr -> expr + expr .)
    }               reduce using rule 34 (expr -> expr + expr .)
    FI              reduce using rule 34 (expr -> expr + expr .)
    *               shift and go to state 72
    /               shift and go to state 77
    DOT             shift and go to state 70
    @               shift and go to state 76

  ! *               [ reduce using rule 34 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 34 (expr -> expr + expr .) ]
  ! DOT             [ reduce using rule 34 (expr -> expr + expr .) ]
  ! @               [ reduce using rule 34 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 74 ]
  ! -               [ shift and go to state 71 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 73 ]
  ! =               [ shift and go to state 69 ]


state 98

    (38) expr -> expr < expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 38 (expr -> expr < expr .)
    <               reduce using rule 38 (expr -> expr < expr .)
    LE              reduce using rule 38 (expr -> expr < expr .)
    =               reduce using rule 38 (expr -> expr < expr .)
    )               reduce using rule 38 (expr -> expr < expr .)
    POOL            reduce using rule 38 (expr -> expr < expr .)
    ELSE            reduce using rule 38 (expr -> expr < expr .)
    ;               reduce using rule 38 (expr -> expr < expr .)
    IN              reduce using rule 38 (expr -> expr < expr .)
    THEN            reduce using rule 38 (expr -> expr < expr .)
    OF              reduce using rule 38 (expr -> expr < expr .)
    LOOP            reduce using rule 38 (expr -> expr < expr .)
    }               reduce using rule 38 (expr -> expr < expr .)
    FI              reduce using rule 38 (expr -> expr < expr .)
    +               shift and go to state 74
    -               shift and go to state 71
    *               shift and go to state 72
    /               shift and go to state 77
    DOT             shift and go to state 70
    @               shift and go to state 76

  ! +               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! DOT             [ reduce using rule 38 (expr -> expr < expr .) ]
  ! @               [ reduce using rule 38 (expr -> expr < expr .) ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 73 ]
  ! =               [ shift and go to state 69 ]


state 99

    (48) methodinvoke -> expr @ TYPEID . DOT OBJECTID ( actualargs )

    DOT             shift and go to state 112


state 100

    (37) expr -> expr / expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ,               reduce using rule 37 (expr -> expr / expr .)
    +               reduce using rule 37 (expr -> expr / expr .)
    -               reduce using rule 37 (expr -> expr / expr .)
    *               reduce using rule 37 (expr -> expr / expr .)
    /               reduce using rule 37 (expr -> expr / expr .)
    <               reduce using rule 37 (expr -> expr / expr .)
    LE              reduce using rule 37 (expr -> expr / expr .)
    =               reduce using rule 37 (expr -> expr / expr .)
    )               reduce using rule 37 (expr -> expr / expr .)
    POOL            reduce using rule 37 (expr -> expr / expr .)
    ELSE            reduce using rule 37 (expr -> expr / expr .)
    ;               reduce using rule 37 (expr -> expr / expr .)
    IN              reduce using rule 37 (expr -> expr / expr .)
    THEN            reduce using rule 37 (expr -> expr / expr .)
    OF              reduce using rule 37 (expr -> expr / expr .)
    LOOP            reduce using rule 37 (expr -> expr / expr .)
    }               reduce using rule 37 (expr -> expr / expr .)
    FI              reduce using rule 37 (expr -> expr / expr .)
    DOT             shift and go to state 70
    @               shift and go to state 76

  ! DOT             [ reduce using rule 37 (expr -> expr / expr .) ]
  ! @               [ reduce using rule 37 (expr -> expr / expr .) ]
  ! +               [ shift and go to state 74 ]
  ! -               [ shift and go to state 71 ]
  ! *               [ shift and go to state 72 ]
  ! /               [ shift and go to state 77 ]
  ! <               [ shift and go to state 75 ]
  ! LE              [ shift and go to state 73 ]
  ! =               [ shift and go to state 69 ]


state 101

    (46) letexpr -> LET variablelist IN . expr
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    ifthenelse                     shift and go to state 51
    caseexpr                       shift and go to state 37
    expr                           shift and go to state 113
    letexpr                        shift and go to state 46
    assignment                     shift and go to state 38

state 102

    (55) variablelist -> variabledefinition , . variablelist
    (55) variablelist -> . variabledefinition , variablelist
    (56) variablelist -> . variabledefinition
    (11) variabledefinition -> . variabledeclaration variableinitialization
    (12) variabledeclaration -> . OBJECTID : TYPEID

    OBJECTID        shift and go to state 30

    variabledeclaration            shift and go to state 16
    variabledefinition             shift and go to state 79
    variablelist                   shift and go to state 114

state 103

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID . { expr }

    {               shift and go to state 115


state 104

    (50) ifthenelse -> IF expr THEN expr . ELSE expr FI
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ELSE            shift and go to state 116
    +               shift and go to state 74
    -               shift and go to state 71
    *               shift and go to state 72
    /               shift and go to state 77
    <               shift and go to state 75
    LE              shift and go to state 73
    =               shift and go to state 69
    DOT             shift and go to state 70
    @               shift and go to state 76


state 105

    (58) casestatements -> variabledeclaration . DARROW expr ; casestatements
    (59) casestatements -> variabledeclaration . DARROW expr ;

    DARROW          shift and go to state 117


state 106

    (57) caseexpr -> CASE expr OF casestatements . ESAC

    ESAC            shift and go to state 118


state 107

    (51) whileloop -> WHILE expr LOOP expr . POOL
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    POOL            shift and go to state 119
    +               shift and go to state 74
    -               shift and go to state 71
    *               shift and go to state 72
    /               shift and go to state 77
    <               shift and go to state 75
    LE              shift and go to state 73
    =               shift and go to state 69
    DOT             shift and go to state 70
    @               shift and go to state 76


state 108

    (53) blockstatements -> expr ; blockstatements .

    }               reduce using rule 53 (blockstatements -> expr ; blockstatements .)


state 109

    (18) actualargs -> expr , . actualargs
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    assignment                     shift and go to state 38
    blockexpr                      shift and go to state 34
    empty                          shift and go to state 89
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    ifthenelse                     shift and go to state 51
    caseexpr                       shift and go to state 37
    expr                           shift and go to state 90
    letexpr                        shift and go to state 46
    localmethodinvoke              shift and go to state 49
    actualargs                     shift and go to state 120

state 110

    (49) localmethodinvoke -> OBJECTID ( actualargs ) .

    ,               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    +               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    -               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    *               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    /               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    <               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    LE              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    =               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    DOT             reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    @               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    )               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    ;               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    IN              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    THEN            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    OF              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    LOOP            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    ELSE            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    POOL            reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    }               reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)
    FI              reduce using rule 49 (localmethodinvoke -> OBJECTID ( actualargs ) .)


state 111

    (47) methodinvoke -> expr DOT OBJECTID ( . actualargs )
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    assignment                     shift and go to state 38
    blockexpr                      shift and go to state 34
    empty                          shift and go to state 89
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    ifthenelse                     shift and go to state 51
    caseexpr                       shift and go to state 37
    expr                           shift and go to state 90
    letexpr                        shift and go to state 46
    localmethodinvoke              shift and go to state 49
    actualargs                     shift and go to state 121

state 112

    (48) methodinvoke -> expr @ TYPEID DOT . OBJECTID ( actualargs )

    OBJECTID        shift and go to state 122


state 113

    (46) letexpr -> LET variablelist IN expr .
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ELSE            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    ;               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    ,               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    IN              reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    THEN            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    )               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    OF              reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    LOOP            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    POOL            reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    }               reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    FI              reduce using rule 46 (letexpr -> LET variablelist IN expr .)
    +               shift and go to state 74
    -               shift and go to state 71
    *               shift and go to state 72
    /               shift and go to state 77
    <               shift and go to state 75
    LE              shift and go to state 73
    =               shift and go to state 69
    DOT             shift and go to state 70
    @               shift and go to state 76

  ! +               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! -               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! *               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! /               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! <               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! LE              [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! =               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! DOT             [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]
  ! @               [ reduce using rule 46 (letexpr -> LET variablelist IN expr .) ]


state 114

    (55) variablelist -> variabledefinition , variablelist .

    IN              reduce using rule 55 (variablelist -> variabledefinition , variablelist .)


state 115

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID { . expr }
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    ifthenelse                     shift and go to state 51
    caseexpr                       shift and go to state 37
    expr                           shift and go to state 123
    letexpr                        shift and go to state 46
    assignment                     shift and go to state 38

state 116

    (50) ifthenelse -> IF expr THEN expr ELSE . expr FI
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    blockexpr                      shift and go to state 34
    localmethodinvoke              shift and go to state 49
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    expr                           shift and go to state 124
    ifthenelse                     shift and go to state 51
    letexpr                        shift and go to state 46
    caseexpr                       shift and go to state 37
    assignment                     shift and go to state 38

state 117

    (58) casestatements -> variabledeclaration DARROW . expr ; casestatements
    (59) casestatements -> variabledeclaration DARROW . expr ;
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    assignment                     shift and go to state 38
    blockexpr                      shift and go to state 34
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    ifthenelse                     shift and go to state 51
    caseexpr                       shift and go to state 37
    expr                           shift and go to state 125
    letexpr                        shift and go to state 46
    localmethodinvoke              shift and go to state 49

state 118

    (57) caseexpr -> CASE expr OF casestatements ESAC .

    THEN            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    +               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    -               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    *               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    /               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    <               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    LE              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    =               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    DOT             reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    @               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    ;               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    ,               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    IN              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    )               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    OF              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    LOOP            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    ELSE            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    POOL            reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    }               reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)
    FI              reduce using rule 57 (caseexpr -> CASE expr OF casestatements ESAC .)


state 119

    (51) whileloop -> WHILE expr LOOP expr POOL .

    +               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    -               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    *               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    /               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    <               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    LE              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    =               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    DOT             reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    @               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    ;               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    ,               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    IN              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    THEN            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    )               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    OF              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    LOOP            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    ELSE            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    POOL            reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    }               reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)
    FI              reduce using rule 51 (whileloop -> WHILE expr LOOP expr POOL .)


state 120

    (18) actualargs -> expr , actualargs .

    )               reduce using rule 18 (actualargs -> expr , actualargs .)


state 121

    (47) methodinvoke -> expr DOT OBJECTID ( actualargs . )

    )               shift and go to state 126


state 122

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID . ( actualargs )

    (               shift and go to state 127


state 123

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr . }
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    }               shift and go to state 128
    +               shift and go to state 74
    -               shift and go to state 71
    *               shift and go to state 72
    /               shift and go to state 77
    <               shift and go to state 75
    LE              shift and go to state 73
    =               shift and go to state 69
    DOT             shift and go to state 70
    @               shift and go to state 76


state 124

    (50) ifthenelse -> IF expr THEN expr ELSE expr . FI
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    FI              shift and go to state 129
    +               shift and go to state 74
    -               shift and go to state 71
    *               shift and go to state 72
    /               shift and go to state 77
    <               shift and go to state 75
    LE              shift and go to state 73
    =               shift and go to state 69
    DOT             shift and go to state 70
    @               shift and go to state 76


state 125

    (58) casestatements -> variabledeclaration DARROW expr . ; casestatements
    (59) casestatements -> variabledeclaration DARROW expr . ;
    (34) expr -> expr . + expr
    (35) expr -> expr . - expr
    (36) expr -> expr . * expr
    (37) expr -> expr . / expr
    (38) expr -> expr . < expr
    (39) expr -> expr . LE expr
    (40) expr -> expr . = expr
    (47) methodinvoke -> expr . DOT OBJECTID ( actualargs )
    (48) methodinvoke -> expr . @ TYPEID DOT OBJECTID ( actualargs )

    ;               shift and go to state 130
    +               shift and go to state 74
    -               shift and go to state 71
    *               shift and go to state 72
    /               shift and go to state 77
    <               shift and go to state 75
    LE              shift and go to state 73
    =               shift and go to state 69
    DOT             shift and go to state 70
    @               shift and go to state 76


state 126

    (47) methodinvoke -> expr DOT OBJECTID ( actualargs ) .

    +               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    -               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    *               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    /               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    <               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    LE              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    =               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    DOT             reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    @               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    ;               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    ,               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    IN              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    THEN            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    )               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    OF              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    LOOP            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    ELSE            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    POOL            reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    }               reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)
    FI              reduce using rule 47 (methodinvoke -> expr DOT OBJECTID ( actualargs ) .)


state 127

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID ( . actualargs )
    (18) actualargs -> . expr , actualargs
    (19) actualargs -> . expr
    (20) actualargs -> . empty
    (21) expr -> . assignment
    (22) expr -> . methodinvoke
    (23) expr -> . localmethodinvoke
    (24) expr -> . ifthenelse
    (25) expr -> . whileloop
    (26) expr -> . blockexpr
    (27) expr -> . letexpr
    (28) expr -> . caseexpr
    (29) expr -> . NEW TYPEID
    (30) expr -> . ISVOID expr
    (31) expr -> . NOT expr
    (32) expr -> . ~ expr
    (33) expr -> . ( expr )
    (34) expr -> . expr + expr
    (35) expr -> . expr - expr
    (36) expr -> . expr * expr
    (37) expr -> . expr / expr
    (38) expr -> . expr < expr
    (39) expr -> . expr LE expr
    (40) expr -> . expr = expr
    (41) expr -> . INT_CONST
    (42) expr -> . STR_CONST
    (43) expr -> . BOOL_CONST
    (44) expr -> . OBJECTID
    (60) empty -> .
    (45) assignment -> . OBJECTID ASSIGN expr
    (47) methodinvoke -> . expr DOT OBJECTID ( actualargs )
    (48) methodinvoke -> . expr @ TYPEID DOT OBJECTID ( actualargs )
    (49) localmethodinvoke -> . OBJECTID ( actualargs )
    (50) ifthenelse -> . IF expr THEN expr ELSE expr FI
    (51) whileloop -> . WHILE expr LOOP expr POOL
    (52) blockexpr -> . { blockstatements }
    (46) letexpr -> . LET variablelist IN expr
    (57) caseexpr -> . CASE expr OF casestatements ESAC

    NEW             shift and go to state 40
    ISVOID          shift and go to state 45
    NOT             shift and go to state 50
    ~               shift and go to state 36
    (               shift and go to state 33
    INT_CONST       shift and go to state 44
    STR_CONST       shift and go to state 48
    BOOL_CONST      shift and go to state 41
    OBJECTID        shift and go to state 52
    )               reduce using rule 60 (empty -> .)
    IF              shift and go to state 32
    WHILE           shift and go to state 43
    {               shift and go to state 47
    LET             shift and go to state 54
    CASE            shift and go to state 39

    assignment                     shift and go to state 38
    blockexpr                      shift and go to state 34
    empty                          shift and go to state 89
    whileloop                      shift and go to state 42
    methodinvoke                   shift and go to state 35
    ifthenelse                     shift and go to state 51
    caseexpr                       shift and go to state 37
    expr                           shift and go to state 90
    letexpr                        shift and go to state 46
    localmethodinvoke              shift and go to state 49
    actualargs                     shift and go to state 131

state 128

    (10) methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr } .

    ;               reduce using rule 10 (methoddefinition -> OBJECTID ( formalargs ) : TYPEID { expr } .)


state 129

    (50) ifthenelse -> IF expr THEN expr ELSE expr FI .

    +               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    -               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    *               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    /               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    <               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    LE              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    =               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    DOT             reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    @               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    ;               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    ,               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    IN              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    THEN            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    )               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    OF              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    LOOP            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    ELSE            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    POOL            reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    }               reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)
    FI              reduce using rule 50 (ifthenelse -> IF expr THEN expr ELSE expr FI .)


state 130

    (58) casestatements -> variabledeclaration DARROW expr ; . casestatements
    (59) casestatements -> variabledeclaration DARROW expr ; .
    (58) casestatements -> . variabledeclaration DARROW expr ; casestatements
    (59) casestatements -> . variabledeclaration DARROW expr ;
    (12) variabledeclaration -> . OBJECTID : TYPEID

    ESAC            reduce using rule 59 (casestatements -> variabledeclaration DARROW expr ; .)
    OBJECTID        shift and go to state 30

    variabledeclaration            shift and go to state 105
    casestatements                 shift and go to state 132

state 131

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs . )

    )               shift and go to state 133


state 132

    (58) casestatements -> variabledeclaration DARROW expr ; casestatements .

    ESAC            reduce using rule 58 (casestatements -> variabledeclaration DARROW expr ; casestatements .)


state 133

    (48) methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .

    +               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    -               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    *               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    /               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    <               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    LE              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    =               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    DOT             reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    @               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    ;               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    ,               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    IN              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    THEN            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    )               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    OF              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    LOOP            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    ELSE            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    POOL            reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    }               reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)
    FI              reduce using rule 48 (methodinvoke -> expr @ TYPEID DOT OBJECTID ( actualargs ) .)

